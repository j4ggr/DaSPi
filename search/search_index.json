{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DaSPi","text":""},{"location":"#daspi","title":"<code>daspi</code>","text":""},{"location":"#daspi--data-analysis-statistics-and-process-improvements-daspi","title":"Data analysis, Statistics and Process improvements (DaSPi)","text":"<p>Visualize and analyze your data with DaSPi. This package is designed for users who want to find relevant influencing factors in processes and validate improvements. This package offers many Six Sigma tools based on the following packages:</p> <ul> <li>pandas</li> <li>numpy</li> <li>matplotlib</li> <li>scipy</li> <li>statsmodels</li> </ul> <p>The goal of this package is to be easy to use and flexible so that it can be adapted to a wide array of data analysis tasks.</p>"},{"location":"#daspi--why-daspi","title":"Why DaSPi?","text":"<p>There are great packages for data analysis and visualization in Python, such as Pandas, Seaborn, Altair, Statsmodels, Scipy, Pinguins. But most of the time they work not directly with each other. Wouldn't it be great if you could use all of these packages together in one place? That's where DaSPi comes in. DaSPi is a Python package that provides a unified interface for data analysis, statistics and visualization. It allows you to use all of the great packages mentioned above together in one place, making it easier to explore and understand your data.</p>"},{"location":"#daspi--features","title":"Features","text":"<ul> <li>Ease of Use: DaSPi is designed to be easy to use, even for beginners. It provides a simple and intuitive interface that makes it easy to get started with data analysis.</li> <li>Visualization: DaSPi provides a wide range of visualization options, including multivariate charts, joint charts, and useful precast. This makes it easy to explore and understand your data in a visual way.</li> <li>Statistics: DaSPi provides a wide range of statistical functions and tests, including hypothesis testing, confidence intervals, and regression analysis. This makes it easy to explore and understand your data in a statistical way.</li> <li>Open Source: DaSPi is open source, which means that it is free to use and modify. This makes it a great option for users who want to customize the package to their specific needs.</li> </ul> <p>This Package contains following submodules:</p> <ul> <li>plotlib: Visualizations with Matplotlib, where the division by color, marker size or shape as well as rows and columns subplots are automated depending on the given categorical data. Any plots can also be combined, such as scatter with contour plot, violin with error bars or other creative combinations.</li> <li>anova: analysis of variance (ANOVA), which is used to compare the variance within and between of two or more groups, or the effects of different treatments on a response variable. It also includes a function for calculating the variance inflation factor (VIF) for linear regression models. The main class is LinearModel, which provides methods for fitting linear regression with interactions and automatically elimiinating insignificant variables.</li> <li>statistics: applied statistics, hypothesis test, confidence calculations and monte-carlo simulation. It also includes estimation for process capability and capability index.</li> <li>datasets: data for exersices. It includes different datasets that can be used for testing and experimentation.</li> </ul>"},{"location":"#daspi--usage","title":"Usage","text":""},{"location":"#daspi--visualization","title":"Visualization","text":"<p>To use DaSPi, you can import the package and start exploring your data. Here is an example of how to use DaSPi to visualize a dataset:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('iris')\n\nchart = dsp.MultivariateChart(\n        source=df,\n        target='length',\n        feature='width',\n        hue='species',\n        col='leaf',\n        markers=('x',)\n    ).plot(\n        dsp.GaussianKDEContour\n    ).plot(\n        dsp.Scatter\n    ).label(\n        feature_label='leaf width (cm)',\n        target_label='leaf length (cm)',\n    )\n</code></pre> <p></p>"},{"location":"#daspi--anova","title":"ANOVA","text":"<p>Do some ANOVA and statistics on a dataset. Run the example below in a Jupyther Notebook to see the results.</p> <pre><code>df = dsp.load_dataset('painkillers-dissolution')\nmodel = dsp.LinearModel(\n    source=df,\n    target='dissolution',\n    features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n    disturbances=['temperature', 'preparation'],\n    order=2)\ndf_gof = pd.concat(model.recursive_elimination())\n\ndsp.ResidualsCharts(model).plot().stripes().label(info=True)\ndsp.ParameterRelevanceCharts(model).plot().label(info=True)\nmodel\n</code></pre> <p>Formula:</p> <p>dissolution ~ 16.0792 + 2.3750 employee[T.B] + 0.8375 employee[T.C] + 10.7500 brand[T.OuchAway] - 3.8000 water[T.tap] - 5.7167 brand[T.OuchAway]:water[T.tap]</p> <p>Model Summary</p> Hierarchical Least Parameter P Least S AIC R\u00b2 R\u00b2 Adj R\u00b2 Pred True employee 0.023298 2.374693 224.835935 0.857379 0.840400 0.813719 <p>Parameter Statistics</p> Coef Std Err T P CI Low CI Upp Intercept 16.079167 0.839581 19.151424 0.000000 14.384824 17.773509 employee[T.B] 2.375000 0.839581 2.828793 0.007133 0.680657 4.069343 employee[T.C] 0.837500 0.839581 0.997522 0.324224 -0.856843 2.531843 brand[T.OuchAway] 10.750000 0.969464 11.088598 0.000000 8.793542 12.706458 water[T.tap] -3.800000 0.969464 -3.919690 0.000321 -5.756458 -1.843542 brand[T.OuchAway]:water[T.tap] -5.716667 1.371030 -4.169616 0.000149 -8.483516 -2.949817 <p>Analysis of Variance</p> Source DF SS MS F P n\u00b2 employee 2 46.431667 23.215833 4.116891 0.023298 0.027960 brand 1 747.340833 747.340833 132.526821 0.000000 0.450027 water 1 532.000833 532.000833 94.340328 0.000000 0.320355 brand:water 1 98.040833 98.040833 17.385695 0.000149 0.059037 Residual 42 236.845000 5.639167 nan nan 0.142621 <p>Variance Inflation Factor</p> DF VIF GVIF Threshold Collinear Method Intercept 1 5.000000 2.236068 2.236068 True R_squared employee 2 1.000000 1.000000 1.495349 False generalized brand 1 1.000000 1.000000 2.236068 False R_squared water 1 1.000000 1.000000 2.236068 False R_squared brand:water 1 1.000000 1.000000 2.236068 False single_order-2_term <p></p> <p></p>"},{"location":"#daspi--process-capability","title":"Process capability","text":"<p>Analyze process variation and other key performance indicators for process capacity.</p> <pre><code>df = dsp.load_dataset('drop_card')\nspec_limits = dsp.SpecLimits(0, float(df.loc[0, 'usl']))\ntarget = 'distance'\n\nchart = dsp.ProcessCapabilityAnalysisCharts(\n        source=df,\n        target=target,\n        spec_limits=spec_limits,\n        hue='method'\n    ).plot(\n    ).stripes(\n    ).label(\n        fig_title='Process Capability Analysis',\n        sub_title='Drop Card Experiment',\n        target_label='Distance (cm)',\n        info=True\n    )\n\nsamples_parallel = df[df['method']=='parallel'][target]\nsamples_series = df[df['method']=='perpendicular'][target]\npd.concat([\n    dsp.ProcessEstimator(samples_parallel, spec_limits).describe(),\n    dsp.ProcessEstimator(samples_series, spec_limits).describe()],\n    axis=1,\n    ignore_index=True,\n).rename(\n    columns={0: 'parallel', 1: 'perpendicular'}\n)\n</code></pre> parallel perpendicular n_samples 20 20 n_missing 0 0 n_ok 18 20 n_nok 2 0 n_errors 0 0 ok 90.00 % 100.00 % nok 10.00 % 0.00 % nok_norm 8.01 % 3.73 % nok_fit 7.24 % 5.77 % min 8.5 17.5 max 83.0 73.0 mean 42.935 48.485 median 40.75 52.5 std 22.666583 17.359489 sem 5.068402 3.8817 excess -0.900801 -1.236078 p_excess 0.288757 0.072573 skew 0.19252 -0.377538 p_skew 0.690373 0.438723 p_ad 0.754044 0.098371 dist lognorm logistic p_ks 0.964797 0.744326 strategy norm norm lcl -25.064748 -3.593468 ucl 110.934748 100.563468 lsl 0 0 usl 80.0 80.0 cp 0.588237 0.768072 cpk 0.545076 0.605145 Z 1.635227 1.815434 Z_lt 0.135227 0.315434 <p></p>"},{"location":"#daspi--about-daspi","title":"About DaSPi","text":"<p>DaSPi was created and is actively maintained by Reto J\u00e4ggli, a Data Scientist at Festo Microtechnology AG.  Much of the development happens during spare time, driven by a passion for making data analysis, statistics, and process improvement more accessible and integrated.</p> <p>Contributions to DaSPi are very welcome! If you find bugs or have ideas for improvements, please report them or submit pull requests on the GitHub repository, where the full source code is also available for review.</p> <p>Important Notice: DaSPi is still under heavy development and may contain hidden bugs.  While every effort is made to ensure reliability, no warranty is provided.  The results obtained using DaSPi should be double-checked with other trusted statistical software whenever possible.  Where applicable, DaSPi acts as a convenient wrapper around well-established packages such as pandas, numpy, matplotlib, scipy, and statsmodels, leveraging their robustness and functionality.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Types of changes:</p> <ul> <li>Added for new features.</li> <li>Changed for changes in existing functionality.</li> <li>Deprecated for soon-to-be removed features.</li> <li>Removed for now removed features.</li> <li>Fixed for any bug fixes.</li> <li>Security in case of vulnerabilities.</li> </ul>"},{"location":"CHANGELOG/#180-2025-11-04","title":"[1.8.0] - 2025-11-04","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>The DOE module with classes and functions for design of experiments.</li> <li>The Factor class to DOE module.</li> <li>The BaseDesignBuilder class to DOE module.</li> <li>The FullFactorialDesignBuilder class to DOE module.</li> <li>The FullFactorial2kDesignBuilder class to DOE module.</li> <li>The FractionalFactorialDesignBuilder class to DOE module.</li> <li>Numerous tests were conducted across the entire package, test coverage is now at ~95%</li> <li>The Property <code>errors</code> to ProcessEstimator class to show errors as percentage values.</li> <li>'About DaSPi' section to documentation.</li> <li>Assert tests to check whether some data are empty or not for SingleChart class.</li> <li>The method <code>check_current_data()</code> to SingleChart class to check if current data is empty, throws a UserWarning if so.</li> <li>The option to set a colname when generating the descriptive statistics using <code>describe()</code> method of Estimator classes.</li> <li>The option to set a colname when generating the process descriptions using <code>process_descriptions()</code> method of Process classes.</li> <li>The option to rotate, align and format tick labels. This option is applied to <code>SingleChart</code>, <code>MultivariateChart</code>  and of course the underlying <code>LabelFacets</code> classes.</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>The property <code>processes</code> of ProcessEstimator class to a method.</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Creating uncertainties DataFrame for GageRnRCharts failed in certain cases.</li> <li>The functions <code>stdev_ci</code> and <code>variance_ci</code> had wrong calculations.</li> <li>The stacked bars in Bar plotter were not always displayed correctly. With this fix, t_base is now calculated correctly.</li> </ul>"},{"location":"CHANGELOG/#170-2025-07-01","title":"[1.7.0] - 2025-07-01","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>The name of Estimator class to LocationDispersionEstimator and this class inherits also from BaseEstimator class.</li> <li>The property name descriptive_statistic_attrs of Estimator classes to attrs_describe.</li> <li>The GageRnRModel calculates the uncertainties now after the VDA 5 standard.</li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>The BaseEstimator class to estimation module.</li> <li>The DistributionEstimator class to estimation module.</li> <li>The root_mean_square() function to estmation modul.</li> <li>The GageStudyModel class to model module.</li> <li>The BaseHTMLReprModel class to model module, all Model classe inherit from this class.</li> <li>The CategoricalObservation class to plotter module.</li> <li>The option to stretch the figsize by an amount for AxesFacets and all Chart classes.</li> <li>The MeasurementUncertainty class to estimation module.</li> <li>The property k (coverage factor) to LocationDispersionEstimation class.</li> <li>The options strategy, agreement and possible_dists to GageEstimator class</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>The calculation of measuremen unsertainties at GageEstimator class.</li> </ul>"},{"location":"CHANGELOG/#160-2025-06-05","title":"[1.6.0] - 2025-06-05","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Renamed the module templates to precast.</li> <li>Renamed Parameter class to Specification.</li> <li>The groupby option observed to Ture within Chart and Plotter classes, because of FutureWarnings.</li> <li>LinearModel does not require calling fit method by default aufter initialization.</li> <li>The attribute name tick_lables to tick_labels at Dodger class</li> </ul>"},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>The inclination_displacement() function to montecarlo module.</li> <li>The coaxial() and perpendicular() methods to RandomProcessValue class at montecarlo module.</li> <li>The GageEstimator class to estimation module.</li> <li>The GageRnRModel class to model module.</li> <li>The GageRnRCharts class to precast module.</li> <li>The t_test() function to hypothesis module.</li> <li>Unittests across many classes.</li> <li>Documentation for plotting guide and a lot of examples across many classes.</li> <li>The datasets grnr_adjustment.csv, grnr_layer_thickness.csv and grnr_spec.csv</li> <li>The option margin to estimate_kernel_density and that this option can also be used in the GaussianKDE and GaussianKDEContour plotters.</li> <li>The option to get the full data range for Estimator lcl and ucl when setting strategy to 'data' and agreement to '1.0' or flota('inf')</li> <li>The mask_missing(), mask_ok() methods to Estimator class.</li> <li>The mask_error(), mask_nok() and mask_ok() method to ProcessEstimator class.</li> <li>The pos_to_ticklabes() method for Dodger class.</li> <li>The Stem class to plotter module.</li> </ul>"},{"location":"CHANGELOG/#150-2025-04-29","title":"[1.5.0] - 2025-04-29","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>LabelAxes draws all labels within the figure and adjusts then the subplots. This ensures that all labels are allways rendered.</li> </ul>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Term names for VIF and ANOVA tables are now converted correctly even if there are spaces in the factor levels</li> </ul>"},{"location":"CHANGELOG/#145-2025-04-10","title":"[1.4.5] - 2025-04-10","text":""},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>The images should now be displayed on GH pages and PyPI.</li> </ul>"},{"location":"CHANGELOG/#144-2025-04-10","title":"[1.4.4] - 2025-04-10","text":""},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed documentation and docstrings to eliminate mkdocs warnings when building documentation.</li> <li>Typing in montecarlo module was not sutable for numpy v2.0.0</li> </ul>"},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Enhanced README.</li> </ul>"},{"location":"CHANGELOG/#143-2025-04-04","title":"[1.4.3] - 2025-04-04","text":""},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>RandomProcessValue requires a Parameter instance instead of nominal and tolerance</li> </ul>"},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Tests for RandomProcessValue class</li> <li>Examples to docstring of RandomProcessValue class</li> </ul>"},{"location":"CHANGELOG/#142-2025-04-03","title":"[1.4.2] - 2025-04-03","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Binning class for binning precise values into a specified number of bins.</li> <li>Tests for Binning class.</li> </ul>"},{"location":"CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li>The functions float_to_bins and precise_to_bin_nominals from montecarlo module. They are now part of Binning class.</li> </ul>"},{"location":"CHANGELOG/#141-2025-04-02","title":"[1.4.1] - 2025-04-02","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>The option kind to choose between 'linear' and 'quantile' aproach for float_to_bins function in montecarlo module.</li> <li>The function precise_to_bin_nominals in montecarlo module.</li> </ul>"},{"location":"CHANGELOG/#140-2025-04-02","title":"[1.4.0] - 2025-04-02","text":""},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>LinearModel returned wrong parameters at highest_parameters method.</li> <li>Categoical features are now correctly handled by GaussianKDE.</li> <li>LinearModel failed when converting dtype to 'category' in optimize method.</li> <li>LinearModel residual_data method failed for non-numeric index values \u200b\u200bbecause they were used for \"observation.\" Now, a separate data series is created.</li> <li>ProcessEstimator n_nok was calculated incorrectly if usl was not present or 0.</li> <li>ProcessEstimator check if lsl and usl are boolean True can lead to incorrectly predictive nok values.</li> </ul>"},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>LinearModel method name highest_features to highest_parameters.</li> <li>The option center_points to show_center at CenterLocation plotter, due to consistency.</li> <li>Individual options for mean, median and control_limits at stripes method for ProcessCapabilityAnalysisCharts</li> <li>GaussianKDE and Violine uses now the same call method for plotting.</li> <li>No tuple allowed anywhere where spec_limits must be defined.</li> <li>ProcessEstimator property name \"nok_pred\" to \"nok_fit.</li> </ul>"},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li>The _kw_fill method to SpreadOpacity class.</li> <li>The stripes method for ParameterRelevanceCharts.</li> <li>The option dist when instantiating ProcessCapabilityAnalysisCharts.</li> <li>The property nok_norm to ProcessEstimator class.</li> <li>The p_ks to the returned values of describe method of ProcessEstimator class.</li> <li>Tests for LinearModel highest_parameter, optimize and predict methods.</li> <li>Tests for ProcessEstimator nok_fit and nok_norm property.</li> </ul>"},{"location":"CHANGELOG/#130-2025-02-12","title":"[1.3.0] - 2025-02-12","text":""},{"location":"CHANGELOG/#fixed_5","title":"Fixed","text":"<ul> <li>PairComparisonChart failed when plotting MeanTest, because of n_groups was not set.</li> <li>The method anova() of LinearModel class failed for typ \"I\" under certain conditions. Automatically changed to \"III\" for the moment.</li> <li>The function transpose_xy_axes_params() did wrong stuff if axes were shared.</li> </ul>"},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Dependency of matplotlib to &gt;= 3.10.0</li> <li>Method description() of Estimator class now returns a DataFrame instead of a Series.</li> <li>Terminology for \"term\", \"feature\" and \"parameter\" at LinearModel class so that it is used consistently across all methods.</li> </ul>"},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li>Method include() for LinearModel class to re include a parameter.</li> <li>Method optimize() for LinearModel class to optimize the model.</li> <li>Method predict() for LinearModel class to predict the response.</li> <li>Examples for LinearModel class.</li> <li>Example for chart precast.</li> </ul>"},{"location":"CHANGELOG/#120-2025-02-12","title":"[1.2.0] - 2025-02-12","text":""},{"location":"CHANGELOG/#fixed_6","title":"Fixed","text":"<ul> <li>Transpose xy-axes parameters did not work for MultivariateCharts.</li> <li>LinearModel getting captions failed when printing tables.</li> <li>SingleChart had wrong key for getting color at plot method.</li> </ul>"},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>Option to highlight quantiles in the fill area of Violine and GaussianKDE Plotters.</li> </ul>"},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>The name of the Plotter Quantiles to QuantileBoxes</li> <li>QuantileBoxes draws now not overlapping boxes</li> </ul>"},{"location":"CHANGELOG/#111-2025-01-24","title":"[1.1.1] - 2025-01-24","text":""},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Option target_on_y for MultivariateChart</li> </ul>"},{"location":"CHANGELOG/#110-2025-01-23","title":"[1.1.0] - 2025-01-23","text":""},{"location":"CHANGELOG/#added_10","title":"Added","text":"<ul> <li>The options rows and cols in label method of JointChart used to labell the axes rows and columns.</li> <li>The Estimation class got now the min and max properties.</li> <li>The option exclude added to Estimation describe method, used to exclude variables from the analysis.</li> <li>The describe method of ProcessEstimation returns now also ok and nok as percentage values.</li> <li>A Beeswarm plotter that is comparable to the Jitter plotter. However, with Beeswarm the points are not distributed randomly, but arranged from the inside to the outside.</li> <li>A Quantiles plotter that is comparable to a boxplot. However, quantiles does not draw whiskers but rather just several boxes that show the given number of percent of the observed data.</li> <li>The option to change color, marker, target_on_y, size and width in plot method for SingleChart and JointChart.</li> <li>The option hide_axis for each Plotter class during initialization.</li> <li>The option visible_spines for each Plotter class during initialization.</li> </ul>"},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>The class name MultipleVariateChart to MultivariateChart</li> </ul>"},{"location":"CHANGELOG/#removed_2","title":"Removed","text":"<ul> <li>The option show_density_axis for GaussianKDE. Use hide_axis and visible_spines instead.</li> </ul>"},{"location":"CHANGELOG/#101-2025-01-09","title":"[1.0.1] - 2025-01-09","text":""},{"location":"CHANGELOG/#fixed_7","title":"Fixed","text":"<ul> <li>Calculating Z-score for ProcessEstimator failure when no specification limit is provided.</li> </ul>"},{"location":"CHANGELOG/#100-2025-01-09","title":"[1.0.0] - 2025-01-09","text":""},{"location":"CHANGELOG/#added_11","title":"Added","text":"<ul> <li>ProcessEstimator z_transform method and tolerance property.</li> <li>GaussianKDE ignore_feature option for plotting all at same axis base or not.</li> <li>GaussianKDE fill option for filling in the curves.</li> <li>SpreadWidth center calculation option kind.</li> <li>ProcessEstimator Z_lt property for long-term sigma level.</li> <li>ProcessEstimator Z property as sigma level process capability.</li> <li>Confidence interval functions for Cp and Cpk in confidence module.</li> <li>The function estimate_capability_confidence function in estimation module.</li> <li>CapabilityConfidenceIntervall Plotter class.</li> <li>Datasets drop_card.csv and salt_sticks.csv.</li> <li>AxesFacets mosaic option for more flexability in axes arrangement.</li> <li>AxesFacets properties flat and shape.</li> <li>Loess class in estimation module used for plotting loess curves.</li> <li>Plotting styles ggplot2, daspi-dark and seaborn.</li> <li>The module appereance in plotlib used for managing loading and saving styles.</li> <li>Colormaps used at seaborn to the module appereance.</li> </ul>"},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li>Estimator agreement property gets allways the multiplier of sigma agreement.</li> <li>Chart property name default_kwds changed to kw_default.</li> <li>JointChart possability to add axes independend stripes for mean, median and control_limits</li> <li>Errorbars requires now the amount of groups. This is necessary for bonferroni adjustment.</li> <li>Chart property name axes_facets changed to Axes.</li> <li>Most of the arguments is now only available as a keyword argument in Chart classes.</li> <li>When target_on_y is set to False in SingleChart, the x and y axes params are swapped.</li> <li>The default plotting color is now black and the palette behaves like ggplot2. That means that the colors changes with the number of groups (except for the first group).</li> </ul>"},{"location":"CHANGELOG/#removed_3","title":"Removed","text":"<ul> <li>The marker option for TransformPlotter.</li> </ul>"},{"location":"CHANGELOG/#fixed_8","title":"Fixed","text":"<ul> <li>ErrorBarsPlotter and JitterPlotter now use the marker option.</li> <li>GaussianKDEPlotter color option now has an effect.</li> <li>JointChart handles and labels now get the stripes stuff from all axes and not only from the last one.</li> <li>Categorical floating features are now plotted as categorical.</li> </ul>"},{"location":"CHANGELOG/#051-2024-11-19","title":"[0.5.1] - 2024-11-19","text":""},{"location":"CHANGELOG/#added_12","title":"Added","text":"<ul> <li>GaussianKDEContour Plotter for plotting bivariate distributions as contour lines.</li> <li>kernel_density_estimation_2d function used to calculate bivariate kernel density estimations.</li> <li>Stripe, StripeLine and StripeSpan Plotter for plotting stripes using StripesFacets class or within BlandAltman Plotter.</li> <li>Documentation site</li> </ul>"},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>StripesFacets now uses the new StripeLine and StripeSpan Plotters.</li> <li>BlandAltmanPlotter now uses the new StripeLine and StripeSpan Plotters.</li> <li>The target_on_y option is moved from StripesFacets draw method to init.</li> <li>Getting Figure and Axes behavior if not given during initialization of a Plotter class. The plt.gca() function is now used.</li> </ul>"},{"location":"CHANGELOG/#removed_4","title":"Removed","text":"<ul> <li>Option marker when initializing a Line Plotter. Set the marker if needed when calling the plotter.</li> </ul>"},{"location":"CHANGELOG/#fixed_9","title":"Fixed","text":"<ul> <li>Charts got wrong colors if not given during initialization.</li> </ul>"},{"location":"CHANGELOG/#040-2024-10-24","title":"[0.4.0] - 2024-10-24","text":""},{"location":"CHANGELOG/#added_13","title":"Added","text":"<ul> <li>BivariateUnivariateCharts template, provides a set of charts for visualizing the relationship between a target variable and a feature variable.</li> <li>Option for Plotters to change the marker. This can be set during initialization of the Plotter.</li> <li>Option for Charts to change markers, colors and amount of size bins for categorical differentiation.</li> <li>Single feature or target label for JointCharts if all aubplots shares the corressponding axis.</li> </ul>"},{"location":"CHANGELOG/#fixed_10","title":"Fixed","text":"<ul> <li>Categorical feature failed when using floats. Categorical features failed when using floats. Dodging is now always performed, but only with one category if dodge was set to False.</li> </ul>"},{"location":"CHANGELOG/#030-2024-10-09","title":"[0.3.0] - 2024-10-09","text":""},{"location":"CHANGELOG/#added_14","title":"Added","text":"<ul> <li>PairComparisonCharts template, provides a set of charts for visualizing the pairwise comparison of two variables.</li> <li>kw_where argument to filter data when calling the plot method of a Chart object. For more information see the documentation pandas.DataFrame.where</li> </ul>"},{"location":"CHANGELOG/#removed_5","title":"Removed","text":"<ul> <li>BaseTemplate, all template chart classes inherits directly from JointChart.</li> </ul>"},{"location":"CHANGELOG/#020-2024-07-10","title":"[0.2.0] - 2024-07-10","text":""},{"location":"CHANGELOG/#added_15","title":"Added","text":"<ul> <li>Option for LinearModel and variance_inflation_factor function to choose if generalized or only straightforward VIFs should be calculated.</li> <li>Option for LinearModel if all categorical features should be one-hot encoded or not.</li> <li>ParameterRelevanceCharts template and BaseTemplate as parent for ResidualsCharts and ParameterRelevanceCharts.</li> <li>anguage dependent strings for sum of squares label, effects label and ParameterRelevanceCharts texts.</li> <li>Option to skip plotting nan values for all TransformPlotters.</li> <li>Property effect_threshold for LinearModel, which returns the effect value for the given alpha risk.</li> <li>Option to skip evaluation of intercept as least significant term for LinearModel.</li> <li>Property design_matrix for LinearModel, which returns the currently encoded design matrix.</li> <li>Option to draw a percentage line when using the Pareto plotter or not.</li> <li>GVIF, its threshold, collinearity decision and method used for the VIF table.</li> </ul>"},{"location":"CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Variance inflation factor function calculates now only values for equal orders.</li> <li>Variance inflation factor function returns a DataFrame instead of a Series</li> <li>Renamed attribute of LinearModel: exclude -&gt; excluded.</li> <li>least_term method of LinearModel when evaluating by effects and some effects are equal, the highest interaction order is returned. Now it also takes into account nan values.</li> <li>eliminate method of LinearModel returns self for method chaining.</li> <li>Effects are now calculated as absolute t-values.</li> <li>Effects table keeps now the original term order (was messed up).</li> </ul>"},{"location":"CHANGELOG/#fixed_11","title":"Fixed","text":"<ul> <li>has_insignificant_term method of LinearModel could not detect minimal terms when the attribute skip_intercept_as_least was set to True.</li> <li>Degrees of freedom for VIF table was calculated wrong.</li> </ul>"},{"location":"CHANGELOG/#010-2024-07-01","title":"[0.1.0] - 2024-07-01","text":"<p>Initial release.</p>"},{"location":"CHANGELOG/#added_16","title":"Added","text":"<ul> <li>Character strings in different languages \u200b\u200bfor charts and tables. The language can be set initially and the output adapts automatically. Available languages: German and English.</li> <li>Constants that are available globally throughout the package.</li> </ul> <p>Anova module:</p> <ul> <li>LinearModel for running regressions with higher order interactions and analyzing significant terms and their elimination.</li> <li>Tables such as ANOVA, VIF and residuals.</li> </ul> <p>Statistics module:</p> <ul> <li>Estimator for calculating statistics such as mean, stdev, skew and excess.</li> <li>ProcessEstimator as an extension of the Estimator class which also takes specification limits into account to calculate Cp and Cpk values.</li> <li>Confidence interval functions for position, spread, proportions and fit lines.</li> <li>Estimation functions for kernel density and distributions</li> <li>Hypothesis tests for normality, homogeneity of variance and independence.</li> </ul> <p>Plotlib module:</p> <ul> <li>SingleChart for plotting single Axes charts with different plotters.</li> <li>MultivariateChart for plotting charts with multiple Axes, with the plots divided into the individual Axes depending on the categorical variates.</li> <li>JointChart for plotting multiple axes to which different plotters can be applied.</li> <li>Any type of plotters such as Bar, Violin, KDE, Scatter, Line, Errorbar, Confidence Intervals, Pareto, Bland Altmann, Parallel Coordinate and Jitter.</li> <li>Pre-built Matplotlib stylesheet</li> <li>Classifiers to classify the plots into different colors, markers or marker sizes depending on the categorical variates.</li> <li>Facets for plotting multiple charts in one figure, with the plots divided into the individual Axes depending on the categorical variates. Also for adding stribes to the charts or adding labels, titles </li> </ul>"},{"location":"anova/","title":"ANOVA","text":""},{"location":"anova/#daspi.anova.convert","title":"<code>daspi.anova.convert</code>","text":""},{"location":"anova/#daspi.anova.convert.get_term_name","title":"<code>get_term_name(name)</code>","text":"<p>Get the original term name of a patsy encoded categorical column name, including interactions.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The encoded column name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The original term name of the categorical column name.</p> </li> </ul> Notes <p>Patsy encodes categorical columns by appending '[T.]' to the original term name. Interactions between features are represented by separating the feature names with ':'. This function extracts the original term name from the encoded feature name, taking into account interactions. <p>Examples:</p> <pre><code>encoded_name = 'Category[T.Value]:OtherCategory[T.OtherValue]'\nterm_name = get_term_name(encoded_name)\nprint(term_name)\n</code></pre> <pre><code>'Category:OtherCategory'\n</code></pre>"},{"location":"anova/#daspi.anova.convert.frames_to_html","title":"<code>frames_to_html(dfs, captions)</code>","text":"<p>Converts one or more DataFrames to HTML tables with captions.</p> <p>Parameters:</p> <ul> <li> <code>dfs</code>               (<code>DataFrame or list/tuple of DataFrames</code>)           \u2013            <p>The DataFrame(s) to be converted to HTML.</p> </li> <li> <code>captions</code>               (<code>str or list/tuple of str</code>)           \u2013            <p>The captions to be used for the HTML tables. The number of  captions must match the number of DataFrames.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The HTML representation of the DataFrames with captions.</p> </li> </ul>"},{"location":"anova/#daspi.anova.tables","title":"<code>daspi.anova.tables</code>","text":""},{"location":"anova/#daspi.anova.tables.uniques","title":"<code>uniques(seq)</code>","text":"<p>Get a list of unique elements from a sequence while preserving  the original order.</p> <p>Parameters:</p> <ul> <li> <code>seq</code>               (<code>Iterable</code>)           \u2013            <p>The input sequence.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Any]</code>           \u2013            <p>A list of unique elements from the input sequence, preserving  the original order.</p> </li> </ul> Notes <p>This function is based on the 'uniqify' algorithm by Peter Bengtsson. Source: https://www.peterbe.com/plog/uniqifiers-benchmark</p> <p>Examples:</p> <pre><code>sequence = [1, 2, 3, 2, 1, 4, 5, 4]\nunique_elements = uniques(sequence)\nprint(unique_elements)\n</code></pre> <pre><code>[1, 2, 3, 4, 5]\n</code></pre>"},{"location":"anova/#daspi.anova.tables.terms_effect","title":"<code>terms_effect(model)</code>","text":"<p>Calculates the impact of each term on the target. The effects are described as absolute number of the parameter  coefficients devided by its standard error.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>RegressionResultsWrapper</code>)           \u2013            <p>Statsmodels regression results of fitted model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>A pandas Series containing the effects of each feature on the target variable.</p> </li> </ul>"},{"location":"anova/#daspi.anova.tables.variance_inflation_factor","title":"<code>variance_inflation_factor(model, threshold=5, generalized=True)</code>","text":"<p>Calculate the variance inflation factor (VIF) and the generalized variance inflation factor (GVIF) for each predictor variable in the fitted model.</p> <p>This function takes a regression model as input and returns a  DataFrame containing the VIF, GVIF (= VIF^(1/2*dof)), threshold for  GVIF, collinearity status and calculation kind for each predictor  variable in the model. The VIF and GVIF are measures of  multicollinearity, which can help identify variables that are highly correlated with each other.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>RegressionResultsWrapper</code>)           \u2013            <p>The regression model to analyze.</p> </li> <li> <code>threshold</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The threshold for deciding whether a predictor is collinear. Common values are 5 and 10. By default 5.</p> </li> <li> <code>generalized</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to calculate the generalized VIF or not, by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the VIF, GVIF, threshold, collinearity status and performed method for each predictor variable in the  model.</p> </li> </ul> Notes <p>The VIF tells us: The degree to which the standard error of the  predictor is increased due to the predictor's correlation with the  other predictors in the model. VIF values greater than 10  (or, Tolerance values less than 0.10) corresponding to a multiple  correlation of 0.95 indicates a multicollinearity may be a problem  (Hair Jr, JF, Anderson, RE, Tatham, RL and Black, WC, 1998). Fox and  Weisberg also comment that the straightforward VIF can't be used if  there are variables with more than one degree of freedom (e.g.  polynomial and other contrasts relating to categorical variables  with more than two levels) and recommend using the gvif function  (generalized variance inflation factor) in the car package in R in  these cases. gvif is the square root of the VIF for individual  predictors and thus can be used equivalently. More generally  generalized variance-inflation factors consist of the VIF corrected  by the number of degrees of freedom (df) of the predictor variable:  GVIF = VIF[1/(2df)] and may be compared to thresholds of  10[1/(2df)] to assess collinearity using the stepVIF (source code:  https://github.com/cran/car/blob/master/R/vif.R) function in R.</p> <p>source: https://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/Collinearity</p> <p>See Also: https://www.rdocumentation.org/packages/car/versions/3.1-2/topics/vif https://www.statsmodels.org/dev/generated/statsmodels.stats.outliers_influence.variance_inflation_factor.html</p>"},{"location":"anova/#daspi.anova.tables.anova_table","title":"<code>anova_table(model, typ)</code>","text":"<p>Perform an analysis of variance (ANOVA) on the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>RegressionResultsWrapper</code>)           \u2013            <p>A fitted regression model of the <code>statsmodels</code> package.</p> </li> <li> <code>typ</code>               (<code>Literal['I', 'II', 'III']</code>)           \u2013            <p>The type of ANOVA to perform. Default is 'III', see notes for more informations about the types. - '' : If no or an invalid type is specified, Type-II is  used if the model has no significant interactions.  Otherwise, Type-III is used for hierarchical models and  Type-I is used for non-hierarchical models. - 'I' : Type I sum of squares ANOVA. - 'II' : Type II sum of squares ANOVA. - 'III' : Type III sum of squares ANOVA.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The ANOVA table as DataFrame containing the following columns: - DF : Degrees of freedom for model terms. - SS : Sum of squares for model terms. - F : F statistic value for significance of adding model terms. - p : P-value for significance of adding model terms. - n2 : Eta-square as effect size (proportion of explained variance). - np2 : Partial eta-square as partial effect size.</p> </li> </ul> Notes <p>The ANOVA table provides information about the significance of  each factor and interaction in the model. The type of ANOVA  determines how the sum of squares is partitioned among the  factors.</p> <p>The SAS and also Minitab software uses Type III by default. This type is also the only one who gives us a SS and p-value for the  Intercept. A discussion on which one to use can be  found here: https://stats.stackexchange.com/a/93031</p> <p>A nice conclusion about the differences between the types: - Typ-I: We choose the most \"important\" independent variable and  it will receive the maximum amount of variation possible. - Typ-II: We ignore the shared variation: no interaction is assumed. If this is true, the Type II Sums of Squares are statistically more powerful. However if in reality there is an interaction effect, the model will be wrong and there will be a problem in the conclusions of the analysis. - Typ-III: If there is an interaction effect and we are looking  for an \u201cequal\u201d split between the independent variables,  Type-III should be used.</p> <p>source: https://towardsdatascience.com/anovas-three-types-of-estimating-sums-of-squares-don-t-make-the-wrong-choice-91107c77a27a</p>"},{"location":"anova/#daspi.anova.tables.terms_probability","title":"<code>terms_probability(model)</code>","text":"<p>Compute the p-values for the terms in a regression model using a ANOVA typ-III table.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>RegressionResultsWrapper</code>)           \u2013            <p>The regression model to compute the p-values for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series[float]</code>           \u2013            <p>A Series containing the p-values for each term in the model. If  the ANOVA table could not be calculated, the p-values will be set to NaN.</p> </li> </ul> Notes <p>ANOVA typ III table is used, because it is the only one who gives us a p-value for the intercept.</p>"},{"location":"anova/gage-rnr-model/","title":"Gage rnr model","text":""},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel","title":"<code>daspi.anova.model.GageRnRModel</code>","text":"<p>               Bases: <code>LinearModel</code></p> <p>A linear regression model for Gage Repeatability and  Reproducibility (Gage R&amp;R) analysis.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas DataFrame as tabular data in a long format used for the model.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name for source data holding the measurement values.</p> </li> <li> <code>part</code>               (<code>str</code>)           \u2013            <p>Column name for the parts variable (unit under test).</p> </li> <li> <code>gage</code>               (<code>GageStudyModel</code>)           \u2013            <p>The provided GageStudyModel instance contains the measurement  system's statistics. This class corresponds to measurement  system analysis type 1. To calculate the uncertainty for  linearity, provide multiple reference parts in the <code>GageStudyModel</code> instance.</p> </li> <li> <code>u_av</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Column name of the variable that identifies the operator for  type 2 Gage R&amp;R. If the operator has no influence (MSA Typ III) and was therefore not included in the data acquisition, set <code>u_av</code> to <code>None</code>. In this case, it is recommended to record  multiple locations, multiple part holders, or other possible  changes to the measuring system and specify them in <code>u_gv</code>. Default is None.</p> </li> <li> <code>u_gv</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies the measurement uncertainty of gage ss, which  reflects the comparability of the measurement system. This  uncertainty is determined based on the data. To account for this  uncertainty, provide the column name containing the categorical  variables for the different measurement systems, test nests, or  similar. If not specified, the default value is 'None'.</p> </li> <li> <code>u_t</code>               (<code>MeasurementUncertainty | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Indicates the measurement uncertainty related to temperature  dependence. This uncertainty can be assessed using the data  (Method A) or specified directly if known (Method B).</p> <ul> <li>Method A: Enter the column name containing the categorical    variables for different temperatures.</li> <li>Method B: Specify a MeasurementUncertainty instance directly.</li> </ul> <p>If neither method is applied, the default value is 'None'.</p> </li> <li> <code>u_stab</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Represents the measurement uncertainty related to the stability  of the measurement system. This uncertainty is determined from  the data. To include this uncertainty, enter the column name  containing the categorical variables for the relevant  conditions. If not specified, the default value is 'None'.</p> </li> <li> <code>u_obj</code>               (<code>MeasurementUncertainty | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies the measurement uncertainty associated with the  inhomogeneity of the object. This uncertainty can be determined  from the data (Method A) or directly specified if known  (Method B).</p> <ul> <li>Method A: Provide the column name containing the relevant    categorical variables for calculation from the data.</li> <li>Method B: Specify a MeasurementUncertainty instance directly.</li> </ul> <p>If neither method is applied, the default value is 'None'.</p> </li> <li> <code>u_rest</code>               (<code>MeasurementUncertainty | None</code>, default:                   <code>None</code> )           \u2013            <p>Accounts for uncertainties not covered by the parameters above.  This parameter considers additional sources of uncertainty that  may impact the overall measurement, such as environmental  conditions, operator influences, or other unknown variables. If  known, specify the uncertainty here; otherwise, the default  value is 'None'.</p> </li> <li> <code>fit_at_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the model is fitted at initialization. Otherwise, the model is fitted after calling the <code>fit</code> method. Default is True.</p> </li> </ul> <p>Examples:</p> <p>If you run the following code in a Jupyter Notebook cell, all tables will be calculated and output in an HTML format:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nrnr_model = dsp.GageRnRModel(\n    source=df,\n    target='result_rnr',\n    part='part',\n    gage=gage,\n    u_av='operator')\nrnr_model # or print(repr(rnr_model))\n</code></pre> References <p>The calculations are done based on the following references:</p> <p>[1] Dr. Bill McNeese, BPI Consulting, LLC (09.2012) https://www.spcforexcel.com/knowledge/measurement-systems-analysis-gage-rr/anova-gage-rr-part-2/</p> <p>[2] Minitab, LLC (2025) https://support.minitab.com/de-de/minitab/help-and-how-to/quality-and-process-improvement/measurement-system-analysis/how-to/gage-study/crossed-gage-r-r-study/methods-and-formulas/gage-r-r-table/</p> <p>[3] Curt Ronniger, Software f\u00fcr Statistik, Schulungen und Consulting (2025) https://www.versuchsmethoden.de/Mess-System-Analyse.pdf</p> <p>[4] VDA Band 5, Mess- und Pr\u00fcfprozesse. Eignung, Planung und Management (Juli 2021) 3. \u00fcberarbeitete Auflage</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.alpha","title":"<code>alpha</code>  <code>property</code> <code>writable</code>","text":"<p>Alpha risk as significance threshold for p-value of exegenous factors.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.captions","title":"<code>captions</code>  <code>property</code>","text":"<p>Get the captions for the tables used for html output (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.data","title":"<code>data = source.rename(columns=(self.feature_map | self.target_map))[list(self.feature_map.values()) + list(self.target_map.values())].copy()</code>  <code>instance-attribute</code>","text":"<p>The Pandas DataFrame containing the data for the linear model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.design_info","title":"<code>design_info</code>  <code>property</code>","text":"<p>Get the DesignInfo instance of current fitted model (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.design_matrix","title":"<code>design_matrix</code>  <code>property</code>","text":"<p>Get the design matrix of the current fitted model (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.df_u","title":"<code>df_u</code>  <code>property</code>","text":"<p>Get the data frame with the whole uncertainty budget as the combination of the data frames of MS and MP (<code>df_ums</code> and  <code>df_ump</code>). If the uncertainties are not calculated yet, the method <code>uncertainties()</code> is called (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.df_ump","title":"<code>df_ump</code>  <code>property</code>","text":"<p>Get the data frame with the measurement uncertainty of the  measurement process as gage study type 2 or 3. If the  uncertainties are not calculated yet, the method  <code>uncertainties()</code> is called (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.df_ums","title":"<code>df_ums</code>  <code>property</code>","text":"<p>Get the data frame with the measurement uncertainty of the  measurement system as gage study type 1. If the uncertainties  are not calculated yet, the method <code>uncertainties()</code> is called  (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.disturbances","title":"<code>disturbances = disturbances</code>  <code>instance-attribute</code>","text":"<p>The list of disturbances variables used in the linear  model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.effect_threshold","title":"<code>effect_threshold</code>  <code>property</code>","text":"<p>Calculates the threshold for the effect of adding a term to the model. The threshold is calculated as the inverse survival  function (inverse of sf) at the given alpha (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.excluded","title":"<code>excluded = set()</code>  <code>instance-attribute</code>","text":"<p>A set of feature names that should be excluded from the model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.feature_map","title":"<code>feature_map = {f: _ffor (f, _f) in (zip(features, f_main_terms))} | {c: _cfor (c, _c) in (zip(disturbances, d_main_terms))}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the original feature names to the encoded  names (term) used in the model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.features","title":"<code>features = features</code>  <code>instance-attribute</code>","text":"<p>The list of features used in the linear model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.fitted","title":"<code>fitted</code>  <code>property</code>","text":"<p>Whether the model is fitted (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.formula","title":"<code>formula</code>  <code>property</code>","text":"<p>Get the formula used for the linear model, excluding any factors specified in the <code>exclude</code> attribute. The formula is constructed based on the excluded factors. If the intercept is excluded, the formula will include '-1' as the first term. Otherwise, the formula will include the original terms (excluding the excluded factors) separated by '+' (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.gage","title":"<code>gage</code>  <code>property</code>","text":"<p>The provided GageModel instances contains the measurement  system's statistics. This classes corresponds to measurement  system analysis type 1 (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.generalized_vif","title":"<code>generalized_vif = generalized_vif</code>  <code>instance-attribute</code>","text":"<p>If True, the generalized VIF is calculated when possible. Otherwise, only the straightforward VIF (via R2) is calculated.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.has_operator","title":"<code>has_operator = bool(u_av)</code>  <code>instance-attribute</code>","text":"<p>Indicates whether the model has an operator variable.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.initial_formula","title":"<code>initial_formula</code>  <code>property</code>","text":"<p>Get the initial formula for the ANOVA model (read-only).</p> <p>The initial formula is constructed from the target variable and  the initial terms, which are the terms with an interaction order  less than or equal to the specified order.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.interactions","title":"<code>interactions</code>  <code>property</code>","text":"<p>Get the interaction parameter names if interaction is present  in the fitted model (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.k","title":"<code>k</code>  <code>property</code> <code>writable</code>","text":"<p>The coverage factor for the expanded measurement uncertainty.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.main_parameters","title":"<code>main_parameters</code>  <code>property</code>","text":"<p>Get all main parameters of current model excluding intercept (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.main_term_map","title":"<code>main_term_map = {v: kfor (k, v) in (self.feature_map.items())}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the main term names (no interactions) back  to the original feature names used in the model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.model","title":"<code>model</code>  <code>property</code>","text":"<p>Get regression results of fitted model. Calls <code>fit</code> method if no model is fitted yet (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.n_levels","title":"<code>n_levels = source[features].nunique().rename(self.u_map)</code>  <code>instance-attribute</code>","text":"<p>Series with the number of levels for each variable. The amount of replications are stored under equipment variation 'EV'.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>The number of samples used in the Gage R&amp;R study (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Get the names of all variables for the current fitted  model in the composition using the original feature and  disturbances names (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.part","title":"<code>part = part</code>  <code>instance-attribute</code>","text":"<p>Column name of the part (unit under test) variable.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.skip_intercept_as_least","title":"<code>skip_intercept_as_least = skip_intercept_as_least</code>  <code>instance-attribute</code>","text":"<p>If True, the intercept is not treated as a least significant term</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The name of the target variable for the linear model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.target_map","title":"<code>target_map = {target: 'y'}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the original feature names to the encoded  feature names used in the model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.term_map","title":"<code>term_map</code>  <code>property</code>","text":"<p>Get the names of all internal used and original terms  variables for the current fitted model as dict (read-only)</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.terms","title":"<code>terms</code>  <code>property</code>","text":"<p>Get the encoded names of all variables for the current  fitted model (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.tolerance","title":"<code>tolerance</code>  <code>property</code>","text":"<p>The tolerance of the specification (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_av","title":"<code>u_av</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the appraiser ss  (comparability of operators) (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_evo","title":"<code>u_evo</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the equipment variation  (repeatability) on the object (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_gv","title":"<code>u_gv</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the gage ss  (compareability of measurement system) (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_ia","title":"<code>u_ia</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the interaction  (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_map","title":"<code>u_map = {old: newfor (old, new) in (zip(u_old, u_new)) if isinstance(old, str)}</code>  <code>instance-attribute</code>","text":"<p>Dictionary for mapping original names of uncertainties in the  source data to the uncertainty abbreviations used in the model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_mp","title":"<code>u_mp</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the measurement process (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_ms","title":"<code>u_ms</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the measurement system (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_obj","title":"<code>u_obj</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the inhomogeneity of the  object (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_rest","title":"<code>u_rest</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the remaining  (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_stab","title":"<code>u_stab</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the stability over time (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.u_t","title":"<code>u_t</code>  <code>property</code>","text":"<p>Get the measurement uncertainty of the temperature (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.uncertainty","title":"<code>uncertainty</code>  <code>property</code>","text":"<p>Get uncertainty of the model as square root of MS_Residual (read-only).</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.__html__","title":"<code>__html__()</code>","text":"<p>This method exists to inform other HTML-using modules (e.g.  Markupsafe, htmltag, etc) that this object is HTML and does not  need things like special characters (&lt;&gt;&amp;) escaped.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.__repr__","title":"<code>__repr__()</code>","text":"<p>Generates an string representation of the model's  diagnostic information.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string containing the model's diagnostic information.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.__str__","title":"<code>__str__()</code>","text":"<p>Generates a string representation of the linear regression  model's formula.</p> <p>The formula is constructed by iterating over the parameter  statistics and adding each parameter name and coefficient to the formula string. The target variable is included at the start of  the formula.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.effects","title":"<code>effects()</code>","text":"<p>Calculates the impact of each term on the target. The effects are described as absolute number of the parameter  coefficients devided by its standard error.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.eliminate","title":"<code>eliminate(parameter)</code>","text":"<p>Removes the given parameter from the model by adding it to t he <code>exclude</code> set. Call <code>fit</code> to refit the model.</p> <p>Parameters:</p> <ul> <li> <code>parameter</code>               (<code>str</code>)           \u2013            <p>The feature name, the disturbances name or the interaction  of multiple features to be removed from the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The current instance of the model for more method chaining.</p> </li> </ul> <p>Examples:</p> <p>Prepare a LinearModel instance, fit the model and plot the  relevance of the parameters. If you run the following code in a Jupyter Notebook, the plot and the html representation of the model will be displayed.</p> <p><pre><code>import pandas as pd\nimport daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nlm = dsp.LinearModel(\n        source=df,\n        target='dissolution',\n        features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n        disturbances=['temperature', 'preparation'],\n        alpha=0.05,\n        order=3,\n        encode_categoricals=False\n    )\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre> Now remove the least significant term from the model and refit. Repeat the process until the model contains only significant terms.</p> <pre><code>lm.eliminate('stirrer:brand:catalyst')\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre> <p>To add again a feature to the model, use the <code>include</code> method. For an automatic elimination of insignificant terms, use the 'recursive_elimination' method.</p> Notes <p>Always be careful when removing the intercept. If the intercept is  missing, Patsy will automatically add all one-hot encoded levels for a categorical variable to compensate for this missing term. This  will result in extremely high VIFs.</p> <p>Raises:</p> <ul> <li> <code>AssertionError: </code>             \u2013            <p>If the given term is not in the model.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.fit","title":"<code>fit(**kwds)</code>","text":"<p>Create and fit a ordinary least squares model using current  formula. To fit with a user-defined formula, use the  <code>formula</code> keyword argument.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Pass formula and other keyword arguments to <code>ols</code> function of <code>statsmodels.formula.api</code>.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.gof_metrics","title":"<code>gof_metrics(index=0)</code>","text":"<p>Get different goodness-of-fit metrics (read-only).</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int | str</code>, default:                   <code>0</code> )           \u2013            <p>Value is set as index. When using the method  recursive_elimination, the current step is passed as index</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The goodness-of-fit metrics table as DataFrame containing the following columns: - 'formula' = current formula - 's' = Uncertainty of the model as square root of MS_Residual - 'aic' = Akaike's information criteria - 'r2' = R-squared of the model - 'r2_adj' = adjusted R-squared - 'least_parameter' = the least significant term - 'p_least' = The p-value of least significant term, coming from ANOVA table Type-III. - 'hierarchical' = True if model is hierarchical</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.has_insignificant_term","title":"<code>has_insignificant_term(rsquared_max=0.99)</code>","text":"<p>Check if the fitted model has any insignificant terms.</p> <p>Parameters:</p> <ul> <li> <code>rsquared_max</code>               (<code>float in (0, 1)</code>, default:                   <code>0.99</code> )           \u2013            <p>The maximum R^2 value that the model can have to be  considered significant. If not provided, by default 0.99.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns True if the model has any insignificant terms, and  False otherwise.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.has_significant_interactions","title":"<code>has_significant_interactions()</code>","text":"<p>True if fitted model has significant interactions.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.highest_parameters","title":"<code>highest_parameters(features_only=False)</code>","text":"<p>Determines all main and interaction parameters that do not  occur in a higher interaction in this constellation.</p> <p>Parameters:</p> <ul> <li> <code>features_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, intercept and interaction parameters are not  returned. By default False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of highest parameters.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.include","title":"<code>include(parameter)</code>","text":"<p>Adds the given feature to the model by removing it from the <code>excluded</code> set. Call <code>fit</code> to refit the model.</p> <p>Parameters:</p> <ul> <li> <code>parameter</code>               (<code>str</code>)           \u2013            <p>The feature name, the disturbances name or the interaction  of multiple features to be added to the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The current instance of the model for more method chaining.</p> </li> </ul> <p>Examples:</p> <p>See <code>eliminate</code> method. After removing a term from the model, you can add it again by using the <code>include</code> method.</p> <pre><code>lm.include('C').fit()\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.is_hierarchical","title":"<code>is_hierarchical()</code>","text":"<p>Check if current fitted model is hierarchical.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.least_parameter","title":"<code>least_parameter()</code>","text":"<p>Get the parameter name with the least effect or the least  p-value coming from a ANOVA typ III table of current fitted  model.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The parameter name with the least p_value if possible or the parameter name with the least effect.</p> </li> </ul> Notes <p>This method checks if any p-values are missing (NaN). If there are missing p-values, it returns the term name that has the  smallest effect on the target variable. Otherwise, it returns the term name with the least p-value for the F-stats coming from current ANOVA table.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.optimize","title":"<code>optimize(maximize=True, bounds={})</code>","text":"<p>Optimize the prediction by optimizing the parameters.</p> <p>Parameters:</p> <ul> <li> <code>maximize</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to maximize the prediction or minimize it.</p> </li> <li> <code>bounds</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Bounds for the parameters to optimize. - You can freeze a paramater by setting it to the desired      value. For example, to fix the value of a parameter to 1,      you can set bounds = {'param_name': 1}. - To keep an ordinal or metric parameter within a specific     range, you can set bounds = {'param_name': (lower, upper)}.     For example, to constrain a parameter to be between 0 and      1, you can set bounds = {'param_name': (0, 1)}. - In order to limit the selection of a nominal parameter      only to a certain subset of the originally conained values,     you can set bounds = {'param_name': (val1, val2, ...)}.     For example, to limit the selection of a nominal parameter     to the values 'A' and 'B', you can set      bounds = {'param_name': ('A', 'B')}.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>The optimized parameters.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.p_values","title":"<code>p_values()</code>","text":"<p>Get P-value for significance of adding model terms using  anova typ III table for current model.</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.parameter_statistics","title":"<code>parameter_statistics(alpha=0.05, use_t=True)</code>","text":"<p>Calculate the parameter statistics for the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The significance level for the confidence intervals, by  default 0.05.</p> </li> <li> <code>use_t</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, use t-distribution for hypothesis testing and  confidence intervals. If False, use normal distribution,  by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A pandas DataFrame containing the parameter statistics for  the fitted model. The DataFrame includes columns for the  parameter estimates, standard errors, t-values  (or z-values), and p-values.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.predict","title":"<code>predict(xs)</code>","text":"<p>Predict y with given xs. Ensure that all non interactions are  given in xs</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The values for which you want to predict. Make sure that all non interaction parameters are given in xs. If multiple  values are to be predicted, provide a list of values for  each factor level.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the predicted values for the given values of the predictor variables.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.r2_pred","title":"<code>r2_pred()</code>","text":"<p>Calculate the predicted R-squared (R2_pred) for the fitted  model.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The predicted R-squared value for the fitted model.</p> </li> </ul> Notes <p>The predicted R-squared is a measure of how well the model would  predict new observations. It is calculated as:</p> <p>R2_pred = 1 - (Sum of Squared Prediction Errors / Total Sum of Squares)</p> <p>Where the prediction errors are calculated as the residuals  divided by (1 - leverage), where leverage is the diagonal  elements of the projection matrix P = X(X'X)^(-1)X'.</p> References <p>Calculations are made according to: https://support.minitab.com/de-de/minitab/help-and-how-to/statistical-modeling/doe/how-to/factorial/analyze-factorial-design/methods-and-formulas/goodness-of-fit-statistics/#press</p> <p>Further information about projection matrix (influence matrix or hat matrix) can be found in: https://en.wikipedia.org/wiki/Projection_matrix</p>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.recursive_elimination","title":"<code>recursive_elimination(rsquared_max=0.99, ensure_hierarchy=True, **kwds)</code>","text":"<p>Perform a recursive parameter elimination on the fitted model.</p> <p>This function starts with the complete model and recursively  eliminates parameters based on their p-values, until only  significant parameters remain in the model. The function yields  the goodness-of-fit metrics at each step of the elimination process.</p> <p>Parameters:</p> <ul> <li> <code>rsquared_max</code>               (<code>float in (0, 1)</code>, default:                   <code>0.99</code> )           \u2013            <p>If given, the model must have a lower R^2 value than the  given threshold, by default 0.99</p> </li> <li> <code>ensure_hierarchy</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Adds features at the end to ensure model is hierarchical,  by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for <code>ols</code> function of  <code>statsmodels.formula.api</code>.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The goodness-of-fit metrics at each step of the recursive  feature elimination.</p> </li> </ul> <p>Examples:</p> <p>Prepare a LinearModel instance, fit the model, automatically eliminate insignificant terms and plot the relevance of the parameters and the residuals. In the DataFrame df_gof you can  see when which feature was removed and the current  goodness-of-fit values can also be viewed. If you run the  following code in  a Jupyter Notebook, the plots and the html  representation of the model will be displayed.</p> <pre><code>import pandas as pd\nimport daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nlm = dsp.LinearModel(\n        source=df,\n        target='dissolution',\n        features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n        disturbances=['temperature', 'preparation'],\n        alpha=0.05,\n        order=3,\n        encode_categoricals=False\n    )\ndf_gof = pd.concat(list(lm.recursive_elimination()))\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label(info=True)\ndsp.ResidualsCharts(lm).plot().stripes().label(info=True)\nlm\n</code></pre>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.residual_data","title":"<code>residual_data()</code>","text":"<p>Get the residual data from the fitted model.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The residual data containing the residuals, observation index, and predicted values.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('partial_factorial')\ntarget = 'Yield'\nfeatures = [c for c in df.columns if c != target]\nlm = LinearModel(df, target, features)\nprint(lm.residual_data())\n</code></pre> <pre><code>    Observation      Residuals  Prediction\n0             1  9.250000e+00       46.75\n1             2  2.000000e+00       51.00\n2             3 -1.050000e+01       73.50\n3             4 -2.500000e-01       65.25\n4             5 -1.421085e-14       53.00\n5             6  1.025000e+01       44.75\n6             7 -2.500000e-01       67.25\n7             8 -1.050000e+01       71.50\n8             9  3.750000e+00       65.25\n9            10 -1.200000e+01       57.00\n10           11 -1.500000e+00       79.50\n11           12  9.250000e+00       83.75\n12           13 -1.000000e+01       59.00\n13           14 -3.250000e+00       63.25\n14           15  9.250000e+00       85.75\n15           16  4.500000e+00       77.50\n</code></pre>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.rnr","title":"<code>rnr(evaluate_ia='auto')</code>","text":"<p>Get the Gage R&amp;R analysis results as table.</p> <p>The table contains the following rows:</p> <ul> <li>R&amp;R: The sum of repeatability and reproducibility.</li> <li>EV: The repeatability component (Equipement Variation).</li> <li>AV or GV: The reproducibility component    (Appriser or Gage Variation).</li> <li>Part: The part-to-part component.</li> <li>Total: The sum of the repeatability, reproducibility,    and part-to-part.</li> </ul> <p>The table contains the following columns:</p> <ul> <li>MS: The variance estimation.</li> <li>MS/Total: The estimated variance divided by the total variance.</li> <li>s: The standard deviation as square root of the variance.</li> <li>6s: The 6 times the standard deviation.</li> <li>6s/Total: The 6 times the standard deviation divided by the      total 6 times the standard deviation.</li> <li>6s/Tolerance: The 6 times the standard deviation divided by      the tolerance.</li> </ul> <p>Parameters:</p> <ul> <li> <code>evaluate_ia</code>               (<code>bool | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>Whether to include the interaction term in the analysis. If 'auto', the interaction term is included if it is  significant. Otherwise, the interaction term is excluded and the model is refit without the interaction term.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The Gage R&amp;R analysis results as table.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nrnr_model = dsp.GageRnRModel(\n    source=df,\n    target='result_rnr',\n    part='part',\n    gage=gage,\n    u_av='operator')\nprint(rnr_model.rnr())\n</code></pre> <pre><code>                 MS  MS/Total         s        6s  6s/Total  6s/Tolerance\nR&amp;R    6.736111e-07   0.02248  0.000821  0.004924  0.149932      0.164148\nEV     6.736111e-07   0.02248  0.000821  0.004924  0.149932      0.164148\nAV     0.000000e+00   0.00000  0.000000  0.000000  0.000000      0.000000\nPart   2.929174e-05   0.97752  0.005412  0.032473  0.988696      1.082437\nTotal  2.996535e-05   1.00000  0.005474  0.032844  1.000000      1.094812\n</code></pre> Notes <p>The mean squarse used for the calculation of the variances are computed using the <code>anova</code> method. The variance components are  then calculated as follows:</p> <p>With interaction term:</p> \\[ s^2_{EV} = MS_{EV} = MS_{residual} \\] \\[ s^2_{operator} = \\frac{MS_{operator} - MS_{IA}}{n_{parts} n_{replication}} \\] \\[ s^2_{IA} = \\frac{MS_{IA} - MS_{EV}}{n_{replication}} \\] \\[ s^2_{Part} = \\frac{MS_{Part} - MS_{IA}}{n_{operator} n_{replication}} \\] \\[ s^2_{AV} = s^2_{operator} + s^2_{IA} \\] <p>Without interaction term:</p> \\[ s^2_{EV} = MS_{EV} = MS_{residual} \\] \\[ s^2_{operator} = \\frac{MS_{operator} - MS_{EV}}{n_{parts} n_{replication}} \\] \\[ s^2_{part} = \\frac{MS_{part} - MS_{EV}}{n_{operator} n_{replication}} \\] <p>Variance summary:</p> \\[ s^2_{RnR} = s^2_{EV} + s^2_{AV} \\] \\[ s^2_{total} = s^2_{RnR} + s^2_{part} \\]"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.summary","title":"<code>summary(anova_typ=None, vif=True, **kwds)</code>","text":"<p>Generate a summary of the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>anova_typ</code>               (<code>Literal['', 'I', 'II', 'III', None]</code>, default:                   <code>None</code> )           \u2013            <p>If not None, add an ANOVA table of provided type to the  summary, by default None.</p> </li> <li> <code>vif</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, variance inflation factors (VIF) are added to the  anova table. Will only be considered if anova_typ is not  None, by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>summary</code>  method of <code>statsmodels.regression.linear_model.RegressionResults</code>  class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Summary</code>           \u2013            <p>A summary object containing information about the fitted  model.</p> </li> </ul>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.uncertainties","title":"<code>uncertainties()</code>","text":"<p>The uncertainties of the measurement system.</p> <p>The table contains the following rows:</p> <ul> <li>RE: Resolution uncertainty</li> <li>BI: Bias uncertainty</li> <li>EVR: Equipment variation on the Reference (repeatability) </li> <li>MS: Measurement System uncertainty</li> <li>EVO: Equipement Variation on the Object(repeatability)</li> <li>AV: Appraiser Variation uncertainty</li> <li>IA: Interaction uncertainty</li> <li>MP: Measurement Process (or Precision) uncertainty</li> </ul> <p>The table contains the following columns:</p> <ul> <li>u: The measurement uncertainty for the respective components</li> <li>U: The expanded uncertainty as k * u</li> <li>Q: The Quality Indicator serves as a quality indicator for the    measurement process, reflecting how well the measurement    system performs in relation to the specified requirements and    tolerances.</li> <li>rank: The rank of the uncertainty component, where a lower   rank indicates a more significant contribution to the overall    uncertainty.</li> </ul> <p>Returns:</p> <ul> <li> <code>u</code> (              <code>DataFrame</code> )          \u2013            <p>The uncertainties of the measurement system.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nrnr_model = dsp.GageRnRModel(\n    source=df,\n    target='result_rnr',\n    part='part',\n    gage=gage,\n    u_av='operator')\nmodel.uncertainties()\nprint(model.df_u)\n</code></pre> <pre><code>                u         U         Q  rank\nCAL      0.000100  0.000200  0.013333   5.0\nRE       0.000289  0.000577  0.038490   3.0\nBI       0.000196  0.000393  0.026173   4.0\nLIN      0.000000  0.000000  0.000000   NaN\nEVR      0.000688  0.001377  0.091785   2.0\nMS_REST  0.000000  0.000000  0.000000   NaN\nMS       0.000723  0.001446  0.096371   NaN\nEVO      0.000821  0.001641  0.109432   1.0\nAV       0.000000  0.000000  0.000000   NaN\nGV       0.000000  0.000000  0.000000   NaN\nIA       0.000000  0.000000  0.000000   NaN\nT        0.000000  0.000000  0.000000   NaN\nSTAB     0.000000  0.000000  0.000000   NaN\nOBJ      0.000000  0.000000  0.000000   NaN\nMP_REST  0.000000  0.000000  0.000000   NaN\nMP       0.000850  0.001700  0.113305   NaN\n</code></pre>"},{"location":"anova/gage-rnr-model/#daspi.anova.model.GageRnRModel.variance_inflation_factor","title":"<code>variance_inflation_factor(threshold=5)</code>","text":"<p>Calculate the variance inflation factor (VIF) and the  generalized variance inflation factor (GVIF) for each predictor variable in the fitted model.</p> <p>This function takes a regression model as input and returns a  DataFrame containing the VIF, GVIF (= VIF^(1/2*dof)), threshold  for GVIF, collinearity status and calculation kind for each  predictor variable in the model. The VIF and GVIF are measures of multicollinearity, which can help identify variables that are highly correlated with each other.</p> <p>Parameters:</p> <ul> <li> <code>threshold</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The threshold for deciding whether a predictor is collinear. Common values are 5 and 10. By default 5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the VIF, GVIF, threshold, collinearity status and performed method for each predictor variable in the  model.</p> </li> </ul>"},{"location":"anova/gage-study-model/","title":"Gage study model","text":""},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel","title":"<code>daspi.anova.model.GageStudyModel</code>","text":"<p>               Bases: <code>LinearModel</code></p> <p>Calculates uncertainties for a measurement system (MSA Type 1  study), supporting one or multiple GageEstimator instances. If  multiple are provided, the uncertainty for linearity is also  calculated.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas DataFrame as tabular data in a long format used for the model.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name for source data holding the measurement values.</p> </li> <li> <code>reference</code>               (<code>str</code>)           \u2013            <p>Column name holding the reference values for the measured parts. This column is also used to identify which measured  values belong to which reference part. If the column has missing  values, the pandas method <code>ffill()</code> is used to ensure that the  column is filled. The uncertainty u_lin is determined if the  column contains several reference values, unless a known  measurement uncertainty is given with the argument <code>u_lin</code>.</p> </li> <li> <code>tolerance</code>               (<code>float | SpecLimits | Specification</code>)           \u2013            <p>The specification limits for the measurement system. This can  be a float, a <code>SpecLimits</code> instance or a <code>Specification</code>  instance. If a float is given, it is interpreted as the  tolerance (e.g., 0.1 for \u00b10.05).</p> </li> <li> <code>resolution</code>               (<code>float | None</code>)           \u2013            <p>The resolution of the measurement system. If None, the resolution is estimated from the data. If a float is given, it is interpreted as the resolution (e.g., 0.01 for a resolution of 0.01).</p> </li> <li> <code>u_cal</code>               (<code>MeasurementUncertainty | float</code>)           \u2013            <p>The measurement uncertainty of the gage used to measure the  reference value. This parameter quantifies the uncertainty  associated with the measurement device itself, reflecting how  much the measured value could vary due to the inherent  limitations of the gage. If a float is specified, it is assumed  to be the expanded uncertainty with a coverage factor of  <code>k = 2</code>, which typically corresponds to a 95% confidence level.  Please note that the coverage factor of the calibration is  independent of the coverage factor selected here.</p> </li> <li> <code>u_bi</code>               (<code>MeasurementUncertainty | None</code>, default:                   <code>None</code> )           \u2013            <p>The uncertainty for bias <code>u_BI</code> can be specified here if it is  known; otherwise, it will be determined from the data. This parameter represents the systematic error that may affect the  measurement results, indicating how much the measured values  deviate from the true value due to consistent inaccuracies. The default is None.</p> </li> <li> <code>u_lin</code>               (<code>MeasurementUncertainty | None</code>, default:                   <code>None</code> )           \u2013            <p>The measurement uncertainty for linearity <code>u_LIN</code> is determined  if multiple reference values are provided. This parameter  assesses how well the measured values conform to a linear  relationship with the reference values. However, it will not be  determined if a known measurement uncertainty is provided here.  The default is None.</p> </li> <li> <code>u_rest</code>               (<code>MeasurementUncertainty | None</code>, default:                   <code>None</code> )           \u2013            <p>The uncertainty for further uncertainties not covered by the  parameters above. This parameter accounts for all additional  sources of uncertainty that may affect the overall measurement  but are not specifically addressed by the default uncertainties  provided here. It provides a more comprehensive assessment of  measurement uncertainty by considering factors that may arise  from environmental conditions, operator influences, or other  unknown variables. If known, it can be specified here;  otherwise, the default value is None.</p> </li> <li> <code>k</code>               (<code>int | float</code>, default:                   <code>2</code> )           \u2013            <p>The coverage factor for expanded uncertainty. It is used as a  multiplier to determine the expanded uncertainty based on the  standard uncertainty. The value of <code>k</code> is typically set to  reflect the desired confidence level in the  measurement  results. Default is 2, typical values are: - k=2 corresponds to a confidence interval of 95.45% - k=3 corresponds to a confidence interval of 99.73%</p> </li> <li> <code>tolerance_ratio</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>The ratio of the tolerance to the standard deviation of the measurement system. If the ratio is below this limit, the measurement system is considered unacceptable. Default is 0.2.</p> </li> <li> <code>q_ms_limit</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>The limit for the Q_MS value. If the Q_MS is below this limit, the measurement system is considered acceptable.  Default is 0.15.</p> </li> <li> <code>cg_limit</code>               (<code>float</code>, default:                   <code>1.33</code> )           \u2013            <p>The limit for the Gage R&amp;R study's Cg value. If the Cg value below this limit, the measurement system is considered unacceptable. Default is 1.33.</p> </li> <li> <code>cgk_limit</code>               (<code>float</code>, default:                   <code>1.33</code> )           \u2013            <p>The limit for the Gage R&amp;R study's Cgk value. If the Cgk value is below this limit, the measurement system is considered unacceptable. Default is 1.33.</p> </li> <li> <code>resolution_ratio_limit</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The ratio of the resolution to the standard deviation of the measurement system. If the ratio is below this limit, the measurement system is considered unacceptable. Default is 0.05.</p> </li> <li> <code>bias_corrected</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicates whether the bias is corrected for the Gage R&amp;R study.  If True, the bias is not included in the measurement uncertainty;  otherwise, it is included. Default is False.</p> </li> </ul> <p>Examples:</p> <p>Run the following command in a jupyter notebook to get the html output of <code>gage</code> or you can also use <code>print(repr(gage))</code> instead:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nchart = dsp.GageStudyCharts(\n        gage, stretch_figsize=1.5\n    ).plot(\n    ).stripes(\n    ).label(\n    ) # .save('path/to/file.png')\ngage # or print(repr(gage))\n</code></pre> Notes <p>If only one reference is provided, the uncertainty for linearity  (LIN) will be 0.0. If multiple references are provided, the  uncertainty for linearity will be calculated based on the  standard deviation of the biases of the GageEstimator instances.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.T_min_UMS","title":"<code>T_min_UMS</code>  <code>property</code>","text":"<p>The minimum allowed tolerance for this testing system based on the uncertainty (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.alpha","title":"<code>alpha</code>  <code>property</code> <code>writable</code>","text":"<p>Alpha risk as significance threshold for p-value of exegenous factors.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.bias","title":"<code>bias</code>  <code>property</code>","text":"<p>Returns the bias of the Gage study (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.bias_corrected","title":"<code>bias_corrected</code>  <code>property</code>","text":"<p>Whether the bias is corrected for the Gage R&amp;R study. If  True, the bias itself is not included in the measurement  uncertainty; otherwise, it is.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.captions","title":"<code>captions</code>  <code>property</code>","text":"<p>Get the captions for the tables used for html output (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.data","title":"<code>data = source.rename(columns=(self.feature_map | self.target_map))[list(self.feature_map.values()) + list(self.target_map.values())].copy()</code>  <code>instance-attribute</code>","text":"<p>The Pandas DataFrame containing the data for the linear model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.design_info","title":"<code>design_info</code>  <code>property</code>","text":"<p>Get the DesignInfo instance of current fitted model (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.design_matrix","title":"<code>design_matrix</code>  <code>property</code>","text":"<p>Get the design matrix of the current fitted model (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.disturbances","title":"<code>disturbances = disturbances</code>  <code>instance-attribute</code>","text":"<p>The list of disturbances variables used in the linear  model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.effect_threshold","title":"<code>effect_threshold</code>  <code>property</code>","text":"<p>Calculates the threshold for the effect of adding a term to the model. The threshold is calculated as the inverse survival  function (inverse of sf) at the given alpha (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.excluded","title":"<code>excluded = set()</code>  <code>instance-attribute</code>","text":"<p>A set of feature names that should be excluded from the model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.feature_map","title":"<code>feature_map = {f: _ffor (f, _f) in (zip(features, f_main_terms))} | {c: _cfor (c, _c) in (zip(disturbances, d_main_terms))}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the original feature names to the encoded  names (term) used in the model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.features","title":"<code>features = features</code>  <code>instance-attribute</code>","text":"<p>The list of features used in the linear model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.fitted","title":"<code>fitted</code>  <code>property</code>","text":"<p>Whether the model is fitted (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.formula","title":"<code>formula</code>  <code>property</code>","text":"<p>Get the formula used for the linear model, excluding any factors specified in the <code>exclude</code> attribute. The formula is constructed based on the excluded factors. If the intercept is excluded, the formula will include '-1' as the first term. Otherwise, the formula will include the original terms (excluding the excluded factors) separated by '+' (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.gage","title":"<code>gage</code>  <code>property</code>","text":"<p>Returns the GageEstimator instances (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.generalized_vif","title":"<code>generalized_vif = generalized_vif</code>  <code>instance-attribute</code>","text":"<p>If True, the generalized VIF is calculated when possible. Otherwise, only the straightforward VIF (via R2) is calculated.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.initial_formula","title":"<code>initial_formula</code>  <code>property</code>","text":"<p>Get the initial formula for the ANOVA model (read-only).</p> <p>The initial formula is constructed from the target variable and  the initial terms, which are the terms with an interaction order  less than or equal to the specified order.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.k","title":"<code>k</code>  <code>property</code> <code>writable</code>","text":"<p>Get the coverage factor <code>k</code> used in uncertainty  calculations.</p> <p>This property returns the coverage factor, which is a multiplier  used to determine the expanded uncertainty based on the standard  uncertainty. The value of <code>k</code> is typically set to reflect the  desired confidence level in the measurement results.</p> <p>Set the coverage factor with a positive number, typical values  are: - k=2 corresponds to a confidence interval of 95.45% - k=3 corresponds to a confidence interval of 99.73%</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.main_parameters","title":"<code>main_parameters</code>  <code>property</code>","text":"<p>Get all main parameters of current model excluding intercept (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.main_term_map","title":"<code>main_term_map = {v: kfor (k, v) in (self.feature_map.items())}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the main term names (no interactions) back  to the original feature names used in the model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.model","title":"<code>model</code>  <code>property</code>","text":"<p>Get regression results of fitted model. Calls <code>fit</code> method if no model is fitted yet (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.n_references","title":"<code>n_references</code>  <code>property</code>","text":"<p>Get the amount of references used in the study (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.n_replications","title":"<code>n_replications</code>  <code>property</code>","text":"<p>Get the number of replications for each reference (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>The number of samples used in the Gage study (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Get the names of all variables for the current fitted  model in the composition using the original feature and  disturbances names (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.q_ms_limit","title":"<code>q_ms_limit</code>  <code>property</code>","text":"<p>Get the provided limit for the Q_MS as float between 0 and 1 (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.ref_gages","title":"<code>ref_gages</code>  <code>property</code>","text":"<p>Returns a list of GageEstimator instances used in the model (read_only).</p> <p>If only one reference is used, it returns a list containing  one GageEstimator of that reference. If multiple references are used, it returns a list of GageEstimator instances for each reference part measured.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.resolution","title":"<code>resolution</code>  <code>property</code>","text":"<p>Returns the resolution of the first GageEstimator instance (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.skip_intercept_as_least","title":"<code>skip_intercept_as_least = skip_intercept_as_least</code>  <code>instance-attribute</code>","text":"<p>If True, the intercept is not treated as a least significant term</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.target_map","title":"<code>target_map = {target: 'y'}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the original feature names to the encoded  feature names used in the model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.term_map","title":"<code>term_map</code>  <code>property</code>","text":"<p>Get the names of all internal used and original terms  variables for the current fitted model as dict (read-only)</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.terms","title":"<code>terms</code>  <code>property</code>","text":"<p>Get the encoded names of all variables for the current  fitted model (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.tolerance","title":"<code>tolerance</code>  <code>property</code>","text":"<p>Returns the tolerance of the first GageEstimator instance  (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_bi","title":"<code>u_bi</code>  <code>property</code>","text":"<p>The uncertainty of the bias of the testing system (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_cal","title":"<code>u_cal</code>  <code>property</code>","text":"<p>The expanded uncertainty of the calibration.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_evr","title":"<code>u_evr</code>  <code>property</code>","text":"<p>The uncertainty of the expanded variance ratio of the testing system (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_lin","title":"<code>u_lin</code>  <code>property</code>","text":"<p>The uncertainty of linearity of the measurement system  (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_ms","title":"<code>u_ms</code>  <code>property</code>","text":"<p>The uncertainty of the measurement system (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_re","title":"<code>u_re</code>  <code>property</code>","text":"<p>The uncertainty of the resolution of the testing system (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.u_rest","title":"<code>u_rest</code>  <code>property</code>","text":"<p>The uncertainty of the repeatability of the testing system (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.uncertainty","title":"<code>uncertainty</code>  <code>property</code>","text":"<p>Get uncertainty of the model as square root of MS_Residual (read-only).</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.__html__","title":"<code>__html__()</code>","text":"<p>This method exists to inform other HTML-using modules (e.g.  Markupsafe, htmltag, etc) that this object is HTML and does not  need things like special characters (&lt;&gt;&amp;) escaped.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.__repr__","title":"<code>__repr__()</code>","text":"<p>Generates an string representation of the model's  diagnostic information.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string containing the model's diagnostic information.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.__str__","title":"<code>__str__()</code>","text":"<p>Generates a string representation of the linear regression  model's formula.</p> <p>The formula is constructed by iterating over the parameter  statistics and adding each parameter name and coefficient to the formula string. The target variable is included at the start of  the formula.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.capabilities","title":"<code>capabilities()</code>","text":"<p>Returns a DataFrame with the capabilities of the measurement  system. </p> <p>The capabilities include Cg, Cgk, and the ratio of resolution the .</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Capabilities for Cp, Cpk, Cg, Cgk and the ratio of  resolution to standard deviation.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nprint(gage.capabilities())\n</code></pre> <pre><code>            Value  Limit  Capable     T_min\nCg        2.179005   1.33     True  0.018311\nCgk       1.932051   1.33     True  0.021711\nRE_ratio  0.033333   0.05     True  0.020000\nU_MS      0.096371   0.15     True  0.019274\np_BI      0.001024   0.05    False       NaN\n</code></pre>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.effects","title":"<code>effects()</code>","text":"<p>Calculates the impact of each term on the target. The effects are described as absolute number of the parameter  coefficients devided by its standard error.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.eliminate","title":"<code>eliminate(parameter)</code>","text":"<p>Removes the given parameter from the model by adding it to t he <code>exclude</code> set. Call <code>fit</code> to refit the model.</p> <p>Parameters:</p> <ul> <li> <code>parameter</code>               (<code>str</code>)           \u2013            <p>The feature name, the disturbances name or the interaction  of multiple features to be removed from the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The current instance of the model for more method chaining.</p> </li> </ul> <p>Examples:</p> <p>Prepare a LinearModel instance, fit the model and plot the  relevance of the parameters. If you run the following code in a Jupyter Notebook, the plot and the html representation of the model will be displayed.</p> <p><pre><code>import pandas as pd\nimport daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nlm = dsp.LinearModel(\n        source=df,\n        target='dissolution',\n        features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n        disturbances=['temperature', 'preparation'],\n        alpha=0.05,\n        order=3,\n        encode_categoricals=False\n    )\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre> Now remove the least significant term from the model and refit. Repeat the process until the model contains only significant terms.</p> <pre><code>lm.eliminate('stirrer:brand:catalyst')\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre> <p>To add again a feature to the model, use the <code>include</code> method. For an automatic elimination of insignificant terms, use the 'recursive_elimination' method.</p> Notes <p>Always be careful when removing the intercept. If the intercept is  missing, Patsy will automatically add all one-hot encoded levels for a categorical variable to compensate for this missing term. This  will result in extremely high VIFs.</p> <p>Raises:</p> <ul> <li> <code>AssertionError: </code>             \u2013            <p>If the given term is not in the model.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.fit","title":"<code>fit(**kwds)</code>","text":"<p>Create and fit a ordinary least squares model using current  formula. To fit with a user-defined formula, use the  <code>formula</code> keyword argument.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Pass formula and other keyword arguments to <code>ols</code> function of <code>statsmodels.formula.api</code>.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.from_gage_estimators","title":"<code>from_gage_estimators(gages, k=2, bias_corrected=False)</code>  <code>staticmethod</code>","text":"<p>Create a GageStudyModel from a list of GageEstimator  instances. This method is useful when you already have  GageEstimator instances and want to create a GageStudyModel  without needing to provide the source DataFrame and other  parameters again.</p> <p>Parameters:</p> <ul> <li> <code>gages</code>               (<code>GageEstimator | List[GageEstimator]</code>)           \u2013            <p>A list of GageEstimator instances to create the model from.</p> </li> <li> <code>k</code>               (<code>int | float</code>, default:                   <code>2</code> )           \u2013            <p>The coverage factor for expanded uncertainty. It is used as  a multiplier to determine the expanded uncertainty based on  the standard uncertainty. The value of <code>k</code> is typically set  to reflect the desired confidence level in the  measurement  results. Default is 2, typical values are: - k=2 corresponds to a confidence interval of 95.45% - k=3 corresponds to a confidence interval of 99.73%</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GageStudyModel</code>           \u2013            <p>A new GageStudyModel instance created from the provided  GageEstimator instances.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.gof_metrics","title":"<code>gof_metrics(index=0)</code>","text":"<p>Get different goodness-of-fit metrics (read-only).</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int | str</code>, default:                   <code>0</code> )           \u2013            <p>Value is set as index. When using the method  recursive_elimination, the current step is passed as index</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The goodness-of-fit metrics table as DataFrame containing the following columns: - 'formula' = current formula - 's' = Uncertainty of the model as square root of MS_Residual - 'aic' = Akaike's information criteria - 'r2' = R-squared of the model - 'r2_adj' = adjusted R-squared - 'least_parameter' = the least significant term - 'p_least' = The p-value of least significant term, coming from ANOVA table Type-III. - 'hierarchical' = True if model is hierarchical</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.has_insignificant_term","title":"<code>has_insignificant_term(rsquared_max=0.99)</code>","text":"<p>Check if the fitted model has any insignificant terms.</p> <p>Parameters:</p> <ul> <li> <code>rsquared_max</code>               (<code>float in (0, 1)</code>, default:                   <code>0.99</code> )           \u2013            <p>The maximum R^2 value that the model can have to be  considered significant. If not provided, by default 0.99.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns True if the model has any insignificant terms, and  False otherwise.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.has_significant_interactions","title":"<code>has_significant_interactions()</code>","text":"<p>True if fitted model has significant interactions.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.highest_parameters","title":"<code>highest_parameters(features_only=False)</code>","text":"<p>Determines all main and interaction parameters that do not  occur in a higher interaction in this constellation.</p> <p>Parameters:</p> <ul> <li> <code>features_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, intercept and interaction parameters are not  returned. By default False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of highest parameters.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.include","title":"<code>include(parameter)</code>","text":"<p>Adds the given feature to the model by removing it from the <code>excluded</code> set. Call <code>fit</code> to refit the model.</p> <p>Parameters:</p> <ul> <li> <code>parameter</code>               (<code>str</code>)           \u2013            <p>The feature name, the disturbances name or the interaction  of multiple features to be added to the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The current instance of the model for more method chaining.</p> </li> </ul> <p>Examples:</p> <p>See <code>eliminate</code> method. After removing a term from the model, you can add it again by using the <code>include</code> method.</p> <pre><code>lm.include('C').fit()\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.is_hierarchical","title":"<code>is_hierarchical()</code>","text":"<p>Check if current fitted model is hierarchical.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.least_parameter","title":"<code>least_parameter()</code>","text":"<p>Get the parameter name with the least effect or the least  p-value coming from a ANOVA typ III table of current fitted  model.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The parameter name with the least p_value if possible or the parameter name with the least effect.</p> </li> </ul> Notes <p>This method checks if any p-values are missing (NaN). If there are missing p-values, it returns the term name that has the  smallest effect on the target variable. Otherwise, it returns the term name with the least p-value for the F-stats coming from current ANOVA table.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.optimize","title":"<code>optimize(maximize=True, bounds={})</code>","text":"<p>Optimize the prediction by optimizing the parameters.</p> <p>Parameters:</p> <ul> <li> <code>maximize</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to maximize the prediction or minimize it.</p> </li> <li> <code>bounds</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Bounds for the parameters to optimize. - You can freeze a paramater by setting it to the desired      value. For example, to fix the value of a parameter to 1,      you can set bounds = {'param_name': 1}. - To keep an ordinal or metric parameter within a specific     range, you can set bounds = {'param_name': (lower, upper)}.     For example, to constrain a parameter to be between 0 and      1, you can set bounds = {'param_name': (0, 1)}. - In order to limit the selection of a nominal parameter      only to a certain subset of the originally conained values,     you can set bounds = {'param_name': (val1, val2, ...)}.     For example, to limit the selection of a nominal parameter     to the values 'A' and 'B', you can set      bounds = {'param_name': ('A', 'B')}.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>The optimized parameters.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.p_values","title":"<code>p_values()</code>","text":"<p>Get P-value for significance of adding model terms using  anova typ III table for current model.</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.parameter_statistics","title":"<code>parameter_statistics(alpha=0.05, use_t=True)</code>","text":"<p>Calculate the parameter statistics for the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The significance level for the confidence intervals, by  default 0.05.</p> </li> <li> <code>use_t</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, use t-distribution for hypothesis testing and  confidence intervals. If False, use normal distribution,  by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A pandas DataFrame containing the parameter statistics for  the fitted model. The DataFrame includes columns for the  parameter estimates, standard errors, t-values  (or z-values), and p-values.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.predict","title":"<code>predict(xs)</code>","text":"<p>Predict y with given xs. Ensure that all non interactions are  given in xs</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The values for which you want to predict. Make sure that all non interaction parameters are given in xs. If multiple  values are to be predicted, provide a list of values for  each factor level.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the predicted values for the given values of the predictor variables.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.r2_pred","title":"<code>r2_pred()</code>","text":"<p>Calculate the predicted R-squared (R2_pred) for the fitted  model.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The predicted R-squared value for the fitted model.</p> </li> </ul> Notes <p>The predicted R-squared is a measure of how well the model would  predict new observations. It is calculated as:</p> <p>R2_pred = 1 - (Sum of Squared Prediction Errors / Total Sum of Squares)</p> <p>Where the prediction errors are calculated as the residuals  divided by (1 - leverage), where leverage is the diagonal  elements of the projection matrix P = X(X'X)^(-1)X'.</p> References <p>Calculations are made according to: https://support.minitab.com/de-de/minitab/help-and-how-to/statistical-modeling/doe/how-to/factorial/analyze-factorial-design/methods-and-formulas/goodness-of-fit-statistics/#press</p> <p>Further information about projection matrix (influence matrix or hat matrix) can be found in: https://en.wikipedia.org/wiki/Projection_matrix</p>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.recursive_elimination","title":"<code>recursive_elimination(rsquared_max=0.99, ensure_hierarchy=True, **kwds)</code>","text":"<p>Perform a recursive parameter elimination on the fitted model.</p> <p>This function starts with the complete model and recursively  eliminates parameters based on their p-values, until only  significant parameters remain in the model. The function yields  the goodness-of-fit metrics at each step of the elimination process.</p> <p>Parameters:</p> <ul> <li> <code>rsquared_max</code>               (<code>float in (0, 1)</code>, default:                   <code>0.99</code> )           \u2013            <p>If given, the model must have a lower R^2 value than the  given threshold, by default 0.99</p> </li> <li> <code>ensure_hierarchy</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Adds features at the end to ensure model is hierarchical,  by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for <code>ols</code> function of  <code>statsmodels.formula.api</code>.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The goodness-of-fit metrics at each step of the recursive  feature elimination.</p> </li> </ul> <p>Examples:</p> <p>Prepare a LinearModel instance, fit the model, automatically eliminate insignificant terms and plot the relevance of the parameters and the residuals. In the DataFrame df_gof you can  see when which feature was removed and the current  goodness-of-fit values can also be viewed. If you run the  following code in  a Jupyter Notebook, the plots and the html  representation of the model will be displayed.</p> <pre><code>import pandas as pd\nimport daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nlm = dsp.LinearModel(\n        source=df,\n        target='dissolution',\n        features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n        disturbances=['temperature', 'preparation'],\n        alpha=0.05,\n        order=3,\n        encode_categoricals=False\n    )\ndf_gof = pd.concat(list(lm.recursive_elimination()))\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label(info=True)\ndsp.ResidualsCharts(lm).plot().stripes().label(info=True)\nlm\n</code></pre>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.references_analysis","title":"<code>references_analysis()</code>","text":"<p>Returns a DataFrame with the analysis of the reference  parts. </p> <p>The analysis includes the GageEstimator statistics for each  reference part, such as Cg, Cgk, resolution ratio, and bias.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Analysis of the reference parts with GageEstimator  statistics.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nprint(gage.references_analysis())\n</code></pre> <pre><code>     Ref     mean     Bias         s      R\n1  0.101  0.10066 -0.00034  0.000688  0.003\n</code></pre>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.residual_data","title":"<code>residual_data()</code>","text":"<p>Get the residual data from the fitted model.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The residual data containing the residuals, observation index, and predicted values.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('partial_factorial')\ntarget = 'Yield'\nfeatures = [c for c in df.columns if c != target]\nlm = LinearModel(df, target, features)\nprint(lm.residual_data())\n</code></pre> <pre><code>    Observation      Residuals  Prediction\n0             1  9.250000e+00       46.75\n1             2  2.000000e+00       51.00\n2             3 -1.050000e+01       73.50\n3             4 -2.500000e-01       65.25\n4             5 -1.421085e-14       53.00\n5             6  1.025000e+01       44.75\n6             7 -2.500000e-01       67.25\n7             8 -1.050000e+01       71.50\n8             9  3.750000e+00       65.25\n9            10 -1.200000e+01       57.00\n10           11 -1.500000e+00       79.50\n11           12  9.250000e+00       83.75\n12           13 -1.000000e+01       59.00\n13           14 -3.250000e+00       63.25\n14           15  9.250000e+00       85.75\n15           16  4.500000e+00       77.50\n</code></pre>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.summary","title":"<code>summary(anova_typ=None, vif=True, **kwds)</code>","text":"<p>Generate a summary of the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>anova_typ</code>               (<code>Literal['', 'I', 'II', 'III', None]</code>, default:                   <code>None</code> )           \u2013            <p>If not None, add an ANOVA table of provided type to the  summary, by default None.</p> </li> <li> <code>vif</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, variance inflation factors (VIF) are added to the  anova table. Will only be considered if anova_typ is not  None, by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>summary</code>  method of <code>statsmodels.regression.linear_model.RegressionResults</code>  class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Summary</code>           \u2013            <p>A summary object containing information about the fitted  model.</p> </li> </ul>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.uncertainties","title":"<code>uncertainties()</code>","text":"<p>Returns a DataFrame with the uncertainties for the  measurement system.</p> <p>The table contains the following rows:</p> <ul> <li>CAL: Calibration uncertainty</li> <li>RE: Resolution uncertainty</li> <li>BI: Bias uncertainty</li> <li>LIN: Linearity uncertainty</li> <li>EVR: Equipment Variation on the Reference</li> <li>REST: Other known and provided uncertainty</li> <li>MS: Measurement System uncertainty</li> </ul> <p>The table contains the following columns:</p> <ul> <li>u: The measurement uncertainty for the respective components</li> <li>U: The expanded uncertainty as k * u</li> <li>Q: The Quality Indicator serves as a quality indicator for the    measurement process, reflecting how well the measurement    system performs in relation to the specified requirements and    tolerances.</li> <li>rank: The rank of the uncertainty component, where a lower   rank indicates a more significant contribution to the overall    uncertainty.</li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Uncertainties for CAL, RE, BI, LIN, EVR, REST, MS.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],)\nprint(gage.uncertainties())\n</code></pre> <pre><code>             u         U         Q  rank\nCAL   0.000100  0.000200  0.013333   4.0\nRE    0.000289  0.000577  0.038490   2.0\nBI    0.000196  0.000393  0.026173   3.0\nLIN   0.000000  0.000000  0.000000   NaN\nEVR   0.000688  0.001377  0.091785   1.0\nREST  0.000000  0.000000  0.000000   NaN\nMS    0.000723  0.001446  0.096371   NaN\n</code></pre>"},{"location":"anova/gage-study-model/#daspi.anova.model.GageStudyModel.variance_inflation_factor","title":"<code>variance_inflation_factor(threshold=5)</code>","text":"<p>Calculate the variance inflation factor (VIF) and the  generalized variance inflation factor (GVIF) for each predictor variable in the fitted model.</p> <p>This function takes a regression model as input and returns a  DataFrame containing the VIF, GVIF (= VIF^(1/2*dof)), threshold  for GVIF, collinearity status and calculation kind for each  predictor variable in the model. The VIF and GVIF are measures of multicollinearity, which can help identify variables that are highly correlated with each other.</p> <p>Parameters:</p> <ul> <li> <code>threshold</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The threshold for deciding whether a predictor is collinear. Common values are 5 and 10. By default 5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the VIF, GVIF, threshold, collinearity status and performed method for each predictor variable in the  model.</p> </li> </ul>"},{"location":"anova/linear-model/","title":"Linear model","text":""},{"location":"anova/linear-model/#daspi.anova.model.LinearModel","title":"<code>daspi.anova.model.LinearModel</code>","text":"<p>               Bases: <code>BaseHTMLReprModel</code></p> <p>This class is used to create and simplify linear models so that  only significant features describe the model.</p> <p>Balanced models (DOEs or EVOPs) including continuous can be  analyzed. With this class, you can create an encoded design matrix with all factor levels, including their interactions. All non-significant factors can then be automatically eliminated. Furthermore, this class allows the examination of main effects,  the sum of squares (explained variation), and the ANOVA table in  more detail.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas DataFrame as tabular data in a long format used for the model.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the endogenous variable.</p> </li> <li> <code>features</code>               (<code>List[str]</code>)           \u2013            <p>Column names of the exogenous variables that can be actively  changed (factor levels for DOE or EVOP). Interactions are also  created for these variables if the order is set &gt; 1.</p> </li> <li> <code>disturbances</code>               (<code>List[str]</code>, default:                   <code>[]</code> )           \u2013            <p>Column names for exogenous variables that are logged but cannot  be influenced. No interactions are created for these variables.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Threshold as alpha risk. All features, including continuous and  intercept, that have a p-value smaller than alpha are removed  during the automatic elimination of the factors. Default is 0.05.</p> </li> <li> <code>skip_intercept_as_least</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the intercept is not removed as a least significant  term when using recursive feature elimination. Also if True, the intercept does not appear when calling the <code>least_parameter</code> method, by default True.</p> </li> <li> <code>encode_features</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, all of the provided feature variables are encoded using one-hot encoding by changing the data type to category.  Otherwise they are interpreted as continuous variables when  possible, by default True.</p> </li> <li> <code>fit_at_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the model is fitted at initialization. Otherwise, the model is fitted after calling the <code>fit</code> method. Default is True.</p> </li> </ul> <p>Examples:</p> <p>Do some ANOVA and statistics on a dataset. Run the example below in  a Jupyther Notebook to see the results.</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nmodel = dsp.LinearModel(\n    source=df,\n    target='dissolution',\n    features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n    disturbances=['temperature', 'preparation'],\n    order=2)\n\n# Store goodnes of fit values for each elimination step\ndf_gof = pd.concat(model.recursive_elimination())\n\n# Plot residual and parameter relevance analysis\ndsp.ResidualsCharts(model).plot().stripes().label(info=True)\ndsp.ParameterRelevanceCharts(model).plot().label(info=True)\n\n# Get HTML output\nmodel\n</code></pre> Notes <p>Always be careful when removing the intercept. If the intercept is  missing, Patsy will automatically add all one-hot encoded levels for a categorical variable to compensate for this missing term. This  will result in extremely high VIFs. That means that the parameters are not linearly independent.</p> Terminology <ul> <li>feature:    The original name as it appears in the provided data.</li> <li>term:   The name of the term as it appears in the design matrix. All    feature names are converted to \"xi\" where i is an ascending    number. The name of the first feature becomes \"x0\", the second    becomes \"x1\",... The disturbance variables are also converted in    the same way, but instead of the letter \"x\" the letter \"e\" is    used.</li> <li>parameter:   The variable names in connection with a coefficient, but in the   composition with the original feature names.</li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.alpha","title":"<code>alpha</code>  <code>property</code> <code>writable</code>","text":"<p>Alpha risk as significance threshold for p-value of exegenous factors.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.captions","title":"<code>captions</code>  <code>property</code>","text":"<p>Get the captions for the tables used for html output (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.data","title":"<code>data = source.rename(columns=(self.feature_map | self.target_map))[list(self.feature_map.values()) + list(self.target_map.values())].copy()</code>  <code>instance-attribute</code>","text":"<p>The Pandas DataFrame containing the data for the linear model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.design_info","title":"<code>design_info</code>  <code>property</code>","text":"<p>Get the DesignInfo instance of current fitted model (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.design_matrix","title":"<code>design_matrix</code>  <code>property</code>","text":"<p>Get the design matrix of the current fitted model (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.disturbances","title":"<code>disturbances = disturbances</code>  <code>instance-attribute</code>","text":"<p>The list of disturbances variables used in the linear  model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.effect_threshold","title":"<code>effect_threshold</code>  <code>property</code>","text":"<p>Calculates the threshold for the effect of adding a term to the model. The threshold is calculated as the inverse survival  function (inverse of sf) at the given alpha (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.excluded","title":"<code>excluded = set()</code>  <code>instance-attribute</code>","text":"<p>A set of feature names that should be excluded from the model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.feature_map","title":"<code>feature_map = {f: _ffor (f, _f) in (zip(features, f_main_terms))} | {c: _cfor (c, _c) in (zip(disturbances, d_main_terms))}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the original feature names to the encoded  names (term) used in the model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.features","title":"<code>features = features</code>  <code>instance-attribute</code>","text":"<p>The list of features used in the linear model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.fitted","title":"<code>fitted</code>  <code>property</code>","text":"<p>Whether the model is fitted (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.formula","title":"<code>formula</code>  <code>property</code>","text":"<p>Get the formula used for the linear model, excluding any factors specified in the <code>exclude</code> attribute. The formula is constructed based on the excluded factors. If the intercept is excluded, the formula will include '-1' as the first term. Otherwise, the formula will include the original terms (excluding the excluded factors) separated by '+' (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.generalized_vif","title":"<code>generalized_vif = generalized_vif</code>  <code>instance-attribute</code>","text":"<p>If True, the generalized VIF is calculated when possible. Otherwise, only the straightforward VIF (via R2) is calculated.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.initial_formula","title":"<code>initial_formula</code>  <code>property</code>","text":"<p>Get the initial formula for the ANOVA model (read-only).</p> <p>The initial formula is constructed from the target variable and  the initial terms, which are the terms with an interaction order  less than or equal to the specified order.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.main_parameters","title":"<code>main_parameters</code>  <code>property</code>","text":"<p>Get all main parameters of current model excluding intercept (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.main_term_map","title":"<code>main_term_map = {v: kfor (k, v) in (self.feature_map.items())}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the main term names (no interactions) back  to the original feature names used in the model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.model","title":"<code>model</code>  <code>property</code>","text":"<p>Get regression results of fitted model. Calls <code>fit</code> method if no model is fitted yet (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Get the names of all variables for the current fitted  model in the composition using the original feature and  disturbances names (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.skip_intercept_as_least","title":"<code>skip_intercept_as_least = skip_intercept_as_least</code>  <code>instance-attribute</code>","text":"<p>If True, the intercept is not treated as a least significant term</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The name of the target variable for the linear model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.target_map","title":"<code>target_map = {target: 'y'}</code>  <code>instance-attribute</code>","text":"<p>A dictionary that maps the original feature names to the encoded  feature names used in the model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.term_map","title":"<code>term_map</code>  <code>property</code>","text":"<p>Get the names of all internal used and original terms  variables for the current fitted model as dict (read-only)</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.terms","title":"<code>terms</code>  <code>property</code>","text":"<p>Get the encoded names of all variables for the current  fitted model (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.uncertainty","title":"<code>uncertainty</code>  <code>property</code>","text":"<p>Get uncertainty of the model as square root of MS_Residual (read-only).</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.__html__","title":"<code>__html__()</code>","text":"<p>This method exists to inform other HTML-using modules (e.g.  Markupsafe, htmltag, etc) that this object is HTML and does not  need things like special characters (&lt;&gt;&amp;) escaped.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.__repr__","title":"<code>__repr__()</code>","text":"<p>Generates an string representation of the model's  diagnostic information.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string containing the model's diagnostic information.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.__str__","title":"<code>__str__()</code>","text":"<p>Generates a string representation of the linear regression  model's formula.</p> <p>The formula is constructed by iterating over the parameter  statistics and adding each parameter name and coefficient to the formula string. The target variable is included at the start of  the formula.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.anova","title":"<code>anova(typ='', vif=False)</code>","text":"<p>Perform an analysis of variance (ANOVA) on the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>typ</code>               (<code>Literal['', 'I', 'II', 'III']</code>, default:                   <code>''</code> )           \u2013            <p>The type of ANOVA to perform. Default is 'III', see notes for more informations about the types. - '' : If no or an invalid type is specified, Type-II is  used if the model has no significant interactions.  Otherwise, Type-III is used for hierarchical models and  Type-I is used for non-hierarchical models. - 'I' : Type I sum of squares ANOVA. - 'II' : Type II sum of squares ANOVA. - 'III' : Type III sum of squares ANOVA.</p> </li> <li> <code>vif</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, variance inflation factors (VIF) are added to the  anova table, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The ANOVA table as DataFrame containing the following columns: - DF : Degrees of freedom for model terms. - SS : Sum of squares for model terms. - F : F statistic value for significance of adding model terms. - p : P-value for significance of adding model terms. - n2 : Eta-square as effect size (proportion of explained variance). - np2 : Partial eta-square as partial effect size.</p> </li> </ul> Notes <p>The ANOVA table provides information about the significance of  each factor and interaction in the model. The type of ANOVA  determines how the sum of squares is partitioned among the  factors.</p> <p>The SAS and also Minitab software uses Type III by default. This type is also the only one who gives us a SS and p-value for the  Intercept. So Type-III is also used internaly for evaluating the least significant term. A discussion on which one to use can be  found here: https://stats.stackexchange.com/a/93031</p> <p>A nice conclusion about the differences between the types: - Typ-I: We choose the most \"important\" independent variable and  it will receive the maximum amount of variation possible. - Typ-II: We ignore the shared variation: no interaction is assumed. If this is true, the Type II Sums of Squares are statistically more powerful. However if in reality there is an interaction effect, the model will be wrong and there will be a problem in the conclusions of the analysis. - Typ-III: If there is an interaction effect and we are looking  for an \u201cequal\u201d split between the independent variables,  Type-III should be used.</p> <p>source: https://towardsdatascience.com/anovas-three-types-of-estimating-sums-of-squares-don-t-make-the-wrong-choice-91107c77a27a</p> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('anova3')\nlm = dsp.LinearModel(df, 'Cholesterol', ['Sex', 'Risk', 'Drug'])\nprint(lm.anova(typ='III').round(3))\n</code></pre> <pre><code>Typ-III    DF       SS       MS        F      p     n2\nsource                                                \nIntercept   1  390.868  390.868  453.467  0.000  0.864\nSex         1    2.075    2.075    2.407  0.127  0.005\nRisk        1   11.332   11.332   13.147  0.001  0.025\nDrug        2    0.816    0.408    0.473  0.626  0.002\nResidual   55   47.407    0.862      NaN    NaN  0.105\n</code></pre>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.effects","title":"<code>effects()</code>","text":"<p>Calculates the impact of each term on the target. The effects are described as absolute number of the parameter  coefficients devided by its standard error.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.eliminate","title":"<code>eliminate(parameter)</code>","text":"<p>Removes the given parameter from the model by adding it to t he <code>exclude</code> set. Call <code>fit</code> to refit the model.</p> <p>Parameters:</p> <ul> <li> <code>parameter</code>               (<code>str</code>)           \u2013            <p>The feature name, the disturbances name or the interaction  of multiple features to be removed from the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The current instance of the model for more method chaining.</p> </li> </ul> <p>Examples:</p> <p>Prepare a LinearModel instance, fit the model and plot the  relevance of the parameters. If you run the following code in a Jupyter Notebook, the plot and the html representation of the model will be displayed.</p> <p><pre><code>import pandas as pd\nimport daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nlm = dsp.LinearModel(\n        source=df,\n        target='dissolution',\n        features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n        disturbances=['temperature', 'preparation'],\n        alpha=0.05,\n        order=3,\n        encode_categoricals=False\n    )\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre> Now remove the least significant term from the model and refit. Repeat the process until the model contains only significant terms.</p> <pre><code>lm.eliminate('stirrer:brand:catalyst')\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre> <p>To add again a feature to the model, use the <code>include</code> method. For an automatic elimination of insignificant terms, use the 'recursive_elimination' method.</p> Notes <p>Always be careful when removing the intercept. If the intercept is  missing, Patsy will automatically add all one-hot encoded levels for a categorical variable to compensate for this missing term. This  will result in extremely high VIFs.</p> <p>Raises:</p> <ul> <li> <code>AssertionError: </code>             \u2013            <p>If the given term is not in the model.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.fit","title":"<code>fit(**kwds)</code>","text":"<p>Create and fit a ordinary least squares model using current  formula. To fit with a user-defined formula, use the  <code>formula</code> keyword argument.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Pass formula and other keyword arguments to <code>ols</code> function of <code>statsmodels.formula.api</code>.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.gof_metrics","title":"<code>gof_metrics(index=0)</code>","text":"<p>Get different goodness-of-fit metrics (read-only).</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int | str</code>, default:                   <code>0</code> )           \u2013            <p>Value is set as index. When using the method  recursive_elimination, the current step is passed as index</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The goodness-of-fit metrics table as DataFrame containing the following columns: - 'formula' = current formula - 's' = Uncertainty of the model as square root of MS_Residual - 'aic' = Akaike's information criteria - 'r2' = R-squared of the model - 'r2_adj' = adjusted R-squared - 'least_parameter' = the least significant term - 'p_least' = The p-value of least significant term, coming from ANOVA table Type-III. - 'hierarchical' = True if model is hierarchical</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.has_insignificant_term","title":"<code>has_insignificant_term(rsquared_max=0.99)</code>","text":"<p>Check if the fitted model has any insignificant terms.</p> <p>Parameters:</p> <ul> <li> <code>rsquared_max</code>               (<code>float in (0, 1)</code>, default:                   <code>0.99</code> )           \u2013            <p>The maximum R^2 value that the model can have to be  considered significant. If not provided, by default 0.99.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns True if the model has any insignificant terms, and  False otherwise.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.has_significant_interactions","title":"<code>has_significant_interactions()</code>","text":"<p>True if fitted model has significant interactions.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.highest_parameters","title":"<code>highest_parameters(features_only=False)</code>","text":"<p>Determines all main and interaction parameters that do not  occur in a higher interaction in this constellation.</p> <p>Parameters:</p> <ul> <li> <code>features_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, intercept and interaction parameters are not  returned. By default False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of highest parameters.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.include","title":"<code>include(parameter)</code>","text":"<p>Adds the given feature to the model by removing it from the <code>excluded</code> set. Call <code>fit</code> to refit the model.</p> <p>Parameters:</p> <ul> <li> <code>parameter</code>               (<code>str</code>)           \u2013            <p>The feature name, the disturbances name or the interaction  of multiple features to be added to the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The current instance of the model for more method chaining.</p> </li> </ul> <p>Examples:</p> <p>See <code>eliminate</code> method. After removing a term from the model, you can add it again by using the <code>include</code> method.</p> <pre><code>lm.include('C').fit()\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label()\nlm\n</code></pre>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.is_hierarchical","title":"<code>is_hierarchical()</code>","text":"<p>Check if current fitted model is hierarchical.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.least_parameter","title":"<code>least_parameter()</code>","text":"<p>Get the parameter name with the least effect or the least  p-value coming from a ANOVA typ III table of current fitted  model.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The parameter name with the least p_value if possible or the parameter name with the least effect.</p> </li> </ul> Notes <p>This method checks if any p-values are missing (NaN). If there are missing p-values, it returns the term name that has the  smallest effect on the target variable. Otherwise, it returns the term name with the least p-value for the F-stats coming from current ANOVA table.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.optimize","title":"<code>optimize(maximize=True, bounds={})</code>","text":"<p>Optimize the prediction by optimizing the parameters.</p> <p>Parameters:</p> <ul> <li> <code>maximize</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to maximize the prediction or minimize it.</p> </li> <li> <code>bounds</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Bounds for the parameters to optimize. - You can freeze a paramater by setting it to the desired      value. For example, to fix the value of a parameter to 1,      you can set bounds = {'param_name': 1}. - To keep an ordinal or metric parameter within a specific     range, you can set bounds = {'param_name': (lower, upper)}.     For example, to constrain a parameter to be between 0 and      1, you can set bounds = {'param_name': (0, 1)}. - In order to limit the selection of a nominal parameter      only to a certain subset of the originally conained values,     you can set bounds = {'param_name': (val1, val2, ...)}.     For example, to limit the selection of a nominal parameter     to the values 'A' and 'B', you can set      bounds = {'param_name': ('A', 'B')}.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>The optimized parameters.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.p_values","title":"<code>p_values()</code>","text":"<p>Get P-value for significance of adding model terms using  anova typ III table for current model.</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.parameter_statistics","title":"<code>parameter_statistics(alpha=0.05, use_t=True)</code>","text":"<p>Calculate the parameter statistics for the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The significance level for the confidence intervals, by  default 0.05.</p> </li> <li> <code>use_t</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, use t-distribution for hypothesis testing and  confidence intervals. If False, use normal distribution,  by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A pandas DataFrame containing the parameter statistics for  the fitted model. The DataFrame includes columns for the  parameter estimates, standard errors, t-values  (or z-values), and p-values.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.predict","title":"<code>predict(xs)</code>","text":"<p>Predict y with given xs. Ensure that all non interactions are  given in xs</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The values for which you want to predict. Make sure that all non interaction parameters are given in xs. If multiple  values are to be predicted, provide a list of values for  each factor level.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the predicted values for the given values of the predictor variables.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.r2_pred","title":"<code>r2_pred()</code>","text":"<p>Calculate the predicted R-squared (R2_pred) for the fitted  model.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The predicted R-squared value for the fitted model.</p> </li> </ul> Notes <p>The predicted R-squared is a measure of how well the model would  predict new observations. It is calculated as:</p> <p>R2_pred = 1 - (Sum of Squared Prediction Errors / Total Sum of Squares)</p> <p>Where the prediction errors are calculated as the residuals  divided by (1 - leverage), where leverage is the diagonal  elements of the projection matrix P = X(X'X)^(-1)X'.</p> References <p>Calculations are made according to: https://support.minitab.com/de-de/minitab/help-and-how-to/statistical-modeling/doe/how-to/factorial/analyze-factorial-design/methods-and-formulas/goodness-of-fit-statistics/#press</p> <p>Further information about projection matrix (influence matrix or hat matrix) can be found in: https://en.wikipedia.org/wiki/Projection_matrix</p>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.recursive_elimination","title":"<code>recursive_elimination(rsquared_max=0.99, ensure_hierarchy=True, **kwds)</code>","text":"<p>Perform a recursive parameter elimination on the fitted model.</p> <p>This function starts with the complete model and recursively  eliminates parameters based on their p-values, until only  significant parameters remain in the model. The function yields  the goodness-of-fit metrics at each step of the elimination process.</p> <p>Parameters:</p> <ul> <li> <code>rsquared_max</code>               (<code>float in (0, 1)</code>, default:                   <code>0.99</code> )           \u2013            <p>If given, the model must have a lower R^2 value than the  given threshold, by default 0.99</p> </li> <li> <code>ensure_hierarchy</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Adds features at the end to ensure model is hierarchical,  by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for <code>ols</code> function of  <code>statsmodels.formula.api</code>.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The goodness-of-fit metrics at each step of the recursive  feature elimination.</p> </li> </ul> <p>Examples:</p> <p>Prepare a LinearModel instance, fit the model, automatically eliminate insignificant terms and plot the relevance of the parameters and the residuals. In the DataFrame df_gof you can  see when which feature was removed and the current  goodness-of-fit values can also be viewed. If you run the  following code in  a Jupyter Notebook, the plots and the html  representation of the model will be displayed.</p> <pre><code>import pandas as pd\nimport daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nlm = dsp.LinearModel(\n        source=df,\n        target='dissolution',\n        features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n        disturbances=['temperature', 'preparation'],\n        alpha=0.05,\n        order=3,\n        encode_categoricals=False\n    )\ndf_gof = pd.concat(list(lm.recursive_elimination()))\ndsp.ParameterRelevanceCharts(lm).plot().stripes().label(info=True)\ndsp.ResidualsCharts(lm).plot().stripes().label(info=True)\nlm\n</code></pre>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.residual_data","title":"<code>residual_data()</code>","text":"<p>Get the residual data from the fitted model.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The residual data containing the residuals, observation index, and predicted values.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('partial_factorial')\ntarget = 'Yield'\nfeatures = [c for c in df.columns if c != target]\nlm = LinearModel(df, target, features)\nprint(lm.residual_data())\n</code></pre> <pre><code>    Observation      Residuals  Prediction\n0             1  9.250000e+00       46.75\n1             2  2.000000e+00       51.00\n2             3 -1.050000e+01       73.50\n3             4 -2.500000e-01       65.25\n4             5 -1.421085e-14       53.00\n5             6  1.025000e+01       44.75\n6             7 -2.500000e-01       67.25\n7             8 -1.050000e+01       71.50\n8             9  3.750000e+00       65.25\n9            10 -1.200000e+01       57.00\n10           11 -1.500000e+00       79.50\n11           12  9.250000e+00       83.75\n12           13 -1.000000e+01       59.00\n13           14 -3.250000e+00       63.25\n14           15  9.250000e+00       85.75\n15           16  4.500000e+00       77.50\n</code></pre>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.summary","title":"<code>summary(anova_typ=None, vif=True, **kwds)</code>","text":"<p>Generate a summary of the fitted model.</p> <p>Parameters:</p> <ul> <li> <code>anova_typ</code>               (<code>Literal['', 'I', 'II', 'III', None]</code>, default:                   <code>None</code> )           \u2013            <p>If not None, add an ANOVA table of provided type to the  summary, by default None.</p> </li> <li> <code>vif</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, variance inflation factors (VIF) are added to the  anova table. Will only be considered if anova_typ is not  None, by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>summary</code>  method of <code>statsmodels.regression.linear_model.RegressionResults</code>  class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Summary</code>           \u2013            <p>A summary object containing information about the fitted  model.</p> </li> </ul>"},{"location":"anova/linear-model/#daspi.anova.model.LinearModel.variance_inflation_factor","title":"<code>variance_inflation_factor(threshold=5)</code>","text":"<p>Calculate the variance inflation factor (VIF) and the  generalized variance inflation factor (GVIF) for each predictor variable in the fitted model.</p> <p>This function takes a regression model as input and returns a  DataFrame containing the VIF, GVIF (= VIF^(1/2*dof)), threshold  for GVIF, collinearity status and calculation kind for each  predictor variable in the model. The VIF and GVIF are measures of multicollinearity, which can help identify variables that are highly correlated with each other.</p> <p>Parameters:</p> <ul> <li> <code>threshold</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The threshold for deciding whether a predictor is collinear. Common values are 5 and 10. By default 5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the VIF, GVIF, threshold, collinearity status and performed method for each predictor variable in the  model.</p> </li> </ul>"},{"location":"doe/","title":"Design of Experiments","text":"<p>The DOE (Design of Experiments) module provides a comprehensive framework for creating experimental designs that help you efficiently explore factor effects and interactions while minimizing the number of experimental runs required.</p>"},{"location":"doe/#overview","title":"Overview","text":"<p>Design of Experiments is a systematic approach to understanding how different factors (variables) affect a response. Instead of changing one factor at a time, DOE allows you to study multiple factors simultaneously, revealing interactions between factors and providing more information with fewer experiments.</p>"},{"location":"doe/#key-features","title":"Key Features","text":"<ul> <li>Multiple Design Types: Support for full factorial, fractional factorial, and specialized 2^k designs</li> <li>Flexible Factor Definition: Handle both numerical and categorical factors with custom levels</li> <li>Advanced Options: Replication, blocking, central points, and randomization</li> <li>Foldover Support: Resolve aliasing in fractional factorial designs</li> <li>Automatic Encoding: Smart conversion between original factor values and coded levels</li> </ul>"},{"location":"doe/#when-to-use-doe","title":"When to Use DOE","text":"<ul> <li>Process Optimization: Find optimal settings for manufacturing processes</li> <li>Product Development: Understand how design parameters affect performance</li> <li>Quality Improvement: Identify factors that affect product quality</li> <li>Screening Studies: Determine which factors are most important</li> <li>Response Surface Methodology: Build predictive models of your system</li> </ul>"},{"location":"doe/#quick-start","title":"Quick Start","text":"<p>Here's a simple example of creating a full factorial design:</p> <pre><code>import daspi as dsp\n\n# Define factors\ntemperature = dsp.Factor('Temperature', (150, 200))\npressure = dsp.Factor('Pressure', (10, 15))\ncatalyst = dsp.Factor('Catalyst', ('A', 'B'), is_categorical=True)\n\n# Create design\nbuilder = dsp.FullFactorialDesignBuilder(\n    temperature, pressure, catalyst,\n    replicates=2,\n    shuffle=True\n)\n\n# Generate the experimental design\ndesign = builder.build_design(corrected=False)\nprint(design)\n</code></pre> <p>This creates a 2\u00d72\u00d72 factorial design with 2 replicates (16 total runs), showing all possible combinations of the three factors.</p>"},{"location":"doe/#documentation-structure","title":"Documentation Structure","text":"<p>The DOE module documentation is organized into the following sections:</p> <ul> <li>Factor: Learn how to define experimental factors with their levels</li> <li>Design Builders: Understand the base functionality and common features</li> <li>Full Factorial Designs: Explore complete factorial designs and 2^k designs  </li> <li>Fractional Factorial Designs: Discover reduced designs with foldover support</li> </ul> <p>For practical guidance and real-world examples, see the DOE User Guide.</p>"},{"location":"doe/design-builders/","title":"Design Builders","text":"<p>The BaseDesignBuilder is an abstract class that provides the foundation for all DOE builders in DaSPi. It defines the common interface and functionality shared by all design types.</p>"},{"location":"doe/design-builders/#common-features","title":"Common Features","text":"<p>All design builders inherit these features from BaseDesignBuilder:</p>"},{"location":"doe/design-builders/#factors","title":"Factors","text":"<ul> <li>Factor Definition: Define experimental factors with their levels</li> <li>Mixed Types: Support for both numerical and categorical factors</li> <li>Validation: Automatic validation of factor names and properties</li> </ul>"},{"location":"doe/design-builders/#replication","title":"Replication","text":"<ul> <li>Multiple Runs: Repeat each factor combination multiple times</li> <li>Error Estimation: Replication helps estimate experimental error</li> <li>Precision: More replicates increase precision of effect estimates</li> </ul>"},{"location":"doe/design-builders/#blocking","title":"Blocking","text":"<p>Blocking helps control for nuisance variables that might affect your response:</p> <ul> <li>Statistical Blocking: Confound blocks with high-order interactions</li> <li>Simple Blocking: Divide runs evenly across blocks</li> <li>Replica Blocking: Each replicate becomes a block</li> </ul>"},{"location":"doe/design-builders/#central-points","title":"Central Points","text":"<ul> <li>Curvature Detection: Central points help detect non-linear effects</li> <li>Pure Error: Provide an estimate of pure experimental error</li> <li>Model Adequacy: Help assess whether a linear model is adequate</li> </ul>"},{"location":"doe/design-builders/#randomization","title":"Randomization","text":"<ul> <li>Run Order: Randomize the order of experimental runs</li> <li>Block-wise: Randomization within each block</li> <li>Bias Reduction: Helps reduce the effect of time trends and other nuisance factors</li> </ul>"},{"location":"doe/design-builders/#design-matrix-output","title":"Design Matrix Output","text":"<p>All builders produce standardized design matrices with these columns:</p> <ul> <li>std_order: Original order before randomization</li> <li>run_order: Randomized execution order</li> <li>central_point: 1 for factor points, 0 for central points</li> <li>replica: Replicate number for each factor combination</li> <li>block: Block assignment</li> <li>Factor columns: One column per factor with levels</li> </ul>"},{"location":"doe/design-builders/#usage-pattern","title":"Usage Pattern","text":"<p>All design builders follow the same basic pattern:</p> <pre><code>import daspi as dsp\n\n# 1. Define factors\nfactor_a = dsp.Factor('A', (1, 2))\nfactor_b = dsp.Factor('B', (10, 20))\n\n# 2. Create builder with options\nbuilder = dsp.SomeDesignBuilder(\n    factor_a, factor_b,\n    replicates=2,\n    central_points=3,\n    blocks='highest',\n    shuffle=True\n)\n\n# 3. Generate design matrix\ndesign = builder.build_design(corrected=False)\n\n# 4. Use the design for your experiments\nprint(design)\n</code></pre>"},{"location":"doe/design-builders/#coded-vs-original-values","title":"Coded vs Original Values","text":"<p>Builders can return designs in two formats:</p> <pre><code># Original factor values (for experimental use)\ndesign_original = builder.build_design(corrected=False)\n\n# Coded values (for statistical analysis)\ndesign_coded = builder.build_design(corrected=True)\n</code></pre> <p>Coded values use standardized scales (typically -1, 0, +1) that make statistical analysis easier and more interpretable.</p>"},{"location":"doe/design-builders/#validation-and-error-checking","title":"Validation and Error Checking","text":"<p>All builders perform extensive validation:</p> <ul> <li>Factor names must be unique</li> <li>Factor names cannot conflict with standard column names</li> <li>Positive number of replicates</li> <li>Valid block specifications</li> <li>Proper generator syntax (for fractional factorials)</li> </ul>"},{"location":"doe/design-builders/#api-reference","title":"API Reference","text":""},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder","title":"<code>daspi.doe.BaseDesignBuilder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for DOE builders.</p> <p>Parameters:</p> <ul> <li> <code>factors</code>               (<code>Iterable[Factor]</code>, default:                   <code>()</code> )           \u2013            <p>Factors defining the design space.</p> </li> <li> <code>replicates</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of replicates. Must be positive, by default 1.</p> </li> <li> <code>blocks</code>               (<code>int | str | List[str] | Literal['highest', 'replica']</code>, default:                   <code>1</code> )           \u2013            <p>Block assignment: integer for evenly spaced blocks,  str | List[str] for user-defined block generator, or Literal  'highest'/'replica'. Must be positive or 'highest'/'replica', by  default 1.</p> </li> <li> <code>central_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of central points to be added to each block. These are used to test linear effects. Must be non-negative. If set to 0, no central points are added. by default 0.</p> </li> <li> <code>shuffle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to shuffle the design, by default True.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If any of the parameters are invalid: - At least one factor is required. - Factor names must not conflict with standard columns in the    design matrix. - All factors must be instances of Factor class. - Number of replicates must be positive. - Number of central points must be non-negative. - At least one factor must provide a central point, or set    central_points to 0. - Number of blocks must be positive. - Factor names must be unique.</p> </li> </ul>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.blocks","title":"<code>blocks</code>  <code>property</code> <code>writable</code>","text":"<p>Block assignment: integer for evenly spaced blocks,  str | List[str] for user-defined block generator, or Literal  'highest'/'replica'.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.central_points","title":"<code>central_points</code>  <code>property</code> <code>writable</code>","text":"<p>Number of central points (read-only).</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>List of columns in the design matrix.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.factor_names","title":"<code>factor_names</code>  <code>property</code>","text":"<p>List of factor names (read-only).</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.factors","title":"<code>factors</code>  <code>property</code> <code>writable</code>","text":"<p>Tuple of factors defining the design space.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.fold","title":"<code>fold</code>  <code>instance-attribute</code>","text":"<p>Whether to add a foldover to the design.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.is_2k","title":"<code>is_2k</code>  <code>property</code>","text":"<p>Check if the design is a 2^k design.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.level_counts","title":"<code>level_counts</code>  <code>property</code>","text":"<p>Tuple of level counts for each factor (read-only).</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.replicates","title":"<code>replicates</code>  <code>property</code> <code>writable</code>","text":"<p>Number of replicates (read-only).</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.shuffle","title":"<code>shuffle = shuffle</code>  <code>instance-attribute</code>","text":"<p>Whether to shuffle the design.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.standard_columns","title":"<code>standard_columns</code>  <code>property</code>","text":"<p>List of standard columns in the design matrix.</p>"},{"location":"doe/design-builders/#daspi.doe.BaseDesignBuilder.build_design","title":"<code>build_design(corrected=True)</code>","text":"<p>Generate the design matrix with original factor values.</p> <p>This method builds the design matrix by generating the corrected (integer-coded) design, replicating it according to the replicates parameter, shuffling it if specified, and  adding central points if specified. Block assignment is controlled by the <code>blocks</code> option at initialization:</p> <ul> <li>If <code>blocks</code> is an int &gt; 1: blocks are assigned evenly    (not statistically confounded).</li> <li>If <code>blocks</code> is an str or List[str]: blocks are assigned by    confounding with the specified interaction    (statistically correct).</li> <li>If <code>blocks</code> is 'highest': blocks are assigned by confounding   with the highest-order interaction (all centralized factors).</li> <li>If <code>blocks</code> is 'replica': blocks are assigned based on the   replicate number.</li> <li>If <code>blocks</code> == 1: all runs are assigned to block 1.</li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Design matrix with original factor values if corrected is False, otherwise with integer codes representing factor levels.</p> </li> </ul> Notes <p>Statistically correct block assignment is performed by  confounding the block effect with a specified interaction  (block generator). For each run, the value of the block  generator (the product of the coded levels of the specified  factors) is computed, and unique values are mapped to block  numbers. If <code>blocks</code> is 'highest', the highest-order interaction  (all factors) is used. This ensures that block effects are  orthogonal to main effects and lower-order interactions when  using a confounding generator, as recommended in DOE literature  (see Montgomery, 2017). If <code>blocks</code> is a str or List[str], the specified interaction is used. If <code>blocks</code> is 'replica', blocks are assigned by replicate. If <code>blocks</code> is an int, blocks are assigned evenly (not statistically confounded).</p>"},{"location":"doe/factor/","title":"Factor","text":"<p>The Factor class represents a single factor (variable) in a design of experiments, with support for both numerical and categorical levels.</p>"},{"location":"doe/factor/#overview","title":"Overview","text":"<p>A Factor defines one dimension of your experimental space. It can represent:</p> <ul> <li>Numerical factors: Temperature, pressure, concentration, etc.</li> <li>Categorical factors: Machine type, operator, material grade, etc.</li> </ul> <p>The Factor class automatically handles:</p> <ul> <li>Level ordering (numerical factors are sorted)</li> <li>Central point calculation (for numerical factors)</li> <li>Categorical detection (when string levels are present)</li> <li>Code generation for experimental designs</li> </ul>"},{"location":"doe/factor/#basic-usage","title":"Basic Usage","text":""},{"location":"doe/factor/#numerical-factors","title":"Numerical Factors","text":"<pre><code>import daspi as dsp\n\n# Temperature factor with two levels\ntemperature = dsp.Factor('Temperature', (150, 200))\n\n# Pressure factor with three levels\npressure = dsp.Factor('Pressure', (10, 12, 15))\n\nprint(f\"Temperature levels: {temperature.levels}\")\nprint(f\"Temperature central point: {temperature.central_point}\")\nprint(f\"Is categorical: {temperature.is_categorical}\")\n</code></pre>"},{"location":"doe/factor/#categorical-factors","title":"Categorical Factors","text":"<pre><code># Catalyst type (categorical)\ncatalyst = dsp.Factor('Catalyst', ('A', 'B', 'C'), is_categorical=True)\n\n# Machine operator (automatically detected as categorical)\noperator = dsp.Factor('Operator', ('John', 'Jane', 'Bob'))\n\nprint(f\"Catalyst levels: {catalyst.levels}\")\nprint(f\"Has central point: {catalyst.central_point is not None}\")\n</code></pre>"},{"location":"doe/factor/#key-properties","title":"Key Properties","text":"<ul> <li>name: The factor name (used in design matrices)</li> <li>levels: Tuple of factor levels (sorted for numerical factors)</li> <li>n_levels: Number of levels in the factor</li> <li>is_categorical: Whether the factor is categorical</li> <li>central_point: Central value for numerical factors (None for categorical)</li> <li>corrected_levels: Encoded levels used internally in designs</li> </ul>"},{"location":"doe/factor/#advanced-features","title":"Advanced Features","text":""},{"location":"doe/factor/#automatic-categorical-detection","title":"Automatic Categorical Detection","text":"<p>When string levels are detected, the factor is automatically treated as categorical:</p> <pre><code># This triggers a warning and sets is_categorical=True\nmaterial = dsp.Factor('Material', ('Steel', 'Aluminum'))\n\n# To avoid the warning, explicitly set is_categorical\nmaterial = dsp.Factor('Material', ('Steel', 'Aluminum'), is_categorical=True)\n</code></pre>"},{"location":"doe/factor/#coded-levels","title":"Coded Levels","text":"<p>For design generation, factors use coded levels internally:</p> <pre><code>factor = dsp.Factor('pH', (6.5, 7.0, 7.5))\n\nprint(f\"Original levels: {factor.levels}\")\nprint(f\"Coded levels: {factor.corrected_levels}\")\nprint(f\"Level mapping: {factor.corrected_level_map}\")\n</code></pre> <p>This produces coded levels like <code>(-1, 0, 1)</code> for internal calculations while maintaining the mapping to original values.</p>"},{"location":"doe/factor/#api-reference","title":"API Reference","text":""},{"location":"doe/factor/#daspi.doe.Factor","title":"<code>daspi.doe.Factor</code>","text":"<p>Represents a factor in a design of experiments.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the factor.</p> </li> <li> <code>levels</code>               (<code>Tuple[LevelType, ...]</code>)           \u2013            <p>Levels of the factor (numeric or categorical).</p> </li> <li> <code>is_categorical</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the factor is categorical. This is automatically  inferred from the levels if not specified. Categorical factors are assumed to be unordered and have no central point.</p> </li> </ul>"},{"location":"doe/factor/#daspi.doe.Factor.central_point","title":"<code>central_point</code>  <code>property</code>","text":"<p>Central point of the factor (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.corrected_central_points","title":"<code>corrected_central_points</code>  <code>property</code>","text":"<p>Corrected central points as tuple, used for float-coded  designs (read-only).</p> <p>If the factor has a central point, it returns a tuple with the central coded value, otherwise it returns the corrected levels.</p> Notes <p>If this property is accessed, it will also update the  <code>corrected_level_map</code>.</p>"},{"location":"doe/factor/#daspi.doe.Factor.corrected_level_map","title":"<code>corrected_level_map</code>  <code>property</code>","text":"<p>Mapping from float or int codes to their corresponding factor  levels (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.corrected_levels","title":"<code>corrected_levels</code>  <code>property</code>","text":"<p>Corrected levels for float-coded designs (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.is_categorical","title":"<code>is_categorical</code>  <code>property</code>","text":"<p>Return whether the factor is categorical (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.is_centralized","title":"<code>is_centralized</code>  <code>property</code>","text":"<p>Check if the corrected levels are centered around 0  (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.levels","title":"<code>levels</code>  <code>property</code>","text":"<p>Levels of the factor (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.n_levels","title":"<code>n_levels</code>  <code>property</code>","text":"<p>Return number of levels (read-only).</p>"},{"location":"doe/factor/#daspi.doe.Factor.name","title":"<code>name</code>  <code>property</code>","text":"<p>Name of the factor (read-only).</p>"},{"location":"doe/fractional-factorial/","title":"Fractional Factorial Designs","text":"<p>Fractional factorial designs run only a carefully selected subset of the full factorial design, reducing experimental cost while still providing valuable information about main effects and important interactions.</p>"},{"location":"doe/fractional-factorial/#when-to-use-fractional-factorial-designs","title":"When to Use Fractional Factorial Designs","text":"<ul> <li>Many factors to screen: 5 or more factors where full factorial is too expensive</li> <li>Limited resources: When experimental runs are costly or time-consuming</li> <li>Screening studies: To identify the most important factors before detailed study</li> <li>Sequential experimentation: As a first step before running a full factorial on important factors</li> </ul>"},{"location":"doe/fractional-factorial/#key-concepts","title":"Key Concepts","text":""},{"location":"doe/fractional-factorial/#aliasing-confounding","title":"Aliasing (Confounding)","text":"<p>In fractional factorial designs, some effects are aliased (confounded) with others. This means you cannot distinguish between aliased effects from the experimental data alone.</p>"},{"location":"doe/fractional-factorial/#resolution","title":"Resolution","text":"<p>Resolution describes the quality of a fractional factorial design:</p> <ul> <li>Resolution III: Main effects are not aliased with each other (but may be aliased with 2-factor interactions)</li> <li>Resolution IV: Main effects are not aliased with each other or 2-factor interactions</li> <li>Resolution V: Main effects and 2-factor interactions are not aliased with each other</li> </ul>"},{"location":"doe/fractional-factorial/#generators","title":"Generators","text":"<p>Generators define how the fractional design is constructed. For example, in a 2^(4-1) design with generator <code>D=ABC</code>, factor D is set equal to the product of factors A, B, and C.</p>"},{"location":"doe/fractional-factorial/#basic-usage","title":"Basic Usage","text":""},{"location":"doe/fractional-factorial/#simple-fractional-factorial","title":"Simple Fractional Factorial","text":"<pre><code>import daspi as dsp\n\n# 2^(3-1) design: 4 runs instead of 8\nA = dsp.Factor('A', (-1, 1))\nB = dsp.Factor('B', (-1, 1))\nC = dsp.Factor('C', (-1, 1))\n\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C,\n    generators=['C=AB']  # C is determined by A\u00d7B\n)\n\ndesign = builder.build_design(corrected=False)\nprint(design)\n</code></pre>"},{"location":"doe/fractional-factorial/#using-default-generators","title":"Using Default Generators","text":"<p>For common designs, you can use standard generators:</p> <pre><code># Get standard generators for 2^(5-2) design\ngenerators = dsp.get_default_generators(k=5, p=2)\nprint(generators)  # ['D=AB', 'E=AC']\n\n# Create the design\nA = dsp.Factor('A', (-1, 1))\nB = dsp.Factor('B', (-1, 1))\nC = dsp.Factor('C', (-1, 1))\nD = dsp.Factor('D', (-1, 1))\nE = dsp.Factor('E', (-1, 1))\n\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C, D, E,\n    generators=generators\n)\n\ndesign = builder.build_design(corrected=False)\n</code></pre>"},{"location":"doe/fractional-factorial/#foldover-designs","title":"Foldover Designs","text":"<p>Foldover adds a second fraction where the signs of one or more factors are reversed, helping to resolve aliasing between main effects and 2-factor interactions.</p>"},{"location":"doe/fractional-factorial/#complete-foldover","title":"Complete Foldover","text":"<pre><code># Foldover all factors\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C,\n    generators=['C=AB'],\n    fold=True  # Reverses all factors\n)\n\ndesign = builder.build_design(corrected=False)\n# This creates 8 runs total (4 original + 4 foldover)\n</code></pre>"},{"location":"doe/fractional-factorial/#partial-foldover","title":"Partial Foldover","text":"<pre><code># Foldover only factor A\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C,\n    generators=['C=AB'],\n    fold='A'  # Reverses only factor A\n)\n\ndesign = builder.build_design(corrected=False)\n</code></pre>"},{"location":"doe/fractional-factorial/#common-fractional-factorial-designs","title":"Common Fractional Factorial Designs","text":"Design Basic Factors Generated Factors Generators Resolution 2^(3-1) A, B C C=AB III 2^(4-1) A, B, C D D=ABC IV 2^(5-2) A, B, C D, E D=AB, E=AC III 2^(6-3) A, B, C D, E, F D=AB, E=AC, F=BC III 2^(7-3) A, B, C, D E, F, G E=ABC, F=ABD, G=BCD IV"},{"location":"doe/fractional-factorial/#design-strategy","title":"Design Strategy","text":"<ol> <li>Start small: Use a fractional factorial to screen many factors</li> <li>Analyze results: Identify the most important factors</li> <li>Follow up: Run a full factorial or higher-resolution fractional factorial on important factors</li> <li>Use foldover: If main effects are confounded with 2-factor interactions</li> </ol>"},{"location":"doe/fractional-factorial/#advanced-features","title":"Advanced Features","text":""},{"location":"doe/fractional-factorial/#with-blocking-and-replication","title":"With Blocking and Replication","text":"<pre><code>builder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C, D, E,\n    generators=['D=AB', 'E=AC'],\n    replicates=2,\n    central_points=3,\n    blocks=2,  # Split into 2 blocks\n    fold=True,\n    shuffle=True\n)\n\ndesign = builder.build_design(corrected=False)\n</code></pre>"},{"location":"doe/fractional-factorial/#api-reference","title":"API Reference","text":""},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder","title":"<code>daspi.doe.FractionalFactorialDesignBuilder</code>","text":"<p>               Bases: <code>BaseDesignBuilder</code></p> <p>Builder for 2-level fractional factorial designs with optional  foldover.</p> <p>This class supports the construction of regular 2-level fractional  factorial designs using generator strings (e.g., 'C=AB'), and can  optionally add a foldover to the design.</p> <p>Default generators for common designs (see also  get_default_generators):</p> Design Basic Factors Generators Example Generator Strings 2^(3-1) A, B C = AB ['C=AB'] 2^(4-1) A, B, C D = ABC ['D=ABC'] 2^(5-2) A, B, C D = AB, E = AC ['D=AB', 'E=AC'] 2^(6-3) A, B, C D = AB, E = AC, F = BC ['D=AB', 'E=AC', 'F=BC'] 2^(7-3) A, B, C, D E = ABC, F = ABD, G = BCD ['E=ABC', 'F=ABD', 'G=BCD'] <p>Parameters:</p> <ul> <li> <code>factors</code>               (<code>Iterable[Factor]</code>, default:                   <code>()</code> )           \u2013            <p>Factors defining the design space. All factors must have exactly  2 levels.</p> </li> <li> <code>generators</code>               (<code>List[str]</code>)           \u2013            <p>List of generator strings that define how dependent factors are  constructed from basic factors. For example, if you have 4  factors A, B, C, and D, you can set generators to  ['C=AB', 'D=BC']. This means that factor C is defined as the  product of factors A and B (C = A * B), and factor D as the  product of B and C (D = B * C). The order of the generator  strings should match the order of the dependent factors in the  factors list. For common designs, see the table above or use  get_default_generators(k, p).</p> </li> <li> <code>fold</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Whether to add a foldover. If True, a foldover will be added for  all factors. If a string is provided, it should be the name of  the factor to fold over. Default is False (no foldover).</p> </li> <li> <code>replicates</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of replicates. Must be positive, by default 1.</p> </li> <li> <code>central_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of central points to be added to each block. These are used to test linear effects. Must be non-negative. If set to 0, no central points are added. by default 0.</p> </li> <li> <code>blocks</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of blocks. Must be positive, by default 1.</p> </li> <li> <code>shuffle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to shuffle the design, by default True.</p> </li> </ul> <p>Examples:</p> <p>Create a 2^(3-1) fractional factorial design (3 factors, 1 generator):</p> <pre><code>from daspi.doe.build import Factor, FractionalFactorialDesignBuilder\n\nA = Factor('A', (-1, 1))\nB = Factor('B', (-1, 1))\nC = Factor('C', (-1, 1))\nbuilder = FractionalFactorialDesignBuilder(A, B, C, generators=['C=AB'])\ndf = builder.build_design(corrected=False)\nprint(df)\n</code></pre> <pre><code>   std_order  run_order  central_point  replica  block  A  B  C\n0          0          0              1        1      1 -1 -1  1\n1          1          1              1        1      1 -1  1 -1\n2          2          2              1        1      1  1 -1 -1\n3          3          3              1        1      1  1  1  1\n</code></pre> <p>Create the same design with foldover (doubles the number of runs, reverses A):</p> <pre><code>builder = FractionalFactorialDesignBuilder(\n    A, B, C, generators=['C=AB'], fold=True)\ndf = builder.build_design(corrected=False)\nprint(df)\n</code></pre> <pre><code>   std_order  run_order  central_point  replica  block  A  B  C\n0          0          0              1        1      1 -1 -1  1\n1          1          1              1        1      1 -1  1 -1\n2          2          2              1        1      1  1 -1 -1\n3          3          3              1        1      1  1  1  1\n4          4          4              1        1      1  1 -1 -1\n5          5          5              1        1      1  1  1  1\n6          6          6              1        1      1 -1 -1  1\n7          7          7              1        1      1 -1  1 -1\n</code></pre> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If any of the parameters are invalid: - All factors must have exactly 2 levels. - Number of replicates must be positive. - Number of central points must be non-negative. - Number of blocks must be positive. - Generators must be provided as a list of strings. - Generators must match the number of dependent factors. - Each generator string must be in the format 'C=AB' where C is    the dependent factor and AB are the independent factors. - Each dependent factor must be defined in the generators. - The first basic factor must be reversed in sign for foldover.</p> </li> </ul> Notes <p>In fractional factorial designs, only a subset of all possible  factor combinations is run, which leads to confounding (aliasing)  between main effects and interactions. Foldover is a technique to  resolve some of these confoundings by running an additional set of  experiments where the sign of one or more basic factors is reversed.  This effectively doubles the number of runs and allows for the  separation of certain effects that were aliased in the original  fraction. Foldover is especially useful for identifying main effects  that may be confounded with two-factor interactions in the initial  design. Key points:     - Foldover is meaningful only for regular 2-level fractional       factorial designs, not for full factorials, non-regular       designs, or designs with more than two levels per factor.     - For full factorial designs, foldover is unnecessary because       there is no aliasing to resolve.     - For non-regular or mixed-level designs, the concept of       foldover does not apply in the classical sense.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.blocks","title":"<code>blocks</code>  <code>property</code> <code>writable</code>","text":"<p>Block assignment: integer for evenly spaced blocks,  str | List[str] for user-defined block generator, or Literal  'highest'/'replica'.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.central_points","title":"<code>central_points</code>  <code>property</code> <code>writable</code>","text":"<p>Number of central points (read-only).</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>List of columns in the design matrix.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.factor_names","title":"<code>factor_names</code>  <code>property</code>","text":"<p>List of factor names (read-only).</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.factors","title":"<code>factors</code>  <code>property</code> <code>writable</code>","text":"<p>Tuple of factors defining the design space.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.is_2k","title":"<code>is_2k</code>  <code>property</code>","text":"<p>Check if the design is a 2^k design.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.level_counts","title":"<code>level_counts</code>  <code>property</code>","text":"<p>Tuple of level counts for each factor (read-only).</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.replicates","title":"<code>replicates</code>  <code>property</code> <code>writable</code>","text":"<p>Number of replicates (read-only).</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.shuffle","title":"<code>shuffle = shuffle</code>  <code>instance-attribute</code>","text":"<p>Whether to shuffle the design.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.standard_columns","title":"<code>standard_columns</code>  <code>property</code>","text":"<p>List of standard columns in the design matrix.</p>"},{"location":"doe/fractional-factorial/#daspi.doe.FractionalFactorialDesignBuilder.build_design","title":"<code>build_design(corrected=True)</code>","text":"<p>Generate the design matrix with original factor values.</p> <p>This method builds the design matrix by generating the corrected (integer-coded) design, replicating it according to the replicates parameter, shuffling it if specified, and  adding central points if specified. Block assignment is controlled by the <code>blocks</code> option at initialization:</p> <ul> <li>If <code>blocks</code> is an int &gt; 1: blocks are assigned evenly    (not statistically confounded).</li> <li>If <code>blocks</code> is an str or List[str]: blocks are assigned by    confounding with the specified interaction    (statistically correct).</li> <li>If <code>blocks</code> is 'highest': blocks are assigned by confounding   with the highest-order interaction (all centralized factors).</li> <li>If <code>blocks</code> is 'replica': blocks are assigned based on the   replicate number.</li> <li>If <code>blocks</code> == 1: all runs are assigned to block 1.</li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Design matrix with original factor values if corrected is False, otherwise with integer codes representing factor levels.</p> </li> </ul> Notes <p>Statistically correct block assignment is performed by  confounding the block effect with a specified interaction  (block generator). For each run, the value of the block  generator (the product of the coded levels of the specified  factors) is computed, and unique values are mapped to block  numbers. If <code>blocks</code> is 'highest', the highest-order interaction  (all factors) is used. This ensures that block effects are  orthogonal to main effects and lower-order interactions when  using a confounding generator, as recommended in DOE literature  (see Montgomery, 2017). If <code>blocks</code> is a str or List[str], the specified interaction is used. If <code>blocks</code> is 'replica', blocks are assigned by replicate. If <code>blocks</code> is an int, blocks are assigned evenly (not statistically confounded).</p>"},{"location":"doe/fractional-factorial/#daspi.doe.get_default_generators","title":"<code>daspi.doe.get_default_generators(k, p)</code>","text":"<p>Return standard generators for regular 2-level fractional factorial designs.</p> <p>Parameters:</p> <ul> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>Total number of factors.</p> </li> <li> <code>p</code>               (<code>int</code>)           \u2013            <p>Number of generators (fractionality, so design is 2^(k-p)).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of generator strings, e.g. ['C=AB', 'D=AC'].</p> </li> </ul> Notes <p>These are standard choices for high-resolution designs, suitable for  most practical cases. For more, see Montgomery (2017), Box, Hunter  &amp; Hunter, or standard DOE tables.</p>"},{"location":"doe/full-factorial/","title":"Full Factorial Designs","text":"<p>Full factorial designs include every possible combination of factor levels, providing complete information about main effects and all interactions between factors.</p>"},{"location":"doe/full-factorial/#when-to-use-full-factorial-designs","title":"When to Use Full Factorial Designs","text":"<ul> <li>Small number of factors: Typically 2-4 factors with 2-3 levels each</li> <li>Complete understanding needed: When you need to understand all interactions</li> <li>Sufficient resources: When you can afford the number of experimental runs</li> <li>Baseline studies: When establishing a foundation for future experiments</li> </ul>"},{"location":"doe/full-factorial/#available-builders","title":"Available Builders","text":""},{"location":"doe/full-factorial/#fullfactorialdesignbuilder","title":"FullFactorialDesignBuilder","text":"<p>The general-purpose builder for full factorial designs with factors having any number of levels.</p> <pre><code>import daspi as dsp\n\n# Mixed level design: 2\u00d73\u00d72 = 12 runs\ntemperature = dsp.Factor('Temperature', (150, 200))\npressure = dsp.Factor('Pressure', (10, 12, 15))  # 3 levels\ncatalyst = dsp.Factor('Catalyst', ('A', 'B'), is_categorical=True)\n\nbuilder = dsp.FullFactorialDesignBuilder(\n    temperature, pressure, catalyst,\n    replicates=2,\n    central_points=3,\n    blocks='highest',\n    shuffle=True\n)\n\ndesign = builder.build_design(corrected=False)\n</code></pre>"},{"location":"doe/full-factorial/#fullfactorial2kdesignbuilder","title":"FullFactorial2kDesignBuilder","text":"<p>Specialized builder for 2-level factorial designs (2^k designs). These are the most common experimental designs.</p> <pre><code>import daspi as dsp\n\n# 2^3 design: 2\u00d72\u00d72 = 8 runs\ntemperature = dsp.Factor('Temperature', (150, 200))\npressure = dsp.Factor('Pressure', (10, 15))\ntime = dsp.Factor('Time', (30, 60))\n\nbuilder = dsp.FullFactorial2kDesignBuilder(\n    temperature, pressure, time,\n    replicates=2,\n    central_points=4,\n    shuffle=True\n)\n\ndesign = builder.build_design(corrected=False)\n</code></pre>"},{"location":"doe/full-factorial/#design-features","title":"Design Features","text":""},{"location":"doe/full-factorial/#replication","title":"Replication","text":"<p>Replication helps estimate experimental error and increases precision:</p> <pre><code># Each factor combination run 3 times\nbuilder = dsp.FullFactorialDesignBuilder(\n    factor_a, factor_b,\n    replicates=3\n)\n</code></pre>"},{"location":"doe/full-factorial/#central-points","title":"Central Points","text":"<p>Central points help detect curvature in the response and estimate pure error:</p> <pre><code># Add 5 center point runs to each block\nbuilder = dsp.FullFactorial2kDesignBuilder(\n    factor_a, factor_b,\n    central_points=5\n)\n</code></pre>"},{"location":"doe/full-factorial/#blocking","title":"Blocking","text":"<p>Blocking helps control for nuisance variables:</p> <pre><code># Block by highest-order interaction (recommended)\nbuilder = dsp.FullFactorialDesignBuilder(\n    factor_a, factor_b, factor_c,\n    blocks='highest'\n)\n\n# Block by specific interaction\nbuilder = dsp.FullFactorialDesignBuilder(\n    factor_a, factor_b, factor_c,\n    blocks=['A', 'B']  # Block by A\u00d7B interaction\n)\n\n# Simple blocking (not confounded)\nbuilder = dsp.FullFactorialDesignBuilder(\n    factor_a, factor_b, factor_c,\n    blocks=4  # Split into 4 blocks evenly\n)\n</code></pre>"},{"location":"doe/full-factorial/#design-size-considerations","title":"Design Size Considerations","text":"Factors Levels Runs Suitable For 2 2\u00d72 4 Quick screening 3 2\u00d72\u00d72 8 Small studies 4 2\u00d72\u00d72\u00d72 16 Standard studies 5 2\u00d72\u00d72\u00d72\u00d72 32 Large studies 3 3\u00d73\u00d73 27 Response surfaces"},{"location":"doe/full-factorial/#api-reference","title":"API Reference","text":""},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder","title":"<code>daspi.doe.FullFactorialDesignBuilder</code>","text":"<p>               Bases: <code>BaseDesignBuilder</code></p> <p>Builder for full factorial designs.</p> <p>Parameters:</p> <ul> <li> <code>factors</code>               (<code>Iterable[Factor]</code>, default:                   <code>()</code> )           \u2013            <p>Factors defining the design space.</p> </li> <li> <code>replicates</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of replicates. Must be positive, by default 1.</p> </li> <li> <code>blocks</code>               (<code>int | str | List[str] | Literal['highest', 'replica']</code>, default:                   <code>1</code> )           \u2013            <p>Number of blocks or block assignment strategy. For more information, see the docstring of the <code>build_design</code> method. Defaults to 1.</p> </li> <li> <code>central_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of central points to be added to each block. These are used to test linear effects. Must be non-negative. If set to 0, no central points are added. by default 0.</p> </li> <li> <code>shuffle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to shuffle the design, by default True.</p> </li> </ul> <p>Examples:</p> <p>Create a full factorial design with two factors, each with two  levels:</p> <pre><code>import daspi as dsp\n\nfactor_a = dsp.Factor('A', (1, 2))\nfactor_b = dsp.Factor('B', (10, 20))\nbuilder = dsp.FullFactorialDesignBuilder(factor_a, factor_b)\ndf = builder.build_design(corrected=False)\nprint(df)\n</code></pre> <pre><code>   std_order  run_order  central_point  replica  block  A   B\n0          0          0              1        1      1  1  10\n1          1          1              1        1      1  1  20\n2          2          2              1        1      1  2  10\n3          3          3              1        1      1  2  20\n</code></pre> <p>Create a full factorial corrected design with two factors, each with  two levels, and 3 replicates and split into blocks using the highest  interaction:</p> <pre><code>import daspi as dsp\nimport numpy as np\n\nnp.random.seed(42)  # optional for reproducibility\n\nfactor_a = dsp.Factor('A', (1, 2))\nfactor_b = dsp.Factor('B', (10, 20))\nbuilder = dsp.FullFactorialDesignBuilder(\n    factor_a, factor_b, replicates=3, blocks='highest')\ndf = builder.build_design(corrected=True)\nprint(df)\n</code></pre> <pre><code>    std_order  run_order  central_point  replica  block    A    B\n0           0          0              1        1      1 -1.0 -1.0\n1           1          1              1        1      1  1.0  1.0\n2           5          2              1        2      1  1.0  1.0\n3           2          3              1        2      1 -1.0 -1.0\n4           4          4              1        3      1 -1.0 -1.0\n5           3          5              1        3      1  1.0  1.0\n6           9          6              1        1      2  1.0 -1.0\n7           6          7              1        1      2 -1.0  1.0\n8           7          8              1        2      2  1.0 -1.0\n9           8          9              1        2      2 -1.0  1.0\n10         11         10              1        3      2  1.0 -1.0\n11         10         11              1        3      2 -1.0  1.0\n</code></pre> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If any of the parameters are invalid: - At least one factor is required. - All factors must be instances of Factor class. - Number of replicates must be positive. - Number of blocks must be positive.</p> </li> </ul>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.blocks","title":"<code>blocks</code>  <code>property</code> <code>writable</code>","text":"<p>Block assignment: integer for evenly spaced blocks,  str | List[str] for user-defined block generator, or Literal  'highest'/'replica'.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.central_points","title":"<code>central_points</code>  <code>property</code> <code>writable</code>","text":"<p>Number of central points (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>List of columns in the design matrix.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.factor_names","title":"<code>factor_names</code>  <code>property</code>","text":"<p>List of factor names (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.factors","title":"<code>factors</code>  <code>property</code> <code>writable</code>","text":"<p>Tuple of factors defining the design space.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.fold","title":"<code>fold</code>  <code>instance-attribute</code>","text":"<p>Whether to add a foldover to the design.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.is_2k","title":"<code>is_2k</code>  <code>property</code>","text":"<p>Check if the design is a 2^k design.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.level_counts","title":"<code>level_counts</code>  <code>property</code>","text":"<p>Tuple of level counts for each factor (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.replicates","title":"<code>replicates</code>  <code>property</code> <code>writable</code>","text":"<p>Number of replicates (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.shuffle","title":"<code>shuffle = shuffle</code>  <code>instance-attribute</code>","text":"<p>Whether to shuffle the design.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.standard_columns","title":"<code>standard_columns</code>  <code>property</code>","text":"<p>List of standard columns in the design matrix.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorialDesignBuilder.build_design","title":"<code>build_design(corrected=True)</code>","text":"<p>Generate the design matrix with original factor values.</p> <p>This method builds the design matrix by generating the corrected (integer-coded) design, replicating it according to the replicates parameter, shuffling it if specified, and  adding central points if specified. Block assignment is controlled by the <code>blocks</code> option at initialization:</p> <ul> <li>If <code>blocks</code> is an int &gt; 1: blocks are assigned evenly    (not statistically confounded).</li> <li>If <code>blocks</code> is an str or List[str]: blocks are assigned by    confounding with the specified interaction    (statistically correct).</li> <li>If <code>blocks</code> is 'highest': blocks are assigned by confounding   with the highest-order interaction (all centralized factors).</li> <li>If <code>blocks</code> is 'replica': blocks are assigned based on the   replicate number.</li> <li>If <code>blocks</code> == 1: all runs are assigned to block 1.</li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Design matrix with original factor values if corrected is False, otherwise with integer codes representing factor levels.</p> </li> </ul> Notes <p>Statistically correct block assignment is performed by  confounding the block effect with a specified interaction  (block generator). For each run, the value of the block  generator (the product of the coded levels of the specified  factors) is computed, and unique values are mapped to block  numbers. If <code>blocks</code> is 'highest', the highest-order interaction  (all factors) is used. This ensures that block effects are  orthogonal to main effects and lower-order interactions when  using a confounding generator, as recommended in DOE literature  (see Montgomery, 2017). If <code>blocks</code> is a str or List[str], the specified interaction is used. If <code>blocks</code> is 'replica', blocks are assigned by replicate. If <code>blocks</code> is an int, blocks are assigned evenly (not statistically confounded).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder","title":"<code>daspi.doe.FullFactorial2kDesignBuilder</code>","text":"<p>               Bases: <code>FullFactorialDesignBuilder</code></p> <p>Builder for full factorial designs with 2-level factors. This class is a specialization of FullFactorialDesignBuilder for the case where all factors have exactly 2 levels.</p> <p>This design also supports replicates, central points, and blocks, and can be used to explore interactions between factors.</p> <p>Parameters:</p> <ul> <li> <code>factors</code>               (<code>Iterable[Factor]</code>, default:                   <code>()</code> )           \u2013            <p>Factors defining the design space. All factors must have exactly 2 levels.</p> </li> <li> <code>replicates</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of replicates. Must be positive, by default 1.</p> </li> <li> <code>blocks</code>               (<code>int | str | List[str] | Literal['highest', 'replica']</code>, default:                   <code>1</code> )           \u2013            <p>Block assignment: integer for evenly spaced blocks,  str | List[str] for user-defined block generator, or Literal  'highest'/'replica'. Must be positive or 'highest'/'replica', by  default 1.</p> </li> <li> <code>central_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of central points to be added to each block. These are used to test linear effects. Must be non-negative. If set to 0, no central points are added. by default 0.</p> </li> <li> <code>shuffle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to shuffle the design, by default True.</p> </li> </ul> <p>Examples:</p> <p>Create a full factorial design with two factors, each with two  levels: <pre><code>import daspi as dsp\n\nfactor_a = dsp.Factor('A', (0, 1))\nfactor_b = dsp.Factor('B', (0, 1))\nbuilder = dsp.FullFactorial2kDesignBuilder(\n    factor_a, factor_b, shuffle=False)\ndf = builder.build_design(corrected=False)\nprint(df)\n</code></pre></p> <pre><code>   std_order  run_order  central_point  replica  block  A  B\n0          0          0              1        1      1  0  0\n1          1          1              1        1      1  0  1\n2          2          2              1        1      1  1  0\n3          3          3              1        1      1  1  1\n</code></pre> <p>Create a randomized full factorial corrected design with two factors, each with two levels, and 3 replicates, blocks by the highest interaction and 2 central points per block to test  linear effects:</p> <pre><code>import daspi as dsp\nimport numpy as np\n\nnp.random.seed(42) # optional for reproducibility\n\nfactor_a = dsp.Factor('A', (0, 1))\nfactor_b = dsp.Factor('B', (0, 1))\nbuilder = dsp.FullFactorial2kDesignBuilder(\n    factor_a, factor_b, replicates=3, central_points=2,\n    blocks='highest', shuffle=True)\ndf = builder.build_design(corrected=True)\nprint(df)\n</code></pre> <pre><code>    std_order  run_order  central_point  replica  block  A  B\n0           1          0              1        1      1  1  1\n1           5          1              1        2      1  1  1\n2           0          2              1        1      1 -1 -1\n3           7          3              0        1      1  0  0\n4           2          4              1        2      1 -1 -1\n5           4          5              1        3      1 -1 -1\n6           3          6              1        3      1  1  1\n7           6          7              0        2      1  0  0\n8          11          8              1        1      2  1 -1\n9          15          9              0        3      2  0  0\n10          8         10              1        1      2 -1  1\n11         12         11              1        2      2 -1  1\n12         13         12              1        2      2  1 -1\n13         10         13              1        3      2 -1  1\n14          9         14              1        3      2  1 -1\n15         14         15              0        4      2  0  0\n</code></pre> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If any of the parameters are invalid: - All factors must have exactly 2 levels. - Number of replicates must be positive. - Number of central points must be non-negative. - Number of blocks must be positive.</p> </li> </ul>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.blocks","title":"<code>blocks</code>  <code>property</code> <code>writable</code>","text":"<p>Block assignment: integer for evenly spaced blocks,  str | List[str] for user-defined block generator, or Literal  'highest'/'replica'.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.central_points","title":"<code>central_points</code>  <code>property</code> <code>writable</code>","text":"<p>Number of central points (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>List of columns in the design matrix.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.factor_names","title":"<code>factor_names</code>  <code>property</code>","text":"<p>List of factor names (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.factors","title":"<code>factors</code>  <code>property</code> <code>writable</code>","text":"<p>Tuple of factors defining the design space.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.fold","title":"<code>fold</code>  <code>instance-attribute</code>","text":"<p>Whether to add a foldover to the design.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.is_2k","title":"<code>is_2k</code>  <code>property</code>","text":"<p>Check if the design is a 2^k design.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.level_counts","title":"<code>level_counts</code>  <code>property</code>","text":"<p>Tuple of level counts for each factor (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.replicates","title":"<code>replicates</code>  <code>property</code> <code>writable</code>","text":"<p>Number of replicates (read-only).</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.shuffle","title":"<code>shuffle = shuffle</code>  <code>instance-attribute</code>","text":"<p>Whether to shuffle the design.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.standard_columns","title":"<code>standard_columns</code>  <code>property</code>","text":"<p>List of standard columns in the design matrix.</p>"},{"location":"doe/full-factorial/#daspi.doe.FullFactorial2kDesignBuilder.build_design","title":"<code>build_design(corrected=True)</code>","text":"<p>Generate the design matrix with original factor values.</p> <p>This method builds the design matrix by generating the corrected (integer-coded) design, replicating it according to the replicates parameter, shuffling it if specified, and  adding central points if specified. Block assignment is controlled by the <code>blocks</code> option at initialization:</p> <ul> <li>If <code>blocks</code> is an int &gt; 1: blocks are assigned evenly    (not statistically confounded).</li> <li>If <code>blocks</code> is an str or List[str]: blocks are assigned by    confounding with the specified interaction    (statistically correct).</li> <li>If <code>blocks</code> is 'highest': blocks are assigned by confounding   with the highest-order interaction (all centralized factors).</li> <li>If <code>blocks</code> is 'replica': blocks are assigned based on the   replicate number.</li> <li>If <code>blocks</code> == 1: all runs are assigned to block 1.</li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Design matrix with original factor values if corrected is False, otherwise with integer codes representing factor levels.</p> </li> </ul> Notes <p>Statistically correct block assignment is performed by  confounding the block effect with a specified interaction  (block generator). For each run, the value of the block  generator (the product of the coded levels of the specified  factors) is computed, and unique values are mapped to block  numbers. If <code>blocks</code> is 'highest', the highest-order interaction  (all factors) is used. This ensures that block effects are  orthogonal to main effects and lower-order interactions when  using a confounding generator, as recommended in DOE literature  (see Montgomery, 2017). If <code>blocks</code> is a str or List[str], the specified interaction is used. If <code>blocks</code> is 'replica', blocks are assigned by replicate. If <code>blocks</code> is an int, blocks are assigned evenly (not statistically confounded).</p>"},{"location":"guides/","title":"User Guide","text":"<p>Welcome to the DaSPi User Guide! This section provides comprehensive guidance on using DaSPi for data analysis, statistical process improvement, and quality engineering.</p>"},{"location":"guides/#3s-methodology","title":"3S Methodology","text":"<p>The 3S Methodology is a systematic problem-solving approach that combines the best practices from Six Sigma DMAIC and 8D methodologies. It provides a structured framework for identifying, analyzing, and solving quality problems.</p>"},{"location":"guides/#3s-methodology-overview","title":"3S Methodology Overview","text":"<p>Learn about the complete 3S methodology, its phases, and how it integrates with existing quality frameworks.</p>"},{"location":"guides/#specify-phase","title":"Specify Phase","text":"<p>The first phase focuses on defining and containing the problem:</p> <ul> <li>Team formation and project charter</li> <li>Problem definition and impact assessment  </li> <li>SIPOC analysis and process mapping</li> <li>Immediate containment strategies</li> <li>Validation and measurement systems</li> </ul>"},{"location":"guides/#scrutinize-phase","title":"Scrutinize Phase","text":"<p>The second phase concentrates on investigating and analyzing root causes:</p> <ul> <li>Root cause analysis techniques</li> <li>Statistical analysis and hypothesis testing</li> <li>Design of Experiments (DOE)</li> <li>Correlation and regression analysis</li> <li>Multivariate analysis methods</li> </ul>"},{"location":"guides/#stabilize-phase","title":"Stabilize Phase","text":"<p>The final phase emphasizes implementing and controlling sustainable solutions:</p> <ul> <li>Solution selection and optimization</li> <li>Implementation and validation</li> <li>Control systems and monitoring</li> <li>Knowledge transfer and project closure</li> </ul>"},{"location":"guides/#statistical-methods","title":"Statistical Methods","text":"<p>Comprehensive guides for statistical analysis using DaSPi:</p>"},{"location":"guides/#process-capability-analysis","title":"Process Capability Analysis","text":"<ul> <li>Capability indices (Cp, CpK, Pp, PpK)</li> <li>Sigma level calculations</li> <li>Specification limits and process performance</li> </ul>"},{"location":"guides/#design-of-experiments","title":"Design of Experiments","text":"<ul> <li>Full factorial designs</li> <li>Fractional factorial designs</li> <li>Response surface methodology</li> <li>Optimization techniques</li> </ul>"},{"location":"guides/#statistical-process-control","title":"Statistical Process Control","text":"<ul> <li>Control charts for variables and attributes</li> <li>Process monitoring and control</li> <li>Out-of-control detection and response</li> </ul>"},{"location":"guides/#hypothesis-testing","title":"Hypothesis Testing","text":"<ul> <li>Parametric and non-parametric tests</li> <li>ANOVA and regression analysis</li> <li>Confidence intervals and significance testing</li> </ul>"},{"location":"guides/#data-visualization","title":"Data Visualization","text":"<p>Learn to create effective visualizations with DaSPi's plotting capabilities:</p>"},{"location":"guides/#plotting-guide","title":"Plotting Guide","text":"<p>Comprehensive guide to creating professional charts and visualizations using DaSPi's plotting library.</p>"},{"location":"guides/#chart-types","title":"Chart Types","text":"<ul> <li>Distribution plots (histograms, box plots, violin plots)</li> <li>Scatter plots and correlation matrices</li> <li>Time series and trend analysis</li> <li>Process control charts</li> </ul>"},{"location":"guides/#best-practices","title":"Best Practices","text":"<p>Guidelines for effective use of DaSPi in quality improvement projects:</p>"},{"location":"guides/#data-collection-and-preparation","title":"Data Collection and Preparation","text":"<ul> <li>Sampling strategies and sample size determination</li> <li>Data cleaning and preprocessing</li> <li>Measurement system analysis</li> </ul>"},{"location":"guides/#statistical-analysis-workflow","title":"Statistical Analysis Workflow","text":"<ul> <li>Exploratory data analysis</li> <li>Assumption checking and validation</li> <li>Model selection and interpretation</li> <li>Results communication</li> </ul>"},{"location":"guides/#project-management","title":"Project Management","text":"<ul> <li>Problem-solving methodologies</li> <li>Team collaboration and communication</li> <li>Documentation and knowledge transfer</li> </ul>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<p>If you're new to DaSPi, we recommend starting with:</p> <ol> <li>3S Methodology Overview - Understand the systematic approach</li> <li>Specify Phase - Learn problem definition and containment</li> <li>Plotting Guide - Master data visualization techniques</li> </ol> <p>For specific statistical methods, navigate to the relevant sections in the documentation or explore the examples in our notebook collection.</p>"},{"location":"guides/3s-methodology/","title":"3S Methodology: A Structured Problem-Solving Approach","text":"<p>The 3S methodology is a streamlined, three-phase problem-solving framework based on the core idea of Speed Six Sigma, which combines the strengths of Task Force approaches, 8D methodology, and Six Sigma DMAIC. However, unlike Speed Six Sigma's focus on acceleration through parallel execution, step omission, or reordering, the 3S methodology emphasizes systematic thoroughness and sustainable implementation.</p>"},{"location":"guides/3s-methodology/#foundation-and-methodology-integration","title":"Foundation and Methodology Integration","text":"<p>The 3S framework selectively incorporates the most effective elements from established problem-solving methodologies:</p>"},{"location":"guides/3s-methodology/#from-task-force-approaches","title":"From Task Force Approaches","text":"<ul> <li>Rapid team mobilization and clear role definition</li> <li>Immediate containment to prevent further damage</li> <li>Cross-functional collaboration for comprehensive solutions</li> <li>Urgency and accountability in problem resolution</li> </ul>"},{"location":"guides/3s-methodology/#from-8d-methodology","title":"From 8D Methodology","text":"<ul> <li>Structured problem-solving steps with clear gates and deliverables</li> <li>Root cause analysis with evidence-based verification</li> <li>Preventive measures to avoid recurrence</li> <li>Team-based approach with defined responsibilities</li> </ul>"},{"location":"guides/3s-methodology/#from-six-sigma-dmaic","title":"From Six Sigma DMAIC","text":"<ul> <li>Data-driven decision making throughout all phases</li> <li>Statistical rigor in analysis and validation</li> <li>Process focus rather than just symptom treatment</li> <li>Control systems for long-term sustainability</li> </ul>"},{"location":"guides/3s-methodology/#key-differences-from-speed-six-sigma","title":"Key Differences from Speed Six Sigma","text":"<p>While Speed Six Sigma aims to accelerate the Six Sigma process through parallel execution, step elimination, or sequence modification, the 3S methodology takes a fundamentally different approach:</p> Aspect Speed Six Sigma 3S Methodology Primary Goal Maximize speed of execution Ensure systematic completeness Approach Parallel tasks, skip steps, reorder Sequential phases with thorough validation Risk Management Accept higher risk for speed Minimize risk through containment Focus Process acceleration Sustainable problem resolution Validation Compressed validation cycles Comprehensive statistical validation Control Rapid implementation Robust control systems <p>The 3S methodology prioritizes correctness and sustainability over speed, ensuring that each phase is completed thoroughly before proceeding to the next. This approach reduces the risk of incomplete solutions and prevents problem recurrence.</p>"},{"location":"guides/3s-methodology/#authors-perspective-on-phase-completeness","title":"Author's Perspective on Phase Completeness","text":"<p>From the author's viewpoint, if parts of the methodology can be omitted\u2014especially the time-consuming Scrutinize phase\u2014then the problem likely doesn't warrant a structured team-based approach. Such problems are typically:</p> <ul> <li>Simple enough to be resolved by a single expert rather than a cross-functional team</li> <li>Well-understood with obvious root causes that don't require statistical investigation</li> <li>Low-impact issues that don't justify the investment in systematic analysis</li> </ul> <p>The Scrutinize phase is the intellectual heart of the 3S methodology. It transforms assumptions into evidence and hunches into validated hypotheses. Skipping this phase often leads to:</p> <ul> <li>Symptomatic fixes rather than root cause solutions</li> <li>Problem recurrence due to incomplete understanding</li> <li>Suboptimal solutions that miss underlying systemic issues</li> <li>Wasted resources on ineffective countermeasures</li> </ul>"},{"location":"guides/3s-methodology/#the-interaction-problem-why-trial-and-error-fails","title":"The Interaction Problem: Why Trial and Error Fails","text":"<p>Often, when people encounter problems, they resort to trial and error, thinking they've figured something out, and then get stuck. But frequently, there's an underlying interaction at play that completely throws them off, leaving them utterly clueless.</p> <p>Interactions between factors\u2014whether they're process parameters, environmental conditions, or system components\u2014can dramatically change the behavior of a system in ways that single-factor thinking cannot predict. For example:</p> <ul> <li>A process parameter that works perfectly at low temperatures may fail catastrophically at high temperatures</li> <li>A solution that succeeds in the morning shift may fail on the night shift due to different operator behaviors</li> <li>A fix that works for one batch of parts may fail for another batch due to material lot interactions</li> </ul> <p>This is precisely why the Scrutinize phase emphasizes interaction analysis\u2014to uncover these hidden relationships that conventional troubleshooting approaches miss. The systematic investigation of factor interactions is what separates professional problem-solving from amateur trial and error.</p> <p>If the scrutiny can be abbreviated, consider whether the problem truly requires a team effort or if it's better addressed by individual expert action. The 3S methodology is designed for complex, high-impact problems where thorough investigation of interactions is essential for sustainable resolution.</p>"},{"location":"guides/3s-methodology/#overview","title":"Overview","text":"<p>The 3S methodology consists of three main phases, each with a distinct focus and color-coded approach:</p>"},{"location":"guides/3s-methodology/#specify-define-contain","title":"\ud83d\udd35 Specify - Define &amp; Contain","text":"<p>Focus: Clear problem definition and immediate damage control</p> <ul> <li>Team formation and role assignment</li> <li>Problem definition with precise scope and quantification</li> <li>Immediate containment measures to prevent further damage</li> <li>Initial data collection and baseline establishment</li> </ul>"},{"location":"guides/3s-methodology/#scrutinize-investigate-analyze","title":"\ud83d\udfe1 Scrutinize - Investigate &amp; Analyze","text":"<p>Focus: Deep investigation and root cause identification through systematic interaction analysis</p> <ul> <li>Root cause analysis using structured methodologies</li> <li>Data-driven investigation through statistical methods</li> <li>Hypothesis testing and validation</li> <li>Factor interaction analysis and evidence development</li> <li>Multi-variate relationship mapping to uncover hidden dependencies</li> </ul>"},{"location":"guides/3s-methodology/#stabilize-implement-control","title":"\ud83d\udfe2 Stabilize - Implement &amp; Control","text":"<p>Focus: Sustainable solutions and long-term control</p> <ul> <li>Solution selection based on effectiveness and economics</li> <li>Implementation with validation and testing</li> <li>Control systems for long-term sustainability</li> <li>Knowledge transfer and continuous improvement</li> </ul>"},{"location":"guides/3s-methodology/#methodology-advantages","title":"Methodology Advantages","text":""},{"location":"guides/3s-methodology/#streamlined-approach","title":"Streamlined Approach","text":"<p>The 3S methodology simplifies traditional problem-solving frameworks while maintaining scientific rigor. It reduces complexity without sacrificing effectiveness.</p>"},{"location":"guides/3s-methodology/#color-coded-clarity","title":"Color-Coded Clarity","text":"<ul> <li>Blue (Specify): Represents clarity, structure, and focus</li> <li>Yellow (Scrutinize): Symbolizes analytical thinking and enlightenment</li> <li>Green (Stabilize): Signifies growth, success, and sustainability</li> </ul>"},{"location":"guides/3s-methodology/#integrated-tools-and-techniques","title":"Integrated Tools and Techniques","text":"<p>Each phase incorporates specific tools and methodologies:</p> Phase Key Tools Primary Output Specify SIPOC, Project Charter, Containment Actions Problem Definition Scrutinize Ishikawa, DOE, ANOVA, Hypothesis Tests Root Cause Identification Stabilize Control Plans, SPC, Validation Studies Sustainable Solution"},{"location":"guides/3s-methodology/#relationship-to-six-sigma-dmaic","title":"Relationship to Six Sigma DMAIC","text":"<p>The 3S methodology aligns with and simplifies the traditional DMAIC approach:</p> 3S Phase DMAIC Equivalent Key Activities Specify Define + Measure D1-D3: Team, Problem, Containment Scrutinize Analyze D4: Root Cause Analysis Stabilize Improve + Control D5-D8: Solutions, Validation, Control"},{"location":"guides/3s-methodology/#when-to-use-3s-methodology","title":"When to Use 3S Methodology","text":""},{"location":"guides/3s-methodology/#ideal-applications","title":"Ideal Applications","text":"<ul> <li>Manufacturing defects and quality issues</li> <li>Process capability improvements</li> <li>Customer complaints requiring systematic investigation</li> <li>Cost reduction initiatives with measurable targets</li> <li>Supplier quality problems</li> </ul>"},{"location":"guides/3s-methodology/#prerequisites","title":"Prerequisites","text":"<ul> <li>Measurable problem with quantifiable impact</li> <li>Available data or ability to collect relevant data</li> <li>Management support for resource allocation</li> <li>Cross-functional involvement when needed</li> </ul>"},{"location":"guides/3s-methodology/#getting-started","title":"Getting Started","text":"<ol> <li>Begin with Specify - Form your team and define the problem</li> <li>Move to Scrutinize - Investigate root causes systematically  </li> <li>Finish with Stabilize - Implement and sustain solutions</li> </ol> <p>Each phase builds upon the previous one, creating a logical flow from problem identification to sustainable solution implementation.</p>"},{"location":"guides/3s-methodology/#success-factors","title":"Success Factors","text":""},{"location":"guides/3s-methodology/#critical-elements","title":"Critical Elements","text":"<ul> <li>Clear problem definition with measurable objectives</li> <li>Data-driven decision making throughout all phases</li> <li>Stakeholder engagement and communication</li> <li>Systematic approach without shortcuts</li> <li>Focus on sustainability beyond immediate fixes</li> </ul>"},{"location":"guides/3s-methodology/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Rushing through the Specify phase without proper problem definition</li> <li>Implementing solutions without sufficient root cause analysis</li> <li>Neglecting control measures in the Stabilize phase</li> <li>Insufficient stakeholder communication and buy-in</li> </ul>"},{"location":"guides/3s-methodology/#tools-and-resources","title":"Tools and Resources","text":"<p>The DaSPi library provides comprehensive support for 3S methodology implementation:</p> <ul> <li>Statistical analysis tools for data investigation</li> <li>Visualization capabilities for clear communication</li> <li>Design of Experiments for systematic investigation</li> <li>Process control charts and monitoring tools</li> </ul> <p>Ready to start your 3S journey? Begin with the Specify phase to learn how to properly define your problem and set up your improvement project for success. \u0000 \u0000</p>"},{"location":"guides/3s-scrutinize/","title":"Scrutinize Phase: Investigate &amp; Analyze","text":"<p>The Scrutinize phase is the analytical heart of the 3S methodology, focusing on systematic investigation and root cause identification. This phase employs rigorous data analysis and statistical methods to uncover the true causes behind the problem.</p>"},{"location":"guides/3s-scrutinize/#overview","title":"Overview","text":"<p>The Scrutinize phase corresponds to the fourth step of the 8D approach (D4) and aligns with the Analyze phase of Six Sigma DMAIC. It emphasizes thorough investigation and evidence-based decision making.</p>"},{"location":"guides/3s-scrutinize/#phase-objectives","title":"Phase Objectives","text":""},{"location":"guides/3s-scrutinize/#primary-goals","title":"Primary Goals","text":"<ul> <li>Identify the most likely root causes using structured methodologies</li> <li>Weight and prioritize causes based on impact and likelihood</li> <li>Conduct statistical experiments to validate hypotheses</li> <li>Develop evidence-based conclusions through significance testing</li> </ul>"},{"location":"guides/3s-scrutinize/#success-criteria","title":"Success Criteria","text":"<p>\u2705 Root causes identified and validated through data analysis \u2705 Statistical evidence supports cause-and-effect relationships \u2705 Interaction effects are understood and quantified \u2705 Hypotheses tested with appropriate confidence levels  </p>"},{"location":"guides/3s-scrutinize/#key-activities","title":"Key Activities","text":""},{"location":"guides/3s-scrutinize/#1-root-cause-identification","title":"1. Root Cause Identification","text":"<p>Objective: Generate and organize potential causes systematically.</p> <p></p>"},{"location":"guides/3s-scrutinize/#brainstorming-techniques","title":"Brainstorming Techniques","text":"<p>Mind Mapping - Central problem in the center - Branch out to major categories - Sub-branches for specific causes - Visual representation of relationships</p> <p>Ishikawa (Fishbone) Diagram - Categories: Man, Machine, Method, Material, Environment, Measurement - Systematic exploration of each category - Team-based cause identification</p> <p>Process Mapping - Step-by-step process documentation - Identify potential failure points - Map inputs, outputs, and controls</p> <pre><code>import daspi as dsp\nimport pandas as pd\n\n# Example: Organize root cause data\ncauses_data = {\n    'Category': ['Machine', 'Machine', 'Material', 'Method', 'Environment'],\n    'Potential_Cause': ['Calibration drift', 'Wear', 'Contamination', 'Procedure gap', 'Temperature'],\n    'Likelihood': [0.8, 0.6, 0.7, 0.9, 0.5],\n    'Impact': [0.9, 0.7, 0.8, 0.8, 0.6]\n}\n\ncauses_df = pd.DataFrame(causes_data)\ncauses_df['Priority_Score'] = causes_df['Likelihood'] * causes_df['Impact']\nprint(causes_df.sort_values('Priority_Score', ascending=False))\n</code></pre>"},{"location":"guides/3s-scrutinize/#fmea-failure-mode-and-effects-analysis","title":"FMEA (Failure Mode and Effects Analysis)","text":"<p>Systematic analysis of potential failures:</p> Failure Mode Effects Causes Severity Occurrence Detection RPN Calibration drift Out-of-spec products Temperature variation 8 6 4 192 Tool wear Surface defects Usage cycles 7 7 3 147"},{"location":"guides/3s-scrutinize/#2-cause-prioritization","title":"2. Cause Prioritization","text":"<p>Objective: Weight and rank potential causes based on data and expert judgment.</p> <p></p>"},{"location":"guides/3s-scrutinize/#pairwise-comparison-method","title":"Pairwise Comparison Method","text":"<pre><code>import numpy as np\nfrom scipy import stats\n\n# Example: Pairwise comparison matrix\ncauses = ['Calibration', 'Temperature', 'Material_quality', 'Operator_skill']\nn_causes = len(causes)\n\n# Create comparison matrix (example values)\ncomparison_matrix = np.array([\n    [1, 3, 2, 4],    # Calibration vs others\n    [1/3, 1, 1/2, 2], # Temperature vs others  \n    [1/2, 2, 1, 3],   # Material vs others\n    [1/4, 1/2, 1/3, 1] # Operator vs others\n])\n\n# Calculate priority weights (simplified eigenvalue method)\nweights = np.mean(comparison_matrix / np.sum(comparison_matrix, axis=0), axis=1)\npriority_df = pd.DataFrame({\n    'Cause': causes,\n    'Weight': weights,\n    'Rank': stats.rankdata(-weights)\n})\n\nprint(priority_df.sort_values('Rank'))\n</code></pre>"},{"location":"guides/3s-scrutinize/#cause-effect-matrix","title":"Cause &amp; Effect Matrix","text":"<p>Link causes to customer requirements:</p> <pre><code># Example: C&amp;E Matrix analysis\nrequirements = ['Quality', 'Cost', 'Delivery']\nrequirement_weights = [9, 7, 5]  # Importance ratings\n\nce_matrix = pd.DataFrame({\n    'Cause': causes,\n    'Quality_Impact': [9, 7, 8, 6],\n    'Cost_Impact': [6, 4, 7, 5],\n    'Delivery_Impact': [3, 2, 4, 8]\n})\n\n# Calculate weighted scores\nfor i, req in enumerate(requirements):\n    col_name = f'{req}_Impact'\n    ce_matrix[f'{req}_Weighted'] = ce_matrix[col_name] * requirement_weights[i]\n\nce_matrix['Total_Score'] = (ce_matrix['Quality_Weighted'] + \n                           ce_matrix['Cost_Weighted'] + \n                           ce_matrix['Delivery_Weighted'])\n\nprint(ce_matrix[['Cause', 'Total_Score']].sort_values('Total_Score', ascending=False))\n</code></pre>"},{"location":"guides/3s-scrutinize/#pareto-analysis","title":"Pareto Analysis","text":"<p>Visualize the vital few causes:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Create Pareto chart\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# Pareto chart of causes\nsorted_data = ce_matrix.sort_values('Total_Score', ascending=False)\ncumulative_pct = np.cumsum(sorted_data['Total_Score']) / sorted_data['Total_Score'].sum() * 100\n\nax1.bar(sorted_data['Cause'], sorted_data['Total_Score'], alpha=0.7)\nax1.set_ylabel('Impact Score')\nax1.set_title('Cause Impact Analysis')\nax1.tick_params(axis='x', rotation=45)\n\n# Cumulative percentage line\nax1_twin = ax1.twinx()\nax1_twin.plot(sorted_data['Cause'], cumulative_pct, 'ro-', color='red')\nax1_twin.axhline(y=80, color='red', linestyle='--', alpha=0.7, label='80% Line')\nax1_twin.set_ylabel('Cumulative %')\nax1_twin.set_ylim(0, 100)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"guides/3s-scrutinize/#3-statistical-experimentation","title":"3. Statistical Experimentation","text":"<p>Objective: Design and conduct experiments to validate cause-and-effect relationships.</p> <p></p>"},{"location":"guides/3s-scrutinize/#design-of-experiments-doe","title":"Design of Experiments (DOE)","text":"<p>Full Factorial Design</p> <pre><code>from itertools import product\n\n# Example: 2^3 factorial design\nfactors = {\n    'Temperature': [80, 120],\n    'Pressure': [2, 4], \n    'Time': [30, 60]\n}\n\n# Generate all combinations\ndesign_points = list(product(*factors.values()))\nfactor_names = list(factors.keys())\n\ndesign_df = pd.DataFrame(design_points, columns=factor_names)\ndesign_df['Run_Order'] = np.random.permutation(len(design_df))\ndesign_df = design_df.sort_values('Run_Order').reset_index(drop=True)\n\nprint(\"Experimental Design:\")\nprint(design_df)\n</code></pre> <p>Response Surface Methodology (RSM)</p> <p>For optimization studies when approaching optimal conditions:</p> <pre><code># Example: Central Composite Design\nfrom scipy.stats import norm\n\n# Define factor levels for CCD\nalpha = np.sqrt(len(factor_names))  # Rotatable design\ncenter_points = 3\n\n# Generate design matrix (simplified)\nprint(f\"Alpha value for rotatable design: {alpha:.2f}\")\nprint(f\"Recommended center points: {center_points}\")\n</code></pre>"},{"location":"guides/3s-scrutinize/#evop-evolutionary-operation","title":"EVOP (Evolutionary Operation)","text":"<p>For ongoing process improvement during production:</p> <pre><code># Example: Simple EVOP cycle\ncurrent_conditions = {'Temperature': 100, 'Pressure': 3}\nevop_changes = {'Temperature': \u00b12, 'Pressure': \u00b10.2}\n\nprint(\"EVOP Experimental Conditions:\")\nfor factor, base_value in current_conditions.items():\n    change = evop_changes[factor]\n    print(f\"{factor}: {base_value-change}, {base_value}, {base_value+change}\")\n</code></pre>"},{"location":"guides/3s-scrutinize/#4-hypothesis-testing-and-validation","title":"4. Hypothesis Testing and Validation","text":"<p>Objective: Use statistical methods to prove cause-and-effect relationships.</p> <p></p>"},{"location":"guides/3s-scrutinize/#anova-analysis-of-variance","title":"ANOVA (Analysis of Variance)","text":"<p>Test for significant differences between factor levels:</p> <pre><code>import daspi as dsp\nfrom scipy import stats\n\n# Example: One-way ANOVA\ngroup1 = np.random.normal(100, 5, 30)  # Control\ngroup2 = np.random.normal(105, 5, 30)  # Treatment A\ngroup3 = np.random.normal(98, 5, 30)   # Treatment B\n\n# Perform ANOVA\nf_stat, p_value = stats.f_oneway(group1, group2, group3)\n\nprint(f\"F-statistic: {f_stat:.3f}\")\nprint(f\"p-value: {p_value:.3f}\")\n\nif p_value &lt; 0.05:\n    print(\"Significant difference detected between groups\")\n\n    # Post-hoc analysis\n    from scipy.stats import tukey_hsd\n    result = tukey_hsd(group1, group2, group3)\n    print(result)\n</code></pre>"},{"location":"guides/3s-scrutinize/#correlation-analysis","title":"Correlation Analysis","text":"<p>Identify linear relationships between variables:</p> <pre><code># Example: Correlation analysis\nnp.random.seed(42)\nx = np.random.normal(0, 1, 100)\ny = 2 * x + np.random.normal(0, 0.5, 100)  # Strong correlation\nz = np.random.normal(0, 1, 100)             # No correlation\n\ncorrelation_data = pd.DataFrame({'X': x, 'Y': y, 'Z': z})\ncorrelation_matrix = correlation_data.corr()\n\nprint(\"Correlation Matrix:\")\nprint(correlation_matrix.round(3))\n\n# Test significance\nfrom scipy.stats import pearsonr\nr_xy, p_xy = pearsonr(x, y)\nprint(f\"\\nX-Y Correlation: r={r_xy:.3f}, p={p_xy:.3f}\")\n</code></pre>"},{"location":"guides/3s-scrutinize/#regression-analysis","title":"Regression Analysis","text":"<p>Quantify relationships and predict outcomes:</p> <pre><code>from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score\n\n# Multiple regression example\nX = correlation_data[['X', 'Z']]\ny = correlation_data['Y']\n\nmodel = LinearRegression().fit(X, y)\ny_pred = model.predict(X)\nr2 = r2_score(y, y_pred)\n\nprint(f\"R-squared: {r2:.3f}\")\nprint(f\"Coefficients: {model.coef_}\")\nprint(f\"Intercept: {model.intercept_:.3f}\")\n</code></pre>"},{"location":"guides/3s-scrutinize/#multivariate-analysis","title":"Multivariate Analysis","text":"<p>For complex interactions and multiple responses:</p> <pre><code># Example: Principal Component Analysis\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\n\n# Simulate multivariate data\nprocess_data = pd.DataFrame({\n    'Temperature': np.random.normal(100, 10, 200),\n    'Pressure': np.random.normal(50, 5, 200),\n    'Flow_Rate': np.random.normal(25, 3, 200),\n    'Humidity': np.random.normal(60, 8, 200)\n})\n\n# Standardize and perform PCA\nscaler = StandardScaler()\nscaled_data = scaler.fit_transform(process_data)\n\npca = PCA()\npca_result = pca.fit_transform(scaled_data)\n\nprint(\"Explained Variance Ratio:\")\nfor i, ratio in enumerate(pca.explained_variance_ratio_):\n    print(f\"PC{i+1}: {ratio:.3f}\")\n</code></pre>"},{"location":"guides/3s-scrutinize/#decision-point-can-problem-be-demonstrably-solved","title":"Decision Point: Can Problem Be Demonstrably Solved?","text":"<p>At the end of the Scrutinize phase, evaluate whether sufficient evidence exists:</p>"},{"location":"guides/3s-scrutinize/#yes-proceed-to-stabilize-phase","title":"\u2705 Yes \u2192 Proceed to Stabilize Phase","text":"<ul> <li>Root causes are identified and validated</li> <li>Statistical evidence supports cause-and-effect relationships</li> <li>Confidence in solution approach is high</li> </ul>"},{"location":"guides/3s-scrutinize/#no-return-to-experimentation","title":"\u274c No \u2192 Return to Experimentation","text":"<ul> <li>Conduct additional experiments</li> <li>Explore alternative hypotheses</li> <li>Consider different experimental designs</li> </ul>"},{"location":"guides/3s-scrutinize/#tools-and-techniques-summary","title":"Tools and Techniques Summary","text":""},{"location":"guides/3s-scrutinize/#essential-tools-for-scrutinize-phase","title":"Essential Tools for Scrutinize Phase","text":"Tool Purpose Best Used When Ishikawa Diagram Systematic cause identification Starting root cause analysis Pairwise Comparison Objective cause prioritization Multiple competing causes DOE Validate cause-and-effect Controllable factors exist ANOVA Test statistical significance Comparing multiple groups Regression Quantify relationships Continuous variables Multivariate Analysis Complex interactions Many variables involved"},{"location":"guides/3s-scrutinize/#daspi-library-support","title":"DaSPi Library Support","text":"<p>The DaSPi library provides comprehensive tools for the Scrutinize phase:</p> <pre><code>import daspi as dsp\n\n# Statistical testing\nresult = dsp.hypothesis_test(data1, data2, test_type='t_test')\n\n# ANOVA analysis  \nanova_result = dsp.anova_analysis(data, factors=['A', 'B', 'C'])\n\n# Process capability\ncapability = dsp.ProcessEstimator(samples=data, spec_limits=limits)\n\n# Correlation analysis\ncorrelations = dsp.correlation_matrix(dataframe)\n\n# Visualization\ndsp.pareto_chart(causes, impacts)\ndsp.scatter_plot_matrix(variables)\n</code></pre>"},{"location":"guides/3s-scrutinize/#common-challenges-and-solutions","title":"Common Challenges and Solutions","text":""},{"location":"guides/3s-scrutinize/#challenge-1-too-many-potential-causes","title":"Challenge 1: Too Many Potential Causes","text":"<p>Solution:</p> <ul> <li>Use structured prioritization methods</li> <li>Focus on causes with highest impact and likelihood</li> <li>Apply the 80/20 rule to identify vital few causes</li> </ul>"},{"location":"guides/3s-scrutinize/#challenge-2-limited-data-for-analysis","title":"Challenge 2: Limited Data for Analysis","text":"<p>Solution:</p> <ul> <li>Design efficient experiments with maximum information</li> <li>Use historical data and process knowledge</li> <li>Consider observational studies when experiments are not feasible</li> </ul>"},{"location":"guides/3s-scrutinize/#challenge-3-complex-interactions","title":"Challenge 3: Complex Interactions","text":"<p>Solution:</p> <ul> <li>Use factorial designs to study interactions</li> <li>Apply multivariate analysis techniques</li> <li>Break complex problems into smaller, manageable parts</li> </ul>"},{"location":"guides/3s-scrutinize/#next-steps","title":"Next Steps","text":"<p>Once root causes are validated and evidence is compelling:</p> <p>\ud83d\udd04 Proceed to Stabilize Phase to develop and implement solutions</p> <p>The thorough investigation completed in the Scrutinize phase provides the foundation for effective solution development and implementation.</p> <p>Phase Complete! You have successfully identified and validated the root causes of the problem. The team now has solid evidence to guide solution development in the Stabilize phase. \u0000 \u0000</p>"},{"location":"guides/3s-specify/","title":"Specify Phase: Define &amp; Contain","text":"<p>The Specify phase is the foundation of the 3S methodology, focusing on clear problem definition and immediate damage control. This phase ensures that improvement efforts are properly scoped, resourced, and contained before moving into detailed analysis.</p>"},{"location":"guides/3s-specify/#overview","title":"Overview","text":"<p>The Specify phase corresponds to the first three steps of the traditional 8D approach (D1-D3) and combines elements of Six Sigma's Define and Measure phases.</p>"},{"location":"guides/3s-specify/#phase-objectives","title":"Phase Objectives","text":""},{"location":"guides/3s-specify/#primary-goals","title":"Primary Goals","text":"<ul> <li>Form an effective problem-solving team with appropriate skills and authority</li> <li>Define the problem precisely with clear scope and measurable impact</li> <li>Implement immediate containment to prevent further damage or defects</li> <li>Establish baseline measurements and data collection systems</li> </ul>"},{"location":"guides/3s-specify/#success-criteria","title":"Success Criteria","text":"<p>\u2705 Team formed with clear roles and responsibilities \u2705 Problem statement is specific, measurable, and time-bound \u2705 Containment measures are effective and validated \u2705 Data collection systems are operational  </p>"},{"location":"guides/3s-specify/#key-activities","title":"Key Activities","text":""},{"location":"guides/3s-specify/#1-team-formation-d1","title":"1. Team Formation (D1)","text":"<p>Objective: Assemble a cross-functional team with the right skills and authority.</p> <p></p>"},{"location":"guides/3s-specify/#essential-team-roles","title":"Essential Team Roles","text":"Role Responsibility Skills Required Project Champion Overall leadership, resource allocation Leadership, decision-making authority Technical Expert Process knowledge, technical analysis Domain expertise, problem-solving Data Analyst Statistical analysis, measurement Analytics, statistical tools Implementation Lead Solution deployment, change management Project management, communication"},{"location":"guides/3s-specify/#team-formation-checklist","title":"Team Formation Checklist","text":"<ul> <li>[ ] Project champion identified and committed</li> <li>[ ] Team members have appropriate expertise</li> <li>[ ] Team has decision-making authority</li> <li>[ ] Roles and responsibilities defined</li> <li>[ ] Communication plan established</li> <li>[ ] Meeting schedule set</li> </ul>"},{"location":"guides/3s-specify/#2-problem-definition-d2","title":"2. Problem Definition (D2)","text":"<p>Objective: Create a precise, quantified problem statement with clear scope.</p> <p></p>"},{"location":"guides/3s-specify/#sipoc-analysis","title":"SIPOC Analysis","text":"<p>Use SIPOC (Suppliers, Inputs, Process, Outputs, Customers) to understand the problem context:</p> <pre><code>import daspi as dsp\n\n# Example: Creating a SIPOC analysis visualization\nsipoc_data = {\n    'Suppliers': ['Material suppliers', 'Equipment vendors'],\n    'Inputs': ['Raw materials', 'Energy', 'Information'],\n    'Process': ['Manufacturing', 'Quality control', 'Packaging'],\n    'Outputs': ['Finished products', 'Waste', 'Reports'],\n    'Customers': ['End users', 'Distributors', 'Retailers']\n}\n\n# Visualize SIPOC (placeholder for future implementation)\n</code></pre>"},{"location":"guides/3s-specify/#problem-statement-template","title":"Problem Statement Template","text":"<p>Problem: [What is going wrong?] Impact: [How much? How often? Since when?] Scope: [Where does it occur? Where doesn't it occur?] Goal: [What improvement is targeted?] Timeline: [When will this be resolved?]  </p>"},{"location":"guides/3s-specify/#quantification-techniques","title":"Quantification Techniques","text":"<p>Use these metrics to quantify the problem:</p> <ul> <li>DPU (Defects Per Unit): Number of defects divided by number of units</li> <li>FPY (First Pass Yield): Percentage of units passing without rework</li> <li>CpK (Process Capability): Measure of process capability relative to specifications</li> </ul> <pre><code>import daspi as dsp\nimport numpy as np\n\n# Example: Calculate process metrics\ndata = np.random.normal(100, 5, 1000)  # Simulated process data\nspec_limits = dsp.SpecLimits(lower=85, upper=115)\n\n# Calculate process capability\nestimator = dsp.ProcessEstimator(\n    samples=data, \n    spec_limits=spec_limits\n)\n\nprint(f\"Process Mean: {estimator.mean:.2f}\")\nprint(f\"CpK: {estimator.cpk:.2f}\")\nprint(f\"DPU: {estimator.dpu:.3f}\")\n</code></pre>"},{"location":"guides/3s-specify/#3-immediate-containment-d3","title":"3. Immediate Containment (D3)","text":"<p>Objective: Implement immediate measures to prevent further defects or damage.</p> <p></p>"},{"location":"guides/3s-specify/#containment-action-categories","title":"Containment Action Categories","text":"<ol> <li>Detection Enhancement</li> <li>Increased inspection frequency</li> <li>Additional checkpoints</li> <li> <p>Improved testing methods</p> </li> <li> <p>Process Modification</p> </li> <li>Temporary parameter changes</li> <li>Additional process steps</li> <li> <p>Enhanced monitoring</p> </li> <li> <p>Material/Product Segregation</p> </li> <li>Quarantine suspect materials</li> <li>Enhanced sorting procedures</li> <li>Special handling protocols</li> </ol>"},{"location":"guides/3s-specify/#containment-effectiveness-validation","title":"Containment Effectiveness Validation","text":"<p>Containment measures must be validated through:</p> <ul> <li>Statistical testing of effectiveness</li> <li>Process capability analysis</li> <li>Cost-benefit evaluation</li> </ul> <pre><code># Example: Validate containment effectiveness\nbefore_containment = np.array([...])  # Pre-containment data\nafter_containment = np.array([...])   # Post-containment data\n\n# Perform hypothesis test for improvement\ntest_result = dsp.hypothesis_test(\n    before_containment, \n    after_containment,\n    test_type='two_sample'\n)\n\nif test_result.p_value &lt; 0.05:\n    print(\"Containment is statistically effective\")\n</code></pre>"},{"location":"guides/3s-specify/#tools-and-techniques","title":"Tools and Techniques","text":""},{"location":"guides/3s-specify/#essential-tools-for-specify-phase","title":"Essential Tools for Specify Phase","text":"Tool Purpose When to Use Project Charter Define project scope and objectives Start of project SIPOC Diagram Understand process boundaries Problem scoping Action Plan Track containment activities Implementation Eisenhower Matrix Prioritize urgent actions Resource allocation"},{"location":"guides/3s-specify/#data-collection-setup","title":"Data Collection Setup","text":"<p>Establish measurement systems early:</p> <pre><code>import daspi as dsp\nimport pandas as pd\n\n# Example: Set up data collection framework\nmeasurement_plan = {\n    'metric': ['defect_rate', 'cycle_time', 'customer_complaints'],\n    'frequency': ['hourly', 'daily', 'weekly'],\n    'target': [0.01, 120, 5],\n    'responsibility': ['QC', 'Production', 'Customer Service']\n}\n\ntracking_df = pd.DataFrame(measurement_plan)\nprint(tracking_df)\n</code></pre>"},{"location":"guides/3s-specify/#decision-point-is-immediate-measure-effective","title":"Decision Point: Is Immediate Measure Effective?","text":"<p>At the end of the Specify phase, evaluate containment effectiveness:</p>"},{"location":"guides/3s-specify/#yes-proceed-to-scrutinize-phase","title":"\u2705 Yes \u2192 Proceed to Scrutinize Phase","text":"<ul> <li>Containment is validated and effective</li> <li>Problem is contained and data collection is active</li> <li>Team is ready for root cause investigation</li> </ul>"},{"location":"guides/3s-specify/#no-revise-containment-strategy","title":"\u274c No \u2192 Revise Containment Strategy","text":"<ul> <li>Review and enhance containment measures</li> <li>Consider additional actions or different approaches</li> <li>Re-validate effectiveness before proceeding</li> </ul>"},{"location":"guides/3s-specify/#common-challenges-and-solutions","title":"Common Challenges and Solutions","text":""},{"location":"guides/3s-specify/#challenge-1-vague-problem-definition","title":"Challenge 1: Vague Problem Definition","text":"<p>Symptoms: Problem statement lacks specificity or measurable impact</p> <p>Solution:</p> <ul> <li>Use the 5W2H method (Who, What, When, Where, Why, How, How Much)</li> <li>Quantify with specific metrics and timeframes</li> <li>Validate problem scope with stakeholders</li> </ul>"},{"location":"guides/3s-specify/#challenge-2-ineffective-team-composition","title":"Challenge 2: Ineffective Team Composition","text":"<p>Symptoms: Missing expertise, lack of authority, or poor engagement</p> <p>Solution:</p> <ul> <li>Review team skills matrix against problem requirements</li> <li>Ensure management support and clear authority levels</li> <li>Establish clear communication protocols and meeting rhythms</li> </ul>"},{"location":"guides/3s-specify/#challenge-3-weak-containment-actions","title":"Challenge 3: Weak Containment Actions","text":"<p>Symptoms: Continued defect occurrence, ineffective temporary measures</p> <p>Solution:</p> <ul> <li>Implement multiple containment layers</li> <li>Use statistical validation of effectiveness</li> <li>Consider more aggressive temporary measures</li> </ul>"},{"location":"guides/3s-specify/#deliverables-and-outputs","title":"Deliverables and Outputs","text":""},{"location":"guides/3s-specify/#phase-completion-checklist","title":"Phase Completion Checklist","text":"<ul> <li>[ ] Team Charter - Roles, responsibilities, and communication plan</li> <li>[ ] Problem Statement - Quantified and scoped problem definition</li> <li>[ ] SIPOC Analysis - Process understanding and boundaries</li> <li>[ ] Containment Plan - Immediate measures with validation</li> <li>[ ] Data Collection System - Baseline measurements and ongoing tracking</li> <li>[ ] Project Timeline - Milestones and resource allocation</li> </ul>"},{"location":"guides/3s-specify/#key-metrics-and-kpis","title":"Key Metrics and KPIs","text":"<p>Track these metrics throughout the Specify phase:</p> <ul> <li>Containment Effectiveness: Reduction in defect rate or problem impact</li> <li>Team Readiness: Completion of required training and role clarity</li> <li>Data Quality: Completeness and accuracy of baseline measurements</li> <li>Stakeholder Alignment: Agreement on problem definition and scope</li> </ul>"},{"location":"guides/3s-specify/#next-steps","title":"Next Steps","text":"<p>Once the Specify phase is complete and containment is validated as effective:</p> <p>\ud83d\udd04 Proceed to Scrutinize Phase to begin systematic root cause analysis</p> <p>The solid foundation established in the Specify phase enables effective investigation and analysis in the next phase. Ensure all deliverables are complete before transitioning.</p> <p>Phase Complete! You have successfully contained the immediate problem and established a strong foundation for systematic improvement. The team is ready to dive deep into root cause analysis in the Scrutinize phase. \u0000 \u0000</p>"},{"location":"guides/3s-stabilize/","title":"Stabilize Phase: Implement &amp; Control","text":"<p>The Stabilize phase is the execution and sustainability phase of the 3S methodology, focusing on solution implementation and long-term control. This phase ensures that improvements are not only effective but also sustainable over time.</p>"},{"location":"guides/3s-stabilize/#overview","title":"Overview","text":"<p>The Stabilize phase corresponds to steps D5-D8 of the 8D approach and combines the Improve and Control phases of Six Sigma DMAIC. It emphasizes sustainable implementation and knowledge transfer.</p>"},{"location":"guides/3s-stabilize/#phase-objectives","title":"Phase Objectives","text":""},{"location":"guides/3s-stabilize/#primary-goals","title":"Primary Goals","text":"<ul> <li>Select the most economical solution while considering customer needs</li> <li>Implement and validate corrective measures with statistical confidence</li> <li>Establish control systems to ensure long-term sustainability</li> <li>Document and transfer knowledge for future applications</li> </ul>"},{"location":"guides/3s-stabilize/#success-criteria","title":"Success Criteria","text":"<p>\u2705 Solution implemented and validated as effective \u2705 Control systems are operational and monitored \u2705 Immediate containment measures are removed safely \u2705 Knowledge documented and shared with stakeholders  </p>"},{"location":"guides/3s-stabilize/#key-activities","title":"Key Activities","text":""},{"location":"guides/3s-stabilize/#1-solution-selection-d5","title":"1. Solution Selection (D5)","text":"<p>Objective: Choose the most effective and economical solution while considering customer impact.</p> <p></p>"},{"location":"guides/3s-stabilize/#target-optimization","title":"Target Optimization","text":"<p>Optimize solutions for multiple objectives:</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize\n\n# Example: Multi-objective optimization\ndef objective_function(x):\n    # x = [temperature, pressure, speed]\n    quality = -(x[0] - 100)**2/100 - (x[1] - 50)**2/25  # Maximize quality\n    cost = 0.1*x[0] + 0.05*x[1] + 0.2*x[2]              # Minimize cost\n    time = 60/x[2]                                        # Minimize cycle time\n\n    # Weighted objective (maximize)\n    return -(0.5*quality - 0.3*cost - 0.2*time)\n\n# Constraints\nconstraints = [\n    {'type': 'ineq', 'fun': lambda x: x[0] - 80},    # Temp &gt;= 80\n    {'type': 'ineq', 'fun': lambda x: 120 - x[0]},   # Temp &lt;= 120\n    {'type': 'ineq', 'fun': lambda x: x[1] - 40},    # Pressure &gt;= 40\n    {'type': 'ineq', 'fun': lambda x: 60 - x[1]},    # Pressure &lt;= 60\n    {'type': 'ineq', 'fun': lambda x: x[2] - 10},    # Speed &gt;= 10\n    {'type': 'ineq', 'fun': lambda x: 30 - x[2]}     # Speed &lt;= 30\n]\n\n# Optimize\nresult = minimize(objective_function, [100, 50, 20], constraints=constraints)\nprint(f\"Optimal settings: Temperature={result.x[0]:.1f}, Pressure={result.x[1]:.1f}, Speed={result.x[2]:.1f}\")\n</code></pre>"},{"location":"guides/3s-stabilize/#solution-selection-matrix","title":"Solution Selection Matrix","text":"<p>Systematic evaluation of alternative solutions:</p> <pre><code># Example: Solution evaluation matrix\nsolutions = ['Process_Redesign', 'Equipment_Upgrade', 'Training_Program', 'Inspection_Increase']\ncriteria = ['Cost', 'Effectiveness', 'Implementation_Time', 'Risk', 'Customer_Impact']\nweights = [0.25, 0.30, 0.15, 0.15, 0.15]  # Criterion weights\n\n# Scores (1-10 scale, higher is better)\nscores = {\n    'Process_Redesign': [6, 9, 4, 7, 8],\n    'Equipment_Upgrade': [3, 8, 2, 8, 9],\n    'Training_Program': [9, 6, 8, 9, 7],\n    'Inspection_Increase': [8, 5, 9, 8, 6]\n}\n\n# Calculate weighted scores\nevaluation_df = pd.DataFrame(scores, index=criteria).T\nweighted_scores = {}\n\nfor solution in solutions:\n    weighted_score = sum(evaluation_df.loc[solution, criterion] * weight \n                        for criterion, weight in zip(criteria, weights))\n    weighted_scores[solution] = weighted_score\n\n# Rank solutions\nranking = sorted(weighted_scores.items(), key=lambda x: x[1], reverse=True)\nprint(\"Solution Ranking:\")\nfor i, (solution, score) in enumerate(ranking, 1):\n    print(f\"{i}. {solution}: {score:.2f}\")\n</code></pre>"},{"location":"guides/3s-stabilize/#importance-urgency-matrix-eisenhower-matrix","title":"Importance-Urgency Matrix (Eisenhower Matrix)","text":"<p>Prioritize implementation activities:</p> <pre><code># Example: Eisenhower Matrix for implementation tasks\ntasks = [\n    {'Task': 'Update work instructions', 'Importance': 9, 'Urgency': 8},\n    {'Task': 'Train operators', 'Importance': 8, 'Urgency': 9},\n    {'Task': 'Install new equipment', 'Importance': 7, 'Urgency': 6},\n    {'Task': 'Revise procedures', 'Importance': 9, 'Urgency': 7},\n    {'Task': 'Update documentation', 'Importance': 6, 'Urgency': 5}\n]\n\ntask_df = pd.DataFrame(tasks)\n\n# Categorize tasks\ndef categorize_task(importance, urgency):\n    if importance &gt;= 7 and urgency &gt;= 7:\n        return 'Do First (Urgent &amp; Important)'\n    elif importance &gt;= 7 and urgency &lt; 7:\n        return 'Schedule (Important, Not Urgent)'\n    elif importance &lt; 7 and urgency &gt;= 7:\n        return 'Delegate (Urgent, Not Important)'\n    else:\n        return 'Eliminate (Neither)'\n\ntask_df['Category'] = task_df.apply(lambda x: categorize_task(x['Importance'], x['Urgency']), axis=1)\nprint(task_df[['Task', 'Category']].sort_values(['Importance', 'Urgency'], ascending=False))\n</code></pre>"},{"location":"guides/3s-stabilize/#2-implementation-and-validation-d6","title":"2. Implementation and Validation (D6)","text":"<p>Objective: Implement corrective measures and validate their effectiveness statistically.</p> <p></p>"},{"location":"guides/3s-stabilize/#hypothesis-testing-for-validation","title":"Hypothesis Testing for Validation","text":"<p>Compare before and after performance:</p> <pre><code>import daspi as dsp\nfrom scipy import stats\n\n# Example: Validation study\nnp.random.seed(42)\nbefore_implementation = np.random.normal(100, 15, 50)  # Historical data\nafter_implementation = np.random.normal(110, 12, 50)   # Post-implementation\n\n# Perform t-test for improvement\nt_stat, p_value = stats.ttest_ind(before_implementation, after_implementation)\n\nprint(f\"Before Implementation - Mean: {np.mean(before_implementation):.2f}, Std: {np.std(before_implementation):.2f}\")\nprint(f\"After Implementation - Mean: {np.mean(after_implementation):.2f}, Std: {np.std(after_implementation):.2f}\")\nprint(f\"T-statistic: {t_stat:.3f}, P-value: {p_value:.3f}\")\n\nif p_value &lt; 0.05:\n    improvement = np.mean(after_implementation) - np.mean(before_implementation)\n    print(f\"Statistically significant improvement: {improvement:.2f}\")\n</code></pre>"},{"location":"guides/3s-stabilize/#process-capability-assessment","title":"Process Capability Assessment","text":"<p>Evaluate process capability with new conditions:</p> <pre><code>import daspi as dsp\n\n# Example: Process capability analysis\nspec_limits = dsp.SpecLimits(lower=85, upper=115)\n\n# Before implementation\nestimator_before = dsp.ProcessEstimator(\n    samples=before_implementation,\n    spec_limits=spec_limits\n)\n\n# After implementation  \nestimator_after = dsp.ProcessEstimator(\n    samples=after_implementation,\n    spec_limits=spec_limits\n)\n\nprint(\"Process Capability Comparison:\")\nprint(f\"Before - Cp: {estimator_before.cp:.3f}, CpK: {estimator_before.cpk:.3f}\")\nprint(f\"After  - Cp: {estimator_after.cp:.3f}, CpK: {estimator_after.cpk:.3f}\")\nprint(f\"Sigma Level Before: {estimator_before.sigma_level:.2f}\")\nprint(f\"Sigma Level After: {estimator_after.sigma_level:.2f}\")\n</code></pre>"},{"location":"guides/3s-stabilize/#charts-for-location-variation-and-proportions","title":"Charts for Location, Variation and Proportions","text":"<p>Create comprehensive visualization of improvements:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Create comparison charts\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 10))\n\n# Histogram comparison\nax1.hist(before_implementation, alpha=0.7, label='Before', bins=15)\nax1.hist(after_implementation, alpha=0.7, label='After', bins=15)\nax1.set_title('Distribution Comparison')\nax1.set_xlabel('Value')\nax1.set_ylabel('Frequency')\nax1.legend()\nax1.axvline(spec_limits.lower, color='red', linestyle='--', label='LSL')\nax1.axvline(spec_limits.upper, color='red', linestyle='--', label='USL')\n\n# Box plot comparison\nax2.boxplot([before_implementation, after_implementation], \n           labels=['Before', 'After'])\nax2.set_title('Variation Comparison')\nax2.set_ylabel('Value')\nax2.axhline(spec_limits.lower, color='red', linestyle='--')\nax2.axhline(spec_limits.upper, color='red', linestyle='--')\n\n# Process capability bars\ncategories = ['Before', 'After']\ncp_values = [estimator_before.cp, estimator_after.cp]\ncpk_values = [estimator_before.cpk, estimator_after.cpk]\n\nx_pos = np.arange(len(categories))\nwidth = 0.35\n\nax3.bar(x_pos - width/2, cp_values, width, label='Cp')\nax3.bar(x_pos + width/2, cpk_values, width, label='CpK')\nax3.set_title('Process Capability Comparison')\nax3.set_ylabel('Capability Index')\nax3.set_xticks(x_pos)\nax3.set_xticklabels(categories)\nax3.legend()\nax3.axhline(1.33, color='green', linestyle='--', label='Target')\n\n# Sigma level comparison\nsigma_values = [estimator_before.sigma_level, estimator_after.sigma_level]\nax4.bar(categories, sigma_values, color=['orange', 'green'], alpha=0.7)\nax4.set_title('Sigma Level Improvement')\nax4.set_ylabel('Sigma Level')\nax4.axhline(6.0, color='red', linestyle='--', label='Six Sigma Target')\nax4.legend()\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"guides/3s-stabilize/#3-control-systems-implementation-d7","title":"3. Control Systems Implementation (D7)","text":"<p>Objective: Establish sustainable control mechanisms to maintain improvements.</p> <p></p>"},{"location":"guides/3s-stabilize/#statistical-process-control-spc","title":"Statistical Process Control (SPC)","text":"<p>Implement ongoing monitoring:</p> <pre><code>import daspi as dsp\n\n# Example: Control chart setup\ncontrol_data = np.random.normal(110, 5, 100)  # Ongoing process data\n\n# Calculate control limits\nmean = np.mean(control_data)\nstd = np.std(control_data)\nucl = mean + 3 * std\nlcl = mean - 3 * std\n\n# Create control chart\nplt.figure(figsize=(12, 6))\nplt.plot(control_data, 'bo-', markersize=4)\nplt.axhline(mean, color='green', label=f'Mean = {mean:.2f}')\nplt.axhline(ucl, color='red', linestyle='--', label=f'UCL = {ucl:.2f}')\nplt.axhline(lcl, color='red', linestyle='--', label=f'LCL = {lcl:.2f}')\nplt.fill_between(range(len(control_data)), lcl, ucl, alpha=0.2, color='green')\nplt.title('Statistical Process Control Chart')\nplt.xlabel('Sample Number')\nplt.ylabel('Measurement Value')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n\n# Check for out-of-control conditions\nout_of_control = (control_data &gt; ucl) | (control_data &lt; lcl)\nif np.any(out_of_control):\n    print(f\"Out-of-control points detected at samples: {np.where(out_of_control)[0]}\")\n</code></pre>"},{"location":"guides/3s-stabilize/#control-plans-and-ocap","title":"Control Plans and OCAP","text":"<p>Develop Out-of-Control Action Plans:</p> <pre><code># Example: Control plan structure\ncontrol_plan = pd.DataFrame({\n    'Process_Step': ['Mixing', 'Heating', 'Cooling', 'Packaging'],\n    'Characteristic': ['Viscosity', 'Temperature', 'Time', 'Weight'],\n    'Specification': ['100\u00b110', '120\u00b15', '30\u00b12', '500\u00b15'],\n    'Measurement_Method': ['Viscometer', 'Thermocouple', 'Timer', 'Scale'],\n    'Sample_Size': [3, 5, 1, 10],\n    'Frequency': ['Hourly', 'Continuous', 'Each batch', 'Every 10 units'],\n    'Control_Method': ['SPC Chart', 'Alarm', 'Check sheet', 'SPC Chart'],\n    'Reaction_Plan': ['Stop &amp; adjust', 'Auto control', 'Manual check', 'Investigate']\n})\n\nprint(\"Control Plan:\")\nprint(control_plan)\n</code></pre>"},{"location":"guides/3s-stabilize/#time-series-analysis","title":"Time Series Analysis","text":"<p>Monitor trends and patterns:</p> <pre><code>from sklearn.linear_model import LinearRegression\n\n# Example: Trend analysis\ntime_points = np.arange(len(control_data))\ntrend_model = LinearRegression().fit(time_points.reshape(-1, 1), control_data)\ntrend_line = trend_model.predict(time_points.reshape(-1, 1))\n\n# Plot with trend\nplt.figure(figsize=(12, 6))\nplt.plot(time_points, control_data, 'bo-', markersize=4, label='Data')\nplt.plot(time_points, trend_line, 'r-', linewidth=2, label=f'Trend (slope={trend_model.coef_[0]:.4f})')\nplt.title('Process Trend Analysis')\nplt.xlabel('Time')\nplt.ylabel('Measurement Value')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n\n# Trend significance test\nfrom scipy.stats import linregress\nslope, intercept, r_value, p_value, std_err = linregress(time_points, control_data)\nprint(f\"Trend Analysis: Slope={slope:.4f}, R\u00b2={r_value**2:.3f}, p-value={p_value:.3f}\")\n</code></pre>"},{"location":"guides/3s-stabilize/#4-knowledge-transfer-and-closure-d8","title":"4. Knowledge Transfer and Closure (D8)","text":"<p>Objective: Document lessons learned and apply knowledge to similar projects.</p> <p></p>"},{"location":"guides/3s-stabilize/#lessons-learned-documentation","title":"Lessons Learned Documentation","text":"<pre><code># Example: Lessons learned template\nlessons_learned = {\n    'Project': '3S Quality Improvement',\n    'Duration': '3 months',\n    'Team_Size': 6,\n    'Problem_Category': 'Manufacturing Defect',\n    'Root_Causes': ['Equipment calibration drift', 'Operator procedure gaps'],\n    'Solutions_Implemented': ['Automated calibration system', 'Enhanced training program'],\n    'Key_Learnings': [\n        'Early containment prevented customer impact',\n        'Statistical validation was crucial for buy-in',\n        'Automated solutions more sustainable than manual procedures'\n    ],\n    'Recommendations': [\n        'Implement similar automated systems in other areas',\n        'Standardize statistical validation approach',\n        'Create reusable training materials'\n    ],\n    'Metrics_Improved': {\n        'Defect_Rate': {'Before': 0.05, 'After': 0.01, 'Improvement': '80%'},\n        'CpK': {'Before': 1.1, 'After': 1.8, 'Improvement': '64%'},\n        'Customer_Complaints': {'Before': 12, 'After': 2, 'Improvement': '83%'}\n    }\n}\n\nprint(\"PROJECT SUMMARY\")\nprint(\"=\"*50)\nfor key, value in lessons_learned.items():\n    if key != 'Metrics_Improved':\n        print(f\"{key.replace('_', ' ').title()}: {value}\")\n\nprint(\"\\nKEY METRICS IMPROVEMENT\")\nprint(\"=\"*30)\nfor metric, values in lessons_learned['Metrics_Improved'].items():\n    print(f\"{metric}: {values['Before']} \u2192 {values['After']} ({values['Improvement']} improvement)\")\n</code></pre>"},{"location":"guides/3s-stabilize/#final-presentation-template","title":"Final Presentation Template","text":"<p>Key elements for project closure:</p> <ol> <li>Executive Summary</li> <li>Problem statement and business impact</li> <li>Solution overview and results</li> <li> <p>Return on investment</p> </li> <li> <p>Technical Details</p> </li> <li>Root cause analysis findings</li> <li>Statistical validation results</li> <li> <p>Implementation approach</p> </li> <li> <p>Results and Benefits</p> </li> <li>Performance improvements</li> <li>Cost savings</li> <li> <p>Customer impact</p> </li> <li> <p>Sustainability Plan</p> </li> <li>Control systems implemented</li> <li>Training completed</li> <li> <p>Monitoring procedures</p> </li> <li> <p>Recommendations</p> </li> <li>Applications to other areas</li> <li>Additional improvement opportunities</li> <li>Process standardization needs</li> </ol>"},{"location":"guides/3s-stabilize/#removal-of-immediate-containment","title":"Removal of Immediate Containment","text":"<p>Critical Step: Once permanent solutions are validated, safely remove temporary containment:</p> <pre><code># Example: Containment removal validation\ndef validate_containment_removal(performance_data, threshold=0.01):\n    \"\"\"Validate that containment can be safely removed\"\"\"\n    recent_performance = performance_data[-20:]  # Last 20 data points\n    defect_rate = np.sum(recent_performance &gt; threshold) / len(recent_performance)\n\n    if defect_rate &lt; 0.05:  # Less than 5% above threshold\n        return True, f\"Safe to remove containment. Recent defect rate: {defect_rate:.3f}\"\n    else:\n        return False, f\"Keep containment. Recent defect rate: {defect_rate:.3f} too high\"\n\n# Test containment removal\nsafe_to_remove, message = validate_containment_removal(control_data, threshold=120)\nprint(message)\n</code></pre>"},{"location":"guides/3s-stabilize/#success-metrics-and-kpis","title":"Success Metrics and KPIs","text":"<p>Track these metrics throughout the Stabilize phase:</p>"},{"location":"guides/3s-stabilize/#financial-impact","title":"Financial Impact","text":"<pre><code># Example: ROI calculation\nimplementation_cost = 50000  # Total cost of solution\nannual_savings = 120000      # Annual savings from improvement\n\n# Simple ROI\nroi = (annual_savings - implementation_cost) / implementation_cost * 100\npayback_period = implementation_cost / annual_savings * 12  # months\n\nprint(f\"Return on Investment: {roi:.1f}%\")\nprint(f\"Payback Period: {payback_period:.1f} months\")\n</code></pre>"},{"location":"guides/3s-stabilize/#quality-metrics","title":"Quality Metrics","text":"<ul> <li>Process Capability: CpK improvement</li> <li>Defect Reduction: DPU, FPY improvements  </li> <li>Customer Satisfaction: Complaint reduction</li> <li>Process Stability: Control chart performance</li> </ul>"},{"location":"guides/3s-stabilize/#operational-metrics","title":"Operational Metrics","text":"<ul> <li>Implementation Timeline: On schedule completion</li> <li>Training Effectiveness: Competency assessments</li> <li>Control System Performance: Monitoring compliance</li> <li>Knowledge Transfer: Documentation completion</li> </ul>"},{"location":"guides/3s-stabilize/#common-challenges-and-solutions","title":"Common Challenges and Solutions","text":""},{"location":"guides/3s-stabilize/#challenge-1-solution-implementation-resistance","title":"Challenge 1: Solution Implementation Resistance","text":"<p>Solution:</p> <ul> <li>Involve stakeholders in solution design</li> <li>Provide clear communication of benefits</li> <li>Start with pilot implementation to prove effectiveness</li> </ul>"},{"location":"guides/3s-stabilize/#challenge-2-inadequate-control-systems","title":"Challenge 2: Inadequate Control Systems","text":"<p>Solution:</p> <ul> <li>Design robust control plans with clear responsibilities</li> <li>Implement multiple layers of control (prevention, detection, response)</li> <li>Provide training and support for control system operation</li> </ul>"},{"location":"guides/3s-stabilize/#challenge-3-loss-of-improvements-over-time","title":"Challenge 3: Loss of Improvements Over Time","text":"<p>Solution:</p> <ul> <li>Establish regular review and audit cycles</li> <li>Create clear escalation procedures for out-of-control conditions</li> <li>Maintain active engagement from management and stakeholders</li> </ul>"},{"location":"guides/3s-stabilize/#project-completion-checklist","title":"Project Completion Checklist","text":"<ul> <li>[ ] Solution implemented and statistically validated</li> <li>[ ] Control systems operational with trained personnel</li> <li>[ ] Containment measures safely removed</li> <li>[ ] Documentation complete and accessible</li> <li>[ ] Training delivered and competency verified</li> <li>[ ] Lessons learned documented and shared</li> <li>[ ] Final presentation delivered to stakeholders</li> <li>[ ] Project closure completed with stakeholder sign-off</li> </ul> <p>Congratulations! You have successfully completed the 3S methodology. The problem has been systematically resolved with sustainable solutions, and valuable knowledge has been captured for future improvements.</p>"},{"location":"guides/anova/","title":"ANOVA","text":""},{"location":"guides/anova/#what-is-anova","title":"What is ANOVA?","text":"<p>ANOVA, which stands for Analysis of Variance, is a statistical method used to compare the means of three or more groups to determine if at least one of the group means is significantly different from the others. It helps in understanding whether the variations in data can be attributed to different factors or treatments.</p>"},{"location":"guides/anova/#what-does-anova-do","title":"What Does ANOVA Do?","text":"<p>ANOVA tests the hypothesis that the means of different groups are equal. It evaluates the impact of one or more categorical independent variables on a continuous dependent variable. The main goal is to identify whether any of the group means differ significantly, implying that the independent variable(s) have an effect on the dependent variable.</p>"},{"location":"guides/anova/#difference-between-anova-and-linear-regression","title":"Difference Between ANOVA and Linear Regression","text":"<ol> <li>Type of Variables:</li> <li>ANOVA is primarily used when dealing with categorical independent variables (factors) and a continuous dependent variable.</li> <li>Linear Regression can handle both continuous and categorical independent variables, focusing on predicting the value of the dependent variable based on the independent variables.</li> <li>Purpose:<ul> <li>ANOVA is used to compare means across groups and to test for differences in group means.</li> <li>Linear Regression aims to model the relationship between variables and make predictions based on that relationship.</li> </ul> </li> <li>Output:<ul> <li>ANOVA provides insights into whether there are any statistically significant differences between group means.</li> </ul> </li> <li>Linear Regression provides coefficients that describe the relationship between the independent variables and the dependent variable.</li> </ol> <p>ANOVA requires a linear model similar to linear regression, allowing for the inclusion of continuous variables. Typically, a balanced experimental design is established, where parameters are recorded as factor levels, either categorically or quasi-categorically. Additionally, continuous disturbances such as temperature and time can also be measured and incorporated into the model for evaluation in the ANOVA.</p>"},{"location":"guides/anova/#hypothesis-tests-in-anova","title":"Hypothesis Tests in ANOVA","text":"<p>In ANOVA, the following hypotheses are tested:</p> <ul> <li>Null Hypothesis (H0): All group means are equal.</li> <li>Alternative Hypothesis (H1): At least one group mean is different.</li> </ul> <p>The test statistic used in ANOVA is the F-statistic, which is the ratio of the variance between the groups to the variance within the groups. If the F-statistic is significantly large, it suggests that the null hypothesis can be rejected.</p> <p>While these hypotheses could also be tested using a t-test, it would necessitate conducting tests for all possible combinations of group pairs. This highlights a significant advantage of ANOVA: it allows us to accept or reject the null hypothesis through a single test, streamlining the analysis process.</p>"},{"location":"guides/anova/#distribution-basis","title":"Distribution Basis","text":"<p>ANOVA is based on the F-distribution, which is used to determine the critical values for the F-statistic. The F-distribution arises from the ratio of two independent chi-squared distributions and is used to evaluate the significance of the observed variances.</p>"},{"location":"guides/anova/#types-of-anova","title":"Types of ANOVA","text":"<p>The type of ANOVA determines how the sum of squares is partitioned among the factors. The SAS/STAT and also Minitab software uses Type III by default. This type is also the only one who gives us a sum of square value (SS) and a p-value for the Intercept. So Type-III is also used internaly for evaluating the least significant term. A discussion on which one to use can be found at StackExchange. A nice conclusion about the differences between the types:</p> <ul> <li>Typ-I: We choose the most \"important\" independent variable and it will receive the maximum amount of variation possible.</li> <li>Typ-II: We ignore the shared variation: no interaction is assumed. If this is true, the Type II Sums of Squares are statistically more powerful. However if in reality there is an interaction effect, the model will be wrong and there will be a problem in the conclusions of the analysis.</li> <li>Typ-III: If there is an interaction effect and we are looking for an \u201cequal\u201d split between the independent variables, Type-III should be used. [1]</li> </ul> <p>source: Towards Data Science</p>"},{"location":"guides/anova/#example","title":"Example","text":"<p>Research from the University of Melbourne indicates potential differences in pain thresholds between blonds and brunettes. Participants, including men and women of various ages, were classified into four hair color categories: light blond, dark blond, light brunette, and dark brunette. We will now examine this dataset to explore the relationship between hair color and pain perception. [2]</p> <p>To begin with, we will take an exploratory look at the data:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('anova')\nchart = dsp.SingleChart(\n        source=df,\n        target='Pain threshold',\n        feature='Hair color',\n        categorical_feature=True,\n    ).plot(\n        dsp.Jitter\n    ).label(\n        feature_label=True,\n        target_label=True,\n    )\n</code></pre> <p></p> <p>Visually they seem to be different, now we test against the hypothesis that they are not:</p> <pre><code>model = dsp.LinearModel(df, 'Pain threshold', ['Hair color'])\nmodel.anova()\n</code></pre> Typ-II DF SS MS F p n2 Source Hair color 3 1360.726316 453.575439 6.791407 0.004114 0.575962 Residual 15 1001.800000 66.786667 NaN NaN 0.424038 <p>The columns explained from left to right:</p> <ul> <li>Typ-II: Which ANOVA type was performed</li> <li>DF: degree of freedom, equal to the number of observed groups minus 1</li> <li>SS: sum of squares</li> <li>MS: mean squares</li> <li>F: F-statistic value</li> <li>p: p-value as the probability that the null hypothesis is true</li> <li>n2: \\(\\eta^2\\) Is the ratio of SS to the sum of all SS. It indicates how much of the total variance can be explained with this factor level. n2 of Residual therefore corresponds to the unexplained variance</li> </ul> <p>The alpha risk, or Type I error, is the probability of incorrectly rejecting a true null hypothesis, typically set at \\(\\alpha=0.05\\). It indicates the chance of finding a false positive in hypothesis testing. Since our p-value for hair color is less than alpha, we can assume that hair color has a statistically significant influence on how much pain we can tolerate... \ud83d\ude09</p>"},{"location":"guides/anova/#influence","title":"Influence","text":"<p>The influence \\(\\tau\\) of the individual groups is calculated from the group mean values to the overall mean value.</p> <pre><code>x_bar = df['Pain threshold'].mean()\nx_bar_group = df.groupby('Hair color')['Pain threshold'].mean()\nx_bar_group - x_bar\n</code></pre> <pre><code>Hair color\nDark Blond         3.357895\nDark Brunette     10.442105\nLight Blond       11.357895\nLight Brunette     5.342105\nName: Pain threshold, dtype: float64\n</code></pre> <p>This influence can be displayed using the following command:</p> <pre><code>LEVEL = 0.95\nchart = dsp.SingleChart(\n        source=df,\n        target='Pain threshold',\n        feature='Hair color',\n        categorical_feature=True,\n    ).plot(\n        dsp.MeanTest, confidence_level=LEVEL, show_center=False\n    ).plot(\n        dsp.CenterLocation\n    ).stripes(\n        mean=True\n    ).label(\n        fig_title='Pain threshold by hair color',\n        sub_title=f'Mean and {int(100*LEVEL)} % confidence interval',\n        feature_label=True,\n        target_label=True,\n    )\n</code></pre> <p></p> <p>The group means are shown as blue dots and the overall mean as a gray dashed line.</p>"},{"location":"guides/anova/#uncertainty-of-the-model","title":"Uncertainty of the model","text":"<p>So far we have determined the predicted values of the model. Since the predicted values were determined from samples, these values have an uncertainty. We can quantify this uncertainty by using the error term from the ANOVA table as the mean squares of the residuals \\(MS_{residual}\\). The uncertainty \\(s\\) is calculated as follows: [3]</p> \\[s=\\sqrt{MS_{residual}}\\] <pre><code>print(model.uncertainty)\n</code></pre> <pre><code>2.374692962609412\n</code></pre>"},{"location":"guides/anova/#statistical-requirements","title":"Statistical requirements","text":"<p>Before we can use our mathematical model, we must check whether the statistical requirements are met:</p> <ol> <li>The residuals of the mathematical model are normally distributed.</li> <li>The residuals are homogeneous, i.e. they have constant variance, regardless of the adjustment value.</li> <li>The residuals have a mean of 0.</li> <li>The residuals of the mathematical model are independent.</li> </ol> <p>We can check these four points graphically using the following command. Each subplot corresponds to one of these four points in order from top left to bottom right. [4]</p> <pre><code>chart = dsp.ResidualsCharts(model).plot().label()\n</code></pre> <p></p>"},{"location":"guides/anova/#references","title":"References","text":"<p>[1] Joos K (2019). ANOVA\u2019s three types of estimating Sums of Squares: don\u2019t make the wrong choice! Towards Data Science</p> <p>[2] McClave and Dietrich (1991). Pain Thresholds of Blonds and Brunettes.</p> <p>[3] Almut Melzer (2015: 169). Six Sigma \u2013 Kompakt und praxisnah. Springer Gabler</p> <p>[4] Almut Melzer (2015: 169-170). Six Sigma \u2013 Kompakt und praxisnah. Springer Gabler</p>"},{"location":"guides/doe/","title":"Design of Experiments Guide","text":"<p>Design of Experiments (DOE) is a systematic approach to understanding how different factors affect a response variable. Instead of changing one factor at a time, DOE allows you to study multiple factors simultaneously, revealing important interactions while minimizing experimental effort.</p>"},{"location":"guides/doe/#when-should-you-use-doe","title":"When Should You Use DOE?","text":"<ul> <li>Process Optimization: Finding the best settings for your manufacturing process</li> <li>Product Development: Understanding how design parameters affect performance</li> <li>Quality Improvement: Identifying factors that impact product quality</li> <li>Screening Studies: Determining which factors are most important among many candidates</li> <li>Cost Reduction: Getting maximum information from minimum experimental effort</li> </ul>"},{"location":"guides/doe/#basic-doe-workflow","title":"Basic DOE Workflow","text":""},{"location":"guides/doe/#1-problem-definition","title":"1. Problem Definition","text":"<p>Start by clearly defining:</p> <ul> <li>Response variable: What you want to improve or understand</li> <li>Factors: Variables you can control that might affect the response</li> <li>Objectives: Are you screening, optimizing, or characterizing?</li> <li>Resources: How many experimental runs can you afford?</li> </ul>"},{"location":"guides/doe/#2-factor-selection-and-levels","title":"2. Factor Selection and Levels","text":"<pre><code>import daspi as dsp\n\n# Continuous factors (temperature, pressure, concentration)\ntemperature = dsp.Factor('Temperature', (150, 200))\npressure = dsp.Factor('Pressure', (10, 15))\ntime = dsp.Factor('Time', (30, 60))\n\n# Categorical factors (machine, operator, material)\nmachine = dsp.Factor('Machine', ('A', 'B', 'C'), is_categorical=True)\noperator = dsp.Factor('Operator', ('Day', 'Night'), is_categorical=True)\n</code></pre>"},{"location":"guides/doe/#3-choose-design-type","title":"3. Choose Design Type","text":"<p>The choice depends on your objectives and resources:</p> <pre><code># Full factorial: Complete information, higher cost\nbuilder = dsp.FullFactorialDesignBuilder(temperature, pressure, time)\n\n# Fractional factorial: Screening many factors, lower cost\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    temp, pressure, time, concentration, catalyst,\n    generators=['D=AB', 'E=AC']  # 5 factors in 8 runs\n)\n\n# 2^k specialized: Most common for industrial experiments\nbuilder = dsp.FullFactorial2kDesignBuilder(temperature, pressure, time)\n</code></pre>"},{"location":"guides/doe/#4-add-design-features","title":"4. Add Design Features","text":"<pre><code># Enhance your design with:\nbuilder = dsp.FullFactorial2kDesignBuilder(\n    temperature, pressure, time,\n    replicates=3,        # Repeat for error estimation\n    central_points=5,    # Detect curvature\n    blocks='highest',    # Control for time trends\n    shuffle=True         # Randomize run order\n)\n</code></pre>"},{"location":"guides/doe/#5-generate-and-execute","title":"5. Generate and Execute","text":"<pre><code># Generate the design matrix\ndesign = builder.build_design(corrected=False)\nprint(design)\n\n# Execute experiments according to run_order\n# Record your response data\n</code></pre>"},{"location":"guides/doe/#practical-example-chemical-process-optimization","title":"Practical Example: Chemical Process Optimization","text":"<p>Let's walk through a complete example optimizing a chemical reaction:</p>"},{"location":"guides/doe/#problem-setup","title":"Problem Setup","text":"<p>You want to maximize yield in a chemical reaction and suspect that temperature, pressure, and catalyst type affect the outcome.</p> <pre><code>import daspi as dsp\nimport numpy as np\n\n# Define factors\ntemperature = dsp.Factor('Temperature', (150, 200))  # \u00b0C\npressure = dsp.Factor('Pressure', (1.0, 1.5))       # bar\ncatalyst = dsp.Factor('Catalyst', ('A', 'B'), is_categorical=True)\n\n# Create a 2^3 design with center points\nbuilder = dsp.FullFactorial2kDesignBuilder(\n    temperature, pressure, catalyst,\n    replicates=2,        # Run each combination twice\n    central_points=4,    # 4 center points to check curvature\n    shuffle=True         # Randomize to avoid time effects\n)\n\ndesign = builder.build_design(corrected=False)\nprint(f\"Total experimental runs: {len(design)}\")\nprint(design.head(10))\n</code></pre>"},{"location":"guides/doe/#analyzing-results","title":"Analyzing Results","text":"<p>After running your experiments, you can analyze the results:</p> <pre><code># Add your response data (simulated here)\nnp.random.seed(42)\ndesign['Yield'] = (\n    75 +  # baseline\n    5 * (design['Temperature'] == 200) +     # temperature effect\n    3 * (design['Pressure'] == 1.5) +       # pressure effect\n    -2 * (design['Catalyst'] == 'B') +      # catalyst effect\n    2 * ((design['Temperature'] == 200) &amp; (design['Pressure'] == 1.5)) +  # interaction\n    np.random.normal(0, 1.5, len(design))   # experimental error\n)\n\n# Calculate factor effects\nhigh_temp_yield = design[design['Temperature'] == 200]['Yield'].mean()\nlow_temp_yield = design[design['Temperature'] == 150]['Yield'].mean()\ntemperature_effect = high_temp_yield - low_temp_yield\n\nprint(f\"Temperature effect: {temperature_effect:.2f} percentage points\")\n</code></pre>"},{"location":"guides/doe/#design-selection-guide","title":"Design Selection Guide","text":""},{"location":"guides/doe/#number-of-factors-vs-design-choice","title":"Number of Factors vs. Design Choice","text":"Factors Recommended Design Runs Purpose 2-4 Full Factorial 4-16 Complete understanding 5-8 Fractional Factorial 8-16 Factor screening 9+ Sequential DOE Variable Multi-stage approach"},{"location":"guides/doe/#resource-constraints","title":"Resource Constraints","text":"<p>Limited time/money: Start with fractional factorial for screening</p> <pre><code># Screen 6 factors in just 8 runs\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    *six_factors,\n    generators=['D=AB', 'E=AC', 'F=BC']\n)\n</code></pre> <p>Need complete picture: Use full factorial</p> <pre><code># All interactions for 3 factors\nbuilder = dsp.FullFactorialDesignBuilder(*three_factors)\n</code></pre>"},{"location":"guides/doe/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/doe/#sequential-experimentation","title":"Sequential Experimentation","text":"<ol> <li>Screen with fractional factorial to identify important factors</li> <li>Optimize with full factorial or response surface methods on important factors</li> <li>Confirm with verification runs at optimal conditions</li> </ol>"},{"location":"guides/doe/#blocking-strategy","title":"Blocking Strategy","text":"<p>Control for known nuisance variables:</p> <pre><code># Block by time periods\nbuilder = dsp.FullFactorialDesignBuilder(\n    temp, pressure, catalyst,\n    blocks=4,  # Split across 4 time periods\n    replicates=2\n)\n\n# Block by highest-order interaction (recommended)\nbuilder = dsp.FullFactorialDesignBuilder(\n    temp, pressure, catalyst,\n    blocks='highest',  # Confound with 3-way interaction\n)\n</code></pre>"},{"location":"guides/doe/#foldover-for-fractional-factorials","title":"Foldover for Fractional Factorials","text":"<p>Resolve confounding between main effects and interactions:</p> <pre><code># Initial fractional factorial\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C,\n    generators=['C=AB']\n)\n\n# Add foldover to resolve confounding\nbuilder = dsp.FractionalFactorialDesignBuilder(\n    A, B, C,\n    generators=['C=AB'],\n    fold=True  # Doubles the runs, resolves main effect confounding\n)\n</code></pre>"},{"location":"guides/doe/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"guides/doe/#too-many-factors-initially","title":"Too Many Factors Initially","text":"<p>Problem: Trying to study 10+ factors in one experiment</p> <p>Solution: Use sequential approach - screen first, then optimize</p>"},{"location":"guides/doe/#ignoring-practical-constraints","title":"Ignoring Practical Constraints","text":"<p>Problem: Factors levels that are impractical or unsafe</p> <p>Solution: Choose levels based on practical operating ranges</p>"},{"location":"guides/doe/#confusing-correlation-with-causation","title":"Confusing Correlation with Causation","text":"<p>Problem: Assuming all significant effects are causal</p> <p>Solution: Use engineering knowledge to interpret statistical results</p>"},{"location":"guides/doe/#not-randomizing","title":"Not Randomizing","text":"<p>Problem: Running experiments in standard order</p> <p>Solution: Always randomize unless there are strong practical constraints</p>"},{"location":"guides/doe/#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple: Begin with screening designs for many factors</li> <li>Use Replication: Include replicates to estimate error</li> <li>Add Center Points: Help detect curvature in responses</li> <li>Block When Possible: Control for known nuisance variables</li> <li>Randomize Run Order: Reduce bias from time trends</li> <li>Document Everything: Record all conditions and observations</li> <li>Validate Results: Confirm findings with follow-up experiments</li> </ol>"},{"location":"guides/doe/#next-steps","title":"Next Steps","text":"<p>After mastering basic DOE:</p> <ul> <li>Learn response surface methodology for optimization</li> <li>Explore mixture designs for formulation problems</li> <li>Study robust design for reducing variation</li> <li>Consider computer experiments for simulation studies</li> </ul> <p>The key is to start with simple designs and build complexity as you gain experience and understanding of your system.</p>"},{"location":"guides/gage_analysis/","title":"Gage Study and measurement uncertainties","text":""},{"location":"guides/gage_analysis/#standard-uncertainty-components","title":"Standard uncertainty components","text":"<p>The following table shows the typical standard uncertainties as they affect measurements. They are divided into Measurement System (MS) and Measurement Process (MP). The individual standard uncertainty components can be determined using method A or B. The method B refers to prior knowledge or information from manuals or specifications and the method A refers to statistical analysis.</p> Shortcut Uncertainty Component Impact Method <code>CAL</code> Calibration of the reference MS B <code>RE</code> Display resolution MS B <code>BI</code> Bias MS A/B <code>LIN</code> Linearity deviation MS A/B <code>EVR</code> Equipement Variation (repeatability) on the reference MS A <code>MPE</code> Maximum Permissible Error (error limit) MS B <code>EVO</code> Equipement Variation (repeatability) on the object MP A <code>AV</code> Appraiser Variation (comparability of operators) MP A <code>GV</code> Gage Variation (comparability of measurement system) MP A <code>IA</code> Interactions MP A <code>T</code> Temperature MP A/B <code>STAB</code> Stability over time MP A <code>OBJ</code> Inhomogeneity of the object MP A/B <code>REST</code> Other uncertainties not covered by the above MS/MP B"},{"location":"guides/installing/","title":"Installation Guide","text":""},{"location":"guides/installing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"guides/installing/#installing-from-pypi","title":"Installing from PyPI","text":"<p>The easiest way to install is via pip:</p> <pre><code>pip install daspi\n</code></pre>"},{"location":"guides/installing/#verifying-installation","title":"Verifying Installation","text":"<p>Verify the installation by executing the following lines with a Python interpreter:</p> <pre><code>import daspi\nprint(daspi.__version__)\n</code></pre> <p>Or directly in the terminal:</p> <pre><code>python -c \"import daspi; print(daspi.__version__)\" \n</code></pre>"},{"location":"guides/installing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/installing/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Import Errors</p> <ul> <li>Ensure Python environment is activated</li> <li>Verify package installation with <code>pip list</code></li> </ul> </li> <li> <p>Version Conflicts</p> <ul> <li>Try creating a new virtual environment</li> <li>Update dependencies with <code>pip install --upgrade</code></li> </ul> </li> </ol>"},{"location":"guides/installing/#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue on GitHub</li> <li>Check the documentation</li> </ul>"},{"location":"guides/installing/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Quick Start Guide</li> <li>Check out the API References:<ul> <li>Plotlib</li> <li>Statistics</li> <li>Anova</li> </ul> </li> <li>View User Guide</li> </ul>"},{"location":"guides/plotting/","title":"Plotting Guide","text":"<p>Welcome to the wonderful world of DaSPi plotting! \ud83c\udfa8 Think of this as your creative toolkit for turning boring numbers into beautiful, insightful visualizations. We've built a flexible system that lets you craft everything from simple scatter plots to complex multi-panel masterpieces.</p>"},{"location":"guides/plotting/#facets","title":"Facets","text":"<p>Facets are like the stage crew of your visualization theater - they work behind the scenes to make sure everything appears in exactly the right place. They handle the layout, positioning, and all those fiddly details so you can focus on the story your data wants to tell.</p>"},{"location":"guides/plotting/#axesfacets","title":"AxesFacets","text":"<p>Think of AxesFacets as your layout designer. This class creates the blueprint for where your subplots will live and builds the figure to house them. It's heavily inspired by Matplotlib's beloved <code>plt.subplots()</code> function (which it actually uses under the hood), but with some DaSPi magic sprinkled on top.</p> <p>You have two ways to design your layout:</p> <p>Option 1: The Grid Approach \ud83d\udcd0</p> <p>Use <code>nrows</code>, <code>ncols</code>, <code>width_ratios</code>, and <code>height_ratios</code> for clean, structured layouts:</p> <pre><code>import daspi as dsp\n\naxes = dsp.AxesFacets(\n    nrows=2, ncols=2, width_ratios=[3, 1], height_ratios=[1, 3])\n</code></pre> <p>Option 2: The Mosaic Approach \ud83e\udde9</p> <p>Use the <code>mosaic</code> argument for more creative, flexible layouts:</p> <pre><code>axes = dsp.AxesFacets(mosaic=[\n    'aaa.',\n    'bbbc',\n    'bbbc',\n    'bbbc'])\n</code></pre> <p>Both approaches give you the same basic layout, but mosaic has a cool trick up its sleeve - see that '.' in the top right? That tells Matplotlib to leave that space empty. It's like having a \"skip this spot\" instruction!</p> <p>Pro tip: Combine mosaic with ratios for the best of both worlds:</p> <pre><code>axes = dsp.AxesFacets(\n    mosaic=['a.', 'bc'], width_ratios=[3, 1], height_ratios=[1, 3])\n</code></pre> <p></p> <p>Accessing Your Axes \ud83c\udfaf</p> <p>Getting to your individual plots is super intuitive. You can use either: - A single number (like a flat list): <code>axes[1]</code> - Tuple notation (like numpy arrays): <code>axes[-1, 0]</code></p> <p>Plus, AxesFacets works as an iterator, so you can loop through your axes from top-left to bottom-right. Neat!</p>"},{"location":"guides/plotting/#stripesfacets","title":"StripesFacets","text":"<p>Ever wanted to add reference lines or highlight important regions across your plots? That's where StripesFacets shines! \u2728 This class adds horizontal or vertical lines and areas to your plots - perfect for showing specification limits, control limits, confidence intervals, or global statistics.</p> <p>The Problem: Imagine you're comparing data across multiple subplots. Each subplot shows the same type of analysis but for different categories. How do you quickly spot differences between groups?</p> <p>The Solution: Reference lines and areas that make patterns jump out at you!</p> <p>Let's see this in action with painkillers dissolution data. First, the \"before\" picture:</p> <pre><code>import daspi as dsp\nimport matplotlib.pyplot as plt\n\ndf = dsp.load_dataset('painkillers-dissolution')\n\nfig, axes = plt.subplots(\n    nrows=1, ncols=df['employee'].nunique(), sharex=True, sharey=True)\n\nfor ax, (name, group) in zip(axes, df.groupby('employee')):\n    ax.scatter(group['temperature'], group['dissolution'])\n    ax.set_title(str(name))\n</code></pre> <p></p> <p>Hard to compare, right? Now watch the magic happen when we add stripes:</p> <pre><code>import daspi as dsp\nimport matplotlib.pyplot as plt\n\ndf = dsp.load_dataset('painkillers-dissolution')\n\nfig, axes = plt.subplots(\n    nrows=1, ncols=df['employee'].nunique(), sharex=True, sharey=True)\n\nfor ax, (name, group) in zip(axes, df.groupby('employee')):\n    stripes = dsp.StripesFacets(\n        group['dissolution'],\n        target_on_y=True,\n        single_axes=False,\n        mean=True,\n        confidence=0.95,\n        spec_limits=dsp.SpecLimits(upper=25))\n    ax.scatter(group['temperature'], group['dissolution'])\n    ax.set_title(str(name))\n    stripes.draw(ax)\n</code></pre> <p></p> <p>Now you can instantly see which employee's tablets are taking too long to dissolve! \ud83c\udfaf</p> <p>\u26a0\ufe0f Important: When using StripesFacets across multiple subplots, set <code>sharey=True</code> so the reference lines align properly.</p>"},{"location":"guides/plotting/#labelfacets","title":"LabelFacets","text":"<p>LabelFacets is your typography and annotation specialist. \ud83d\udcdd This class handles all the text elements that make your plots publication-ready: titles, subtitles, axis labels, legends, and even info boxes.</p> <p>The best part? It automatically adjusts the subplot area to prevent text overlap. No more manually tweaking margins!</p> <pre><code>from matplotlib.lines import Line2D\nfrom matplotlib.patches import Patch\n\naxes = dsp.AxesFacets(nrows=3, ncols=2, sharey=True)\n\nlegend_data={\n    'Lines': [\n        (Line2D([0], [0], c='r'), Line2D([0], [0], c='b')),\n        ('red line', 'blue line')],\n    'Patches': [\n        (Patch(color='r'), Patch(color='b')), \n        ('red patch', 'blue patch')]},\n\nlabels = dsp.LabelFacets(\n    axes,\n    fig_title='Title',\n    sub_title='Subtitle',\n    xlabel=('xlabel tl', 'xlabel tr', 'xlabel cl', 'xlabel cr', 'xlabel bl', 'xlabel br'),\n    ylabel='single ylabel at center',\n    info='Info goes here',\n    cols=('col 1', 'col 2'),\n    col_title='Column title',\n    rows=('row 1', 'row 2', 'row3'),\n    row_title='Row title',\n    legend_data=legend_data)\nlabels.draw()\n</code></pre> <p></p>"},{"location":"guides/plotting/#bringing-it-all-together","title":"Bringing It All Together","text":"<p>Let's create a complete, professional-looking analysis by combining all three facet classes. We'll revisit our painkillers dissolution example and make it publication-ready:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\n\n# Create the subplots layout\naxes = dsp.AxesFacets(\n    nrows=1, ncols=df['employee'].nunique(), sharex=True, sharey=True)\n\n# Draw the stripes and plot data\nfor ax, (name, group) in zip(axes, df.groupby('employee')):\n    stripes = dsp.StripesFacets(\n        group['dissolution'],\n        target_on_y=True,\n        single_axes=False,\n        mean=True,\n        confidence=0.95,\n        spec_limits=dsp.SpecLimits(upper=25))\n    ax.scatter(group['temperature'], group['dissolution'])\n    stripes.draw(ax)\n\n# Add professional labeling\nlegend_data = {'Lines': stripes.handles_labels()}\n\nlabels = dsp.LabelFacets(\n    axes,\n    fig_title='Painkillers Dissolution Analysis',\n    sub_title='Dissolution time ~ temperature + employee',\n    xlabel='Temperature (\u00b0C)',\n    ylabel='Dissolution time (s)',\n    info='Mini-project from the Six Sigma Black Belt training',\n    cols=tuple(df['employee'].unique()),\n    col_title='Employee',\n    legend_data=legend_data)\nlabels.draw()\n</code></pre> <p></p> <p>From scattered data points to a professional analysis in just a few lines of code! \ud83d\ude80</p>"},{"location":"guides/plotting/#plotters","title":"Plotters","text":"<p>Welcome to the heart of DaSPi's visualization engine! \ud83d\udc96 Our plotter collection is like a Swiss Army knife for data visualization - we've got the right tool for every data story you want to tell.</p>"},{"location":"guides/plotting/#bivariate-xy-plots","title":"Bivariate (XY) Plots","text":"<p>These are your bread-and-butter relationship explorers. Perfect for answering \"How does X relate to Y?\" questions. The setup is always the same:</p> <ul> <li><code>source</code>: Your DataFrame (the data buffet)</li> <li><code>target</code>: The Y-axis variable (what you're trying to understand)</li> <li><code>feature</code>: The X-axis variable (what might be influencing your target)</li> </ul> <p></p>"},{"location":"guides/plotting/#univariate-distribution-plots","title":"Univariate (Distribution) Plots","text":"<p>When you want to get intimate with a single variable - understand its personality, quirks, and behavior patterns. These plots reveal the shape, center, and spread of your data.</p> <p></p>"},{"location":"guides/plotting/#plots-for-differences","title":"Plots for Differences","text":"<p>The \"spot the difference\" champions! \ud83d\udd0d These plots excel at comparing groups and highlighting variations between categories. Perfect for answering \"Are these groups really different?\" questions.</p> <p></p>"},{"location":"guides/plotting/#special-plots","title":"Special Plots","text":"<p>Our collection of specialized tools for specific analytical needs. These are the plots that make you look like a data visualization wizard! \u2728</p> <p></p>"},{"location":"guides/plotting/#charts","title":"Charts","text":"<p>Now for the grand finale! \ud83c\udfad We've built all these amazing components (facets and plotters), but wouldn't it be nice to have a simple way to orchestrate them all? Enter the chart classes - your new best friends for creating stunning visualizations without breaking a sweat.</p> <p>Think of charts as your personal plotting assistants. They handle all the tedious setup work while you focus on the fun part: telling your data's story.</p>"},{"location":"guides/plotting/#the-chart-family","title":"The Chart Family","text":"<p>Meet the three chart siblings, each with their own personality:</p> <ul> <li>SingleChart - The minimalist. One plot area, infinite possibilities.</li> <li>JointChart - The collaborator. Loves showing relationships between variables.</li> <li>MultiVariantChart - The overachiever. Handles complex multi-panel layouts like a boss.</li> </ul>"},{"location":"guides/plotting/#how-charts-work-their-magic","title":"How Charts Work Their Magic","text":"<p>These chart classes are essentially smart wrappers around our facet classes (AxesFacets, StripesFacets, and LabelFacets). They also provide a dead-simple interface for working with plotters. Think of them as the conductors of your data visualization orchestra! \ud83c\udfbc</p> <p>The beauty is in their flexibility - you can mix and match plotters however you want. Just call the <code>plot()</code> method multiple times with different plotter classes. It's like building with LEGO blocks, but for data visualization!</p>"},{"location":"guides/plotting/#the-chart-creation-recipe","title":"The Chart Creation Recipe","text":"<p>Here's the secret sauce for chart creation:</p> <ol> <li>Create your chart - The AxesFacets class gets instantiated automatically</li> <li>Add your plots - Call <code>plot()</code> as many times as you want with different plotters</li> <li>Sprinkle in some stripes - Call <code>stripes()</code> to add reference lines and areas</li> <li>Label everything beautifully - Call <code>labels()</code> to make it publication-ready</li> <li>Save your masterpiece - Call <code>save()</code> to preserve your work</li> </ol> <p>\u26a0\ufe0f Pro tip: The <code>labels()</code> method is a bit of a diva - it must be called last (but before <code>save()</code>). All other methods are more flexible and can be called in any order.</p>"},{"location":"guides/plotting/#method-chaining-magic","title":"Method Chaining Magic \u2728","text":"<p>All methods are chainable, so you can create entire visualizations in one elegant flow:</p> <pre><code>import daspi as dsp\n\nchart = dsp.SingleChart(...\n    ).plot(...\n    ).stripes(...\n    ).labels(...\n    ).save(...)\n</code></pre> <p>It's like writing poetry, but with data! Each method flows naturally into the next, creating a readable narrative of your visualization process.</p>"},{"location":"guides/plotting/#singlechart","title":"SingleChart","text":"<p>The SingleChart class is perfect when you want to focus all attention on one plot area. It's like having a single spotlight on stage - everything else fades away, and your data becomes the star.</p> <p>So now let's create a chart using the SingleChart class with the same data we used in the Facets section above.</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\n\nchart = dsp.SingleChart(\n        source=df,\n        target='dissolution',\n        feature='employee',\n        hue='brand',\n        dodge=True,\n    ).plot(\n        dsp.Beeswarm\n    ).plot(\n        dsp.CenterLocation,\n        show_line=True,\n        show_center=False,\n    ).plot(\n        dsp.MeanTest,\n        marker='_',\n        kw_center={'size': 100}\n    ).stripes(\n        mean=True,\n        confidence=0.95\n    ).label(\n        fig_title='Painkillers Dissolution Analysis',\n        sub_title='Dissolution time vs. Employee, Brand, and Stirrer',\n        target_label='Dissolution time (s)',\n        feature_label='Employee',\n        info=True\n    )\n</code></pre> <p></p> <p>The result? A professional-looking plot that would make any data scientist proud! \ud83d\udcca</p>"},{"location":"plotlib/","title":"Plotting Library","text":""},{"location":"plotlib/#daspi.plotlib","title":"<code>daspi.plotlib</code>","text":""},{"location":"plotlib/chart/","title":"Chart Module","text":""},{"location":"plotlib/chart/#daspi.plotlib.chart","title":"<code>daspi.plotlib.chart</code>","text":"<p>Module for creating various types of chart visualizations using  Matplotlib and Pandas.</p> <p>This module provides classes and utility functions to facilitate the  creation of different types of charts and visualizations. It includes  support for single-variable charts, joint charts combining multiple  variables, and charts with multiple variables simultaneously.</p> <p>All plotter objects from the plotter module can be used and combined  with the chart classes from this module to create a preferred plot that is optimal for the current analysis. These Chart objects are also used to combine the LabelFacets, AxesFacets, and StripesFacets facet objects to produce consistent charts for very different plots.</p>"},{"location":"plotlib/chart/#daspi.plotlib.chart--classes","title":"Classes","text":"<ul> <li>Chart: Abstract base class for creating chart visualizations.</li> <li>SingleChart: Represents a basic chart containing one Axes for    visualization with customizable features.</li> <li>JointChart: Represents a joint chart visualization combining   multiple individual Axes.</li> <li>MultivariateChart: Represents a chart visualization handling    multiple variables simultaneously.</li> </ul>"},{"location":"plotlib/chart/#daspi.plotlib.chart--functionality","title":"Functionality","text":"<ul> <li>Customization of chart attributes including target, feature, hue,    shape, size, etc.</li> <li>Layout setup for charts, including grid arrangements for joint charts.</li> <li>Adding stripes to highlight data patterns and labeling axes    appropriately.</li> <li>Saving charts to files and programmatically closing charts.</li> </ul>"},{"location":"plotlib/chart/#daspi.plotlib.chart--other-details","title":"Other Details","text":"<ul> <li>Dependencies: NumPy, Matplotlib, Pandas.</li> <li>Typing annotations are extensively used for type hinting and  documentation.</li> <li>Emphasizes modularity and extensibility, allowing users to create and  customize a wide range of chart visualizations.</li> </ul>"},{"location":"plotlib/chart/chart/","title":"Chart","text":""},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart","title":"<code>daspi.plotlib.chart.Chart</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for creating chart visualizations.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>A pandas DataFrame containing the data in long-format.</p> </li> <li> <code>target</code>               (<code>str or Tuple[str]</code>)           \u2013            <p>Column name for the target variable to be visualized.</p> </li> <li> <code>feature</code>               (<code>str or Tuple[str]</code>, default:                   <code>''</code> )           \u2013            <p>Column name for the feature variable to be visualized.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the target variable is plotted on the y-axis.</p> </li> <li> <code>colors</code>               (<code>Tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of unique colors used for hue categories as hex or str, by default <code>CATEGORY.PALETTE</code>.</p> </li> <li> <code>markers</code>               (<code>Tuple[str, ...]</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of markers used for shape marker categories as strings, by default <code>CATEGORY.MARKERS</code>.</p> </li> <li> <code>n_size_bins</code>               (<code>int</code>, default:                   <code>N_SIZE_BINS</code> )           \u2013            <p>Number of bins for the size range, by default  <code>CATEGORY.N_SIZE_BINS</code>.</p> </li> <li> <code>axes</code>               (<code>AxesFacets</code>, default:                   <code>None</code> )           \u2013            <p>An instance containing the subplots' Axes and their arrangement. All further keyword arguments from here on will only be  considered if this one is not provided, by default None</p> </li> <li> <code>nrows</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of rows of subplots in the grid, by default 1.</p> </li> <li> <code>ncols</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of columns of subplots in the grid, by default 1.</p> </li> <li> <code>sharex</code>               (<code>bool or {none, all, row, col}</code>, default:                   <code>'none'</code> )           \u2013            <p>Controls sharing of properties along the x-axis, by default 'none'.</p> </li> <li> <code>sharey</code>               (<code>bool or {none, all, row, col}</code>, default:                   <code>'none'</code> )           \u2013            <p>Controls sharing of properties along the y-axis, by default 'none'.</p> </li> <li> <code>width_ratios</code>               (<code>array-like of length ncols</code>, default:                   <code>None</code> )           \u2013            <p>Relative widths of the columns, by default None.</p> </li> <li> <code>height_ratios</code>               (<code>array-like of length nrows</code>, default:                   <code>None</code> )           \u2013            <p>Relative heights of the rows, by default None.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional key word arguments to instantiate the <code>AxesFacets</code> object.</p> </li> </ul>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the  y-axis.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>  <code>abstractmethod</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.label","title":"<code>label(*, fig_title='', sub_title='', feature_label='', target_label='', info=False)</code>  <code>abstractmethod</code>","text":"<p>Add labels and titles to the chart.</p> <p>This method sets various labels and titles for the chart, including figure title, subplot title, axis labels, row and column titles, and additional information.</p> <p>Parameters:</p> <ul> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The main title for the entire figure, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The subtitle for the entire figure, by default ''.</p> </li> <li> <code>feature_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the feature variable (x-axis), by default ''. If set to True, the feature variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>target_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the target variable (y-axis), by default ''. If set to True, the target variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Additional information to display on the chart. If True, the date and user information will be automatically added at the lower left corner of the figure. If a string is provided, it will be shown next to the date and user, separated by a comma. By default, no additional information is displayed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The instance with updated labels and titles.</p> </li> </ul> Notes <p>This method allows customization of chart labels and titles to enhance readability and provide context for the visualized data.</p>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.plot","title":"<code>plot(plotter, *, kw_call={}, **kwds)</code>  <code>abstractmethod</code>","text":"<p>Plot the chart using the specified plotter.</p> <p>Parameters:</p> <ul> <li> <code>plotter</code>               (<code>Type[Plotter]</code>)           \u2013            <p>The plotter object.</p> </li> <li> <code>kw_call</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter call method.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the plotter object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The updated Chart object.</p> </li> </ul>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.stripes","title":"<code>stripes(stripes=[], **kwds)</code>  <code>abstractmethod</code>","text":"<p>Add stripes to the chart.</p> <p>Parameters:</p> <ul> <li> <code>kwds</code>           \u2013            <p>Additional keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The updated Chart object.</p> </li> </ul>"},{"location":"plotlib/chart/chart/#daspi.plotlib.chart.Chart.variate_data","title":"<code>variate_data(skip_variate=[])</code>  <code>abstractmethod</code>","text":"<p>Implement the data generator and add the currently yielded  data to self._data so that it can be used internally. Also  consider the <code>_kw_where</code> attribute to filter the data here for  the plots.</p> <p>Parameters:</p> <ul> <li> <code>skip_variate</code>               (<code>List[str]</code>, default:                   <code>[]</code> )           \u2013            <p>A list of variate names to skip during the grouping. If  provided, these variates will not be included in the  groupby operation. Default is [].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[DataFrame, Self, None]</code>           \u2013            <p>A generator object yielding DataFrames as subsets of the  source data, used as plotting data for each Axes.</p> </li> </ul>"},{"location":"plotlib/chart/joint-chart/","title":"Joint chart","text":""},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart","title":"<code>daspi.plotlib.chart.JointChart</code>","text":"<p>               Bases: <code>Chart</code></p> <p>Represents a joint chart visualization combining multiple  SingleCharts.</p> <p>Inherits from Chart.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>DataFrame</code>)           \u2013            <p>The source data.</p> </li> <li> <code>target</code>               (<code>str or Tuple[str]</code>)           \u2013            <p>The target variable(s).</p> </li> <li> <code>feature</code>               (<code>str or Tuple[str]</code>)           \u2013            <p>The feature variable(s).</p> </li> <li> <code>nrows</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of rows in the subplot grid.</p> </li> <li> <code>ncols</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of columns in the subplot grid.</p> </li> <li> <code>hue</code>               (<code>str or Tuple[str]</code>, default:                   <code>''</code> )           \u2013            <p>The hue variable(s), by default ''.</p> </li> <li> <code>shape</code>               (<code>str or Tuple[str]</code>, default:                   <code>''</code> )           \u2013            <p>The shape variable(s), by default ''.</p> </li> <li> <code>size</code>               (<code>str or Tuple[str]</code>, default:                   <code>''</code> )           \u2013            <p>The size variable(s), by default ''.</p> </li> <li> <code>dodge</code>               (<code>bool or Tuple[bool]</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether dodging is enabled, by default False.</p> </li> <li> <code>categorical_feature</code>               (<code>bool or Tuple[str]</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether feature is categorical, by default False.</p> </li> <li> <code>target_on_y</code>               (<code>bool or List[bool]</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether target is on y-axis, by default True.</p> </li> <li> <code>sharex</code>               (<code>ShareAxisProperty</code>, default:                   <code>'none'</code> )           \u2013            <p>Flag indicating whether x-axis should be shared among subplots, by default False.</p> </li> <li> <code>sharey</code>               (<code>ShareAxisProperty</code>, default:                   <code>'none'</code> )           \u2013            <p>Flag indicating whether y-axis should be shared among subplots, by default False.</p> </li> <li> <code>width_ratios</code>               (<code>List[float]</code>, default:                   <code>None</code> )           \u2013            <p>The width ratios for the subplot grid, by default None.</p> </li> <li> <code>height_ratios</code>               (<code>List[float]</code>, default:                   <code>None</code> )           \u2013            <p>The height ratios for the subplot grid, by default None.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> <li> <code>colors</code>               (<code>Tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of unique colors used for hue categories as hex or str, by default <code>CATEGORY.PALETTE</code>.</p> </li> <li> <code>markers</code>               (<code>Tuple[str, ...]</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of markers used for shape marker categories as strings, by default <code>CATEGORY.MARKERS</code>.</p> </li> <li> <code>n_size_bins</code>               (<code>int</code>, default:                   <code>N_SIZE_BINS</code> )           \u2013            <p>Number of bins for the size range, by default  <code>CATEGORY.N_SIZE_BINS</code>.</p> </li> <li> <code>**kwds</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for Chart initialization.</p> </li> </ul>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.label","title":"<code>label(*, fig_title='', sub_title='', feature_label='', target_label='', info=False, axes_titles=(), rows=(), cols=(), row_title='', col_title='')</code>","text":"<p>Add labels and titles to the chart.</p> <p>This method sets various labels and titles for the chart, including figure title, subplot title, axis labels, row and column titles, and additional information.</p> <p>Parameters:</p> <ul> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The main title for the entire figure, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The subtitle for the entire figure, by default ''.</p> </li> <li> <code>feature_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the feature variable (x-axis), by default ''. If set to True, the feature variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>target_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the target variable (y-axis), by default ''. If set to True, the target variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Additional information to display on the chart. If True, the date and user information will be automatically added at the lower left corner of the figure. If a string is provided, it will be shown next to the date and user, separated by a comma. By default, no additional information is displayed.</p> </li> <li> <code>axes_titles</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Title for each Axes, by default ()</p> </li> <li> <code>rows</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The row labels of the figure, by default ().</p> </li> <li> <code>cols</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The column labels of the figure, by default ().</p> </li> <li> <code>row_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the rows, by default ''.</p> </li> <li> <code>col_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the columns, by default ''.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JointChart</code>           \u2013            <p>The instance of the JointChart with updated labels and  titles.</p> </li> </ul> Notes <p>This method allows customization of chart labels and titles to enhance readability and provide context for the visualized data.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.plot","title":"<code>plot(plotter, *, kw_call={}, kw_where={}, on_last_axes=False, **kwds)</code>","text":"<p>Plot the data using the specified plotter.</p> <p>Parameters:</p> <ul> <li> <code>plotter</code>               (<code>Type[Plotter]</code>)           \u2013            <p>The plotter object.</p> </li> <li> <code>kw_call</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter call method.</p> </li> <li> <code>kw_where</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the where method used to filter the data.</p> </li> <li> <code>on_last_axes</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, plot on the last axes in the grid. If False, plot  on the next axes in the grid, by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the plotter object. Here  you can set the plotter specific initialization parameters.  You can also override the standard parameters color, marker,  target_on_y, size (marker size) and width  (for categorical feature plots).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JointChart</code>           \u2013            <p>The updated JointChart instance after plotting.</p> </li> </ul> Notes <p>Call the plot method for each individual Axes in the flattened  grid. You can specify the desired plotter for each chart  individually. The order of plotting corresponds to the flattened  arrangement of the subplots. Feel free to use this method to  create customized visualizations for each subplot.</p>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/chart/joint-chart/#daspi.plotlib.chart.JointChart.stripes","title":"<code>stripes(stripes=[], *, mean=False, median=False, control_limits=False, spec_limits=SpecLimits(), confidence=None, strategy='norm', agreement=6, **kwds)</code>","text":"<p>Plot location and spread width lines, specification limits  and/or confidence interval areas as stripes on each Axes. The location and spread (and their confidence bands) represent the  data per axes.</p> <p>Parameters:</p> <ul> <li> <code>stripes</code>               (<code>List[Stripe] | Tuple[List[Stripe]]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional non-predefined stripes to be added to the chart. Default is [].</p> </li> <li> <code>mean</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the mean value of the plotted data on the  axes, by default False.</p> </li> <li> <code>median</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the median value of the plotted data on the  axes, by default False.</p> </li> <li> <code>control_limits</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot control limits representing the process  spread, by default False.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>, default:                   <code>SpecLimits()</code> )           \u2013            <p>If provided, specifies the specification limits. Default is SpecLimits().</p> </li> <li> <code>confidence</code>               (<code>float | None | Tuple[float | None, ...]</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level between 0 and 1, by default None.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance  are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int | float | Tuple[int | float, ...]</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreementsigma,  e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 sigma)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for configuring StripesFacets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JointChart</code> (              <code>Self</code> )          \u2013            <p>The instance of the JointChart with the specified stripes  plotted on the axes.</p> </li> </ul> Notes <p>The given arguments are applied to all axes! If stripes should only be drawn on selected axes, select the  desired subchart via <code>charts</code> attributes. Then use its <code>stripes</code> method.</p> <p>This method plots stripes on the chart axes to represent  statistical measures such as mean, median, control limits, and  specification limits. The method provides options to customize  the appearance and behavior of the stripes using various  parameters and keyword arguments.</p>"},{"location":"plotlib/chart/multivariate-chart/","title":"Multivariate chart","text":""},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart","title":"<code>daspi.plotlib.chart.MultivariateChart</code>","text":"<p>               Bases: <code>SingleChart</code></p> <p>Represents a chart visualization that handles multiple variables simultaneously.</p> <p>This class extends the functionality of SingleChart to create  visualizations for multiple variables, allowing for comparisons and insights across different dimensions.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>DataFrame</code>)           \u2013            <p>The source data for the chart.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>The target variable (dependent variable).</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The feature variable (independent variable), by default ''.</p> </li> <li> <code>hue</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The hue variable (color grouping), by default ''.</p> </li> <li> <code>shape</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The shape variable (marker grouping), by default ''.</p> </li> <li> <code>size</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The size variable (marker size grouping), by default ''.</p> </li> <li> <code>col</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The column variable for facetting, by default ''.</p> </li> <li> <code>row</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The row variable for facetting, by default ''.</p> </li> <li> <code>dodge</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to dodge categorical variables, by default False.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> <li> <code>categorical_feature</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the feature variable is categorical. If <code>dodge</code> is True, this will be automatically set to True, by default False.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True</p> </li> <li> <code>colors</code>               (<code>Tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of unique colors used for hue categories as hex or str, by default <code>CATEGORY.PALETTE</code>.</p> </li> <li> <code>markers</code>               (<code>Tuple[str, ...]</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of markers used for shape marker categories as strings, by default <code>CATEGORY.MARKERS</code>.</p> </li> <li> <code>n_size_bins</code>               (<code>int</code>, default:                   <code>N_SIZE_BINS</code> )           \u2013            <p>Number of bins for the size range, by default  <code>CATEGORY.N_SIZE_BINS</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('iris')\n\nchart = dsp.MultivariateChart(\n        source=df,\n        target='length',\n        feature='width',\n        hue='species',\n        col='leaf',\n        markers=('x',)\n    ).plot(\n        dsp.GaussianKDEContour\n    ).plot(\n        dsp.Scatter\n    ).label(\n        feature_label='leaf width (cm)',\n        target_label='leaf length (cm)',\n    )\n</code></pre>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.ax","title":"<code>ax</code>  <code>property</code>","text":"<p>Gets the current Axes instance that is currently being worked  on. This property raises an AttributeError if the current axis  is not set. To access the current axis without errors but with  the possibility of returning None, use the <code>ax</code> property of the  <code>AxesFacets</code> instance (e.g. <code>chart.axes.ax</code>) (read-only).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.categorical_feature","title":"<code>categorical_feature = categorical_feature or dodge</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the features are categorical.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.col","title":"<code>col = col</code>  <code>instance-attribute</code>","text":"<p>The column variable for facetting (if applicable).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.col_labels","title":"<code>col_labels = self.unique_labels(self.col)</code>  <code>instance-attribute</code>","text":"<p>Labels corresponding to categorical values in the column  variable.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color for current variate (read-only).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.dodging","title":"<code>dodging = Dodger(dodge_categories, dodge_labels)</code>  <code>instance-attribute</code>","text":"<p>A handler for dodging categorical features along the axis.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.hue","title":"<code>hue = hue</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.hueing","title":"<code>hueing = HueLabel(labels=(self.unique_labels(self.hue)), colors=(self._colors), follow_order=(style.follow_palette_order))</code>  <code>instance-attribute</code>","text":"<p>A label handler for color differentiation based on the given hue variable column.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker for current variate (read-only)</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.row","title":"<code>row = row</code>  <code>instance-attribute</code>","text":"<p>The row variable for facetting (if applicable).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.row_labels","title":"<code>row_labels = self.unique_labels(self.row)</code>  <code>instance-attribute</code>","text":"<p>Labels corresponding to categorical values in the row variable.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.row_or_col_changed","title":"<code>row_or_col_changed</code>  <code>property</code>","text":"<p>Check whether the current variate belongs to a new row  or column relative to the last variate</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.shape","title":"<code>shape = shape</code>  <code>instance-attribute</code>","text":"<p>The categorical shape variable (column) for marker differentiation.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.shaping","title":"<code>shaping = ShapeLabel(self.unique_labels(self.shape), self._markers)</code>  <code>instance-attribute</code>","text":"<p>A label handler for marker shapes based on the given shape variable (column).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.size","title":"<code>size = size</code>  <code>instance-attribute</code>","text":"<p>The numeric variable (column) from which the marker size is derived.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.sizes","title":"<code>sizes</code>  <code>property</code>","text":"<p>Get sizes for current variate, is set in grouped data  generator (read-only).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.sizing","title":"<code>sizing</code>  <code>instance-attribute</code>","text":"<p>A label handler for marker sizes based on the given size variable (column).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the  y-axis.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.variate_names","title":"<code>variate_names</code>  <code>property</code>","text":"<p>Get names of all set variates (read-only).</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.     - If a string is passed, it will be taken.     - If True, labels of given feature or target name are used.     - If False or None, empty string is used.</p> <p>Parameters:</p> <ul> <li> <code>feature_label</code>               (<code>bool | str | None</code>)           \u2013            <p>Flag or label for the feature variable.</p> </li> <li> <code>target_label</code>               (<code>bool | str | None</code>)           \u2013            <p>Flag or label for the target variable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[str, str]</code>           \u2013            <p>A tuple containing the x-axis label (xlabel) and y-axis  label (ylabel).</p> </li> </ul>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.dodge","title":"<code>dodge()</code>","text":"<p>Converts the feature data to tick positions, taking dodging  into account.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.label","title":"<code>label(*, fig_title='', sub_title='', feature_label='', target_label='', info=False, row_title='', col_title='', feature_formatter=None, target_formatter=None, feature_angle=0.0, target_angle=0.0, feature_align='center', target_align='center')</code>","text":"<p>Add labels and titles to the multivariate chart with advanced  formatting.</p> <p>This method sets various labels and titles for the multivariate chart, including figure title, subtitle, axis labels, row and column titles, and provides extensive formatting control for tick labels across all subplots in the faceted grid.</p> <p>Parameters:</p> <ul> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The main title for the entire figure, displayed at the top, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The subtitle for the entire figure, displayed below the main title, by default ''.</p> </li> <li> <code>feature_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the feature variable axis across all subplots, by default ''. If set to True, the feature variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>target_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the target variable axis across all subplots, by default ''. If set to True, the target variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Additional information to display on the chart. If True, the date and user information will be automatically added at the lower left corner of the figure. If a string is provided, it will be shown next to the date and user, separated by a comma. By default, no additional information is displayed.</p> </li> <li> <code>row_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title for the row facet variable, displayed on the right side of the figure. If not provided and row faceting is used, the row variable name will be used automatically, by default ''.</p> </li> <li> <code>col_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title for the column facet variable, displayed at the top of the figure above the column labels. If not provided and column faceting is used, the column variable name will be used automatically, by default ''.</p> </li> <li> <code>feature_formatter</code>               (<code>Formatter | Callable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Formatter for the feature axis tick labels applied to all subplots that share the feature axis. Supports multiple input types for maximum flexibility:</p> <ul> <li>String format templates: Simple format strings using    Python's string formatting syntax (e.g., '{:.2f}', '{:.1e}',   '${:.0f}', '{:.1%}')</li> <li>Callable functions: Custom functions that take one or two   arguments and return formatted strings  </li> <li>Matplotlib Formatters: Any matplotlib.ticker.Formatter   instance for advanced formatting control</li> <li>None: Use matplotlib's default formatting</li> </ul> <p>Applied consistently across all subplots for uniform appearance. By default, None.</p> </li> <li> <code>target_formatter</code>               (<code>Formatter | Callable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Formatter for the target axis tick labels applied to all subplots that share the target axis. Same options and behavior as feature_formatter. By default, None.</p> </li> <li> <code>feature_angle</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Rotation angle for feature axis tick labels in degrees, applied to all subplots. Positive values rotate counter-clockwise, negative values rotate clockwise. The chart automatically adjusts margins to accommodate rotated labels across the entire grid. By default, 0.0 (no rotation).</p> </li> <li> <code>target_angle</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Rotation angle for target axis tick labels in degrees, applied to all subplots. Same behavior as feature_angle but for the target axis. By default, 0.0 (no rotation).</p> </li> <li> <code>feature_align</code>               (<code>(center, right, left)</code>, default:                   <code>'center'</code> )           \u2013            <p>Alignment for feature axis tick labels applied to all subplots that share the feature axis. 'center' aligns the label center with the tick, 'left' aligns the left edge, 'right' aligns the right edge. Particularly useful with rotated labels. By default, 'center'.</p> </li> <li> <code>target_align</code>               (<code>(center, right, left)</code>, default:                   <code>'center'</code> )           \u2013            <p>Alignment for target axis tick labels applied to all subplots that share the target axis. For horizontal target axes, this controls horizontal alignment. For vertical target axes, this maps to vertical alignment: 'center' centers the label, 'left' maps to 'bottom', 'right' maps to 'top'.  By default, 'center'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MultivariateChart</code>           \u2013            <p>The instance of the MultivariateChart with updated labels and titles for method chaining.</p> </li> </ul> <p>Examples:</p> <p>Basic multivariate chart labeling:</p> <pre><code>chart.label(\n    fig_title='Sales Analysis by Region and Quarter',\n    sub_title='2024 Performance Data',\n    feature_label='Sales Amount ($)',\n    target_label='Customer Count',\n    row_title='Geographic Region',\n    col_title='Quarter',\n    info='Source: Sales database'\n)\n</code></pre> <p>Formatting across all subplots:</p> <pre><code># Currency formatting for feature, percentage for target\nchart.label(\n    feature_formatter='${:,.0f}',  # $1,234\n    target_formatter='{:.1%}',     # 12.3%\n    feature_angle=30,              # Rotate currency labels\n    feature_align='right'          # Right-align rotated labels\n)\n</code></pre> <p>Custom formatters for scientific data:</p> <pre><code>def scientific_formatter(value):\n    if abs(value) &gt;= 1000:\n        return f'{value:.1e}'  # Scientific notation\n    return f'{value:.2f}'      # Regular decimal\n\nchart.label(\n    fig_title='Experimental Results',\n    feature_formatter=scientific_formatter,\n    target_formatter='{:.3f}',\n    col_title='Treatment Group',\n    row_title='Time Point'\n)\n</code></pre> <p>Handling long category names in faceted plots:</p> <pre><code>chart.label(\n    fig_title='Product Performance Analysis',\n    feature_formatter=lambda x: x.replace('_', ' ').title(),\n    feature_angle=45,              # Diagonal for readability\n    feature_align='right',         # Better alignment when rotated\n    target_formatter='${:,.0f}K',  # Thousands with currency\n    row_title='Product Category',\n    col_title='Sales Channel'\n)\n</code></pre> Notes <ul> <li>All formatting options are applied consistently across the   entire subplot grid for uniform appearance</li> <li>Row and column titles are automatically inferred from faceting   variables if not explicitly provided</li> <li>The chart automatically adjusts spacing and margins to accommodate   rotated labels across all subplots</li> <li>String formatters are automatically converted to matplotlib-compatible   formatters and applied to all relevant axes</li> <li>Formatting respects axis sharing - shared axes get consistent    formatting</li> </ul>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.plot","title":"<code>plot(plotter, *, skip_variate=[], kw_call={}, kw_where={}, **kwds)</code>","text":"<p>Plot the chart using the specified plotter.</p> <p>This method generates a subset of the source data specific to  each axes and then uses this data for the specified plotter.</p> <p>Parameters:</p> <ul> <li> <code>plotter</code>               (<code>Type[Plotter]</code>)           \u2013            <p>The type of plotter to use.</p> </li> <li> <code>skip_variate</code>               (<code>List[str]</code>, default:                   <code>[]</code> )           \u2013            <p>A list of variate names to skip during the grouping. If  provided, these variates will not be included in the groupby  operation. Default is None</p> </li> <li> <code>kw_call</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter call method.</p> </li> <li> <code>kw_where</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Do not use this argument in this instance.</p> </li> <li> <code>**kwds</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter object. Here  you can set the plotter specific initialization parameters.  Do not override the standard parameters color, marker,  target_on_y, size (marker size) and width  (for categorical feature plots). These parameters are  handled automatically by the class. For more flexibility,  use the JointChart class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The updated MultivariateChart object.</p> </li> </ul>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.stripes","title":"<code>stripes(stripes=[], *, mean=False, median=False, control_limits=False, spec_limits=SpecLimits(), confidence=None, strategy='norm', agreement=6, **kwds)</code>","text":"<p>Plot location and spread width lines, specification limits  and/or confidence interval areas as stripes on each Axes. The location and spread (and their confidence bands) represent the  data per axes.</p> <p>Parameters:</p> <ul> <li> <code>stripes</code>               (<code>List[Stripe]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional non-predefined stripes to be added to the chart, by default [].</p> </li> <li> <code>mean</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the mean value of the plotted data on the  axes, by default False.</p> </li> <li> <code>median</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the median value of the plotted data on the  axes, by default False.</p> </li> <li> <code>control_limits</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot control limits representing the process  spread, by default False.</p> </li> <li> <code>spec_limits</code>               (<code>Tuple[float]</code>, default:                   <code>SpecLimits()</code> )           \u2013            <p>If provided, specifies the specification limits. Default is SpecLimits().</p> </li> <li> <code>confidence</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level between 0 and 1, by default None.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance  are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int or float</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreementsigma,  e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 sigma)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for configuring StripesFacets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SingleChart</code>           \u2013            <p>The instance of the SingleChart with the specified stripes plotted on the axes.</p> </li> </ul> Notes <p>This method plots stripes on the chart axes to represent statistical measures such as mean, median, control limits, and specification limits. The method provides options to customize the appearance and behavior of the stripes using various parameters and keyword arguments.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.unique_labels","title":"<code>unique_labels(colname)</code>","text":"<p>Get sorted unique elements of given column name if in source.</p> <p>Parameters:</p> <ul> <li> <code>colname</code>               (<code>str</code>)           \u2013            <p>The name of the column in the source DataFrame.</p> </li> </ul> Returns: <p>Tuple:     Sorted unique elements of the given column name.</p>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.update_variate","title":"<code>update_variate(combination)</code>","text":"<p>Update current variate by given combination coming from  pandas DataFrame groupby function.</p> <p>Parameters:</p> <ul> <li> <code>combination</code>               (<code>Any</code>)           \u2013            <p>The combination of variables coming from the DataFrame  groupby function.</p> </li> </ul>"},{"location":"plotlib/chart/multivariate-chart/#daspi.plotlib.chart.MultivariateChart.variate_data","title":"<code>variate_data(skip_variate=[])</code>","text":"<p>Generate grouped data if <code>variate_names</code> are set, otherwise  yield the entire source DataFrame.</p> <p>This method serves as a generator function that yields grouped  data based on the <code>variate_names</code> attribute if it is set.  If no <code>variate_names</code> are specified, it yields the entire source  DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>skip_variate</code>               (<code>List[str]</code>, default:                   <code>[]</code> )           \u2013            <p>A list of variate names to skip during the grouping. If  provided, these variates will not be included in the groupby  operation. Default is []</p> </li> </ul> Yields: <p>self._data : DataFrame     Containing the grouped data or the entire source DataFrame.</p>"},{"location":"plotlib/chart/single-chart/","title":"Single chart","text":""},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart","title":"<code>daspi.plotlib.chart.SingleChart</code>","text":"<p>               Bases: <code>Chart</code></p> <p>Represents a basic chart visualization with customizable features.</p> <p>This class provides a foundation for creating customizable chart visualizations. Customize the appearance and behavior of the chart using various parameters and keyword arguments.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>The target variable (column) to visualize.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The feature variable (column) to use for the visualization, by default ''</p> </li> <li> <code>hue</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The hue variable (column) for color differentiation, by default ''</p> </li> <li> <code>dodge</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to move overlapping categorical features with different colors along the axis so that they appear separately. Should only be set to True if given feature is categorical, by default False</p> </li> <li> <code>shape</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The categorical shape variable (column) for marker differentiation, by default ''.</p> </li> <li> <code>size</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The numeric variable (column) from which the marker size is derived. The range (minimum to maximum) of the variable is mapped to the marker size, by default ''</p> </li> <li> <code>categorical_feature</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether the features are categorical. If True, the feature values are transferred to the feature axis and the major grid is removed. However, a minor grid is created so that the categories are visually better separated. This attribute is set to True if <code>dodge</code> is set to True, by default False.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True</p> </li> <li> <code>colors</code>               (<code>Tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of unique colors used for hue categories as hex or str, by default <code>CATEGORY.PALETTE</code>.</p> </li> <li> <code>markers</code>               (<code>Tuple[str, ...]</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of markers used for shape marker categories as strings, by default <code>CATEGORY.MARKERS</code>.</p> </li> <li> <code>n_size_bins</code>               (<code>int</code>, default:                   <code>N_SIZE_BINS</code> )           \u2013            <p>Number of bins for the size range, by default  <code>CATEGORY.N_SIZE_BINS</code>.</p> </li> <li> <code>axes</code>               (<code>AxesFacets</code>, default:                   <code>None</code> )           \u2013            <p>An instance containing the subplots' Axes and their arrangement. All further keyword arguments from here on will only be  considered if this one is not provided, by default None</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional key word arguments to instantiate the <code>AxesFacets</code> object.</p> </li> </ul>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.ax","title":"<code>ax</code>  <code>property</code>","text":"<p>Gets the current Axes instance that is currently being worked  on. This property raises an AttributeError if the current axis  is not set. To access the current axis without errors but with  the possibility of returning None, use the <code>ax</code> property of the  <code>AxesFacets</code> instance (e.g. <code>chart.axes.ax</code>) (read-only).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.categorical_feature","title":"<code>categorical_feature = categorical_feature or dodge</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the features are categorical.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color for current variate (read-only).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.dodging","title":"<code>dodging = Dodger(dodge_categories, dodge_labels)</code>  <code>instance-attribute</code>","text":"<p>A handler for dodging categorical features along the axis.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.hue","title":"<code>hue = hue</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.hueing","title":"<code>hueing = HueLabel(labels=(self.unique_labels(self.hue)), colors=(self._colors), follow_order=(style.follow_palette_order))</code>  <code>instance-attribute</code>","text":"<p>A label handler for color differentiation based on the given hue variable column.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker for current variate (read-only)</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.shape","title":"<code>shape = shape</code>  <code>instance-attribute</code>","text":"<p>The categorical shape variable (column) for marker differentiation.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.shaping","title":"<code>shaping = ShapeLabel(self.unique_labels(self.shape), self._markers)</code>  <code>instance-attribute</code>","text":"<p>A label handler for marker shapes based on the given shape variable (column).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.size","title":"<code>size = size</code>  <code>instance-attribute</code>","text":"<p>The numeric variable (column) from which the marker size is derived.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.sizes","title":"<code>sizes</code>  <code>property</code>","text":"<p>Get sizes for current variate, is set in grouped data  generator (read-only).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.sizing","title":"<code>sizing</code>  <code>instance-attribute</code>","text":"<p>A label handler for marker sizes based on the given size variable (column).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the  y-axis.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.variate_names","title":"<code>variate_names</code>  <code>property</code>","text":"<p>Get names of all set variates (read-only).</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.     - If a string is passed, it will be taken.     - If True, labels of given feature or target name are used.     - If False or None, empty string is used.</p> <p>Parameters:</p> <ul> <li> <code>feature_label</code>               (<code>bool | str | None</code>)           \u2013            <p>Flag or label for the feature variable.</p> </li> <li> <code>target_label</code>               (<code>bool | str | None</code>)           \u2013            <p>Flag or label for the target variable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[str, str]</code>           \u2013            <p>A tuple containing the x-axis label (xlabel) and y-axis  label (ylabel).</p> </li> </ul>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.dodge","title":"<code>dodge()</code>","text":"<p>Converts the feature data to tick positions, taking dodging  into account.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.label","title":"<code>label(*, fig_title='', sub_title='', feature_label='', target_label='', info=False, feature_formatter=None, target_formatter=None, feature_angle=0.0, target_angle=0.0, feature_align='center', target_align='center')</code>","text":"<p>Add labels and titles to the chart with advanced formatting  options.</p> <p>This method sets various labels and titles for the chart, including figure title, subtitle, axis labels, and provides extensive formatting control for tick labels including custom formatters, rotation angles, and alignment options.</p> <p>Parameters:</p> <ul> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The main title for the entire figure, displayed at the top in a larger font, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The subtitle for the entire figure, displayed below the main title in a smaller font, by default ''.</p> </li> <li> <code>feature_label</code>               (<code>str | bool</code>, default:                   <code>''</code> )           \u2013            <p>The label for the feature variable axis, by default ''. If set to True, the feature variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>target_label</code>               (<code>str | bool</code>, default:                   <code>''</code> )           \u2013            <p>The label for the target variable axis, by default ''. If set to True, the target variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Additional information to display on the chart. If True, the date and user information will be automatically added at the lower left corner of the figure. If a string is provided, it will be shown next to the date and user, separated by a comma. By default, no additional information is displayed.</p> </li> <li> <code>feature_formatter</code>               (<code>Formatter | Callable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Formatter for the feature axis tick labels. Supports  multiple input types for maximum flexibility:</p> <ul> <li>String format templates: Simple format strings using    Python's string formatting syntax (e.g., '{:.2f}',    '{:.1e}', '${:.0f}', '{:.1%}')</li> <li>Callable functions: Custom functions that take one or    two arguments and return formatted strings  </li> <li>Matplotlib Formatters: Any matplotlib.ticker.Formatter   instance for advanced formatting control</li> <li>None: Use matplotlib's default formatting</li> </ul> <p>The formatter automatically handles different orientations (target_on_y=True/False) and applies to the appropriate axis. By default, None.</p> </li> <li> <code>target_formatter</code>               (<code>Formatter | Callable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Formatter for the target axis tick labels. Same options and behavior as feature_formatter. By default, None.</p> </li> <li> <code>feature_angle</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Rotation angle for feature axis tick labels in degrees. Positive values rotate counter-clockwise, negative values rotate clockwise. The chart automatically adjusts margins to accommodate rotated labels to prevent clipping. Common values: 0 (horizontal), 45 (diagonal), 90 (vertical). By default, 0.0 (no rotation).</p> </li> <li> <code>target_angle</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Rotation angle for target axis tick labels in degrees. Same behavior as feature_angle but for the target axis. By default, 0.0 (no rotation).</p> </li> <li> <code>feature_align</code>               (<code>(center, right, left)</code>, default:                   <code>'center'</code> )           \u2013            <p>Horizontal alignment for feature axis tick labels relative to their tick marks. 'center' aligns the label center with  the tick, 'left' aligns the left edge, 'right' aligns the  right edge. Particularly useful with rotated labels to achieve optimal positioning. By default, 'center'.</p> </li> <li> <code>target_align</code>               (<code>(center, right, left)</code>, default:                   <code>'center'</code> )           \u2013            <p>Alignment for target axis tick labels. For horizontal target axes, this controls horizontal alignment. For vertical  target axes, this maps to vertical alignment: 'center' centers the label, 'left' maps to 'bottom', 'right' maps to 'top'. By default, 'center'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SingleChart</code>           \u2013            <p>The instance of the SingleChart with updated labels and  titles for method chaining.</p> </li> </ul> <p>Examples:</p> <p>Basic labeling:</p> <pre><code>chart.label(\n    fig_title='Temperature Analysis',\n    sub_title='Daily measurements',\n    feature_label='Time (hours)',\n    target_label='Temperature (\u00b0C)',\n    info='Data collected in laboratory conditions'\n)\n</code></pre> <p>String formatter examples:</p> <pre><code># Scientific notation\nchart.label(\n    feature_formatter='{:.2e}',  # 1.23e+03\n    target_formatter='{:.1f}'    # 123.5\n)\n\n# Currency and percentage formatting\nchart.label(\n    feature_formatter='${:.0f}',  # $1234\n    target_formatter='{:.1%}'     # 12.3%\n)\n</code></pre> <p>Custom callable formatters:</p> <pre><code># Temperature formatter\ndef temp_formatter(value):\n    return f\"{value:.1f}\u00b0C\"\n\n# Business formatter with units\ndef business_formatter(value, pos=None):\n    if value &gt;= 1000000:\n        return f'{value/1000000:.1f}M'\n    elif value &gt;= 1000:\n        return f'{value/1000:.1f}K'\n    return f'{value:.0f}'\n\nchart.label(\n    target_formatter=temp_formatter,\n    feature_formatter=business_formatter\n)\n</code></pre> <p>Rotation and alignment for crowded labels:</p> <pre><code># Diagonal labels with right alignment\nchart.label(\n    feature_angle=45,\n    feature_align='right',\n    target_angle=0,\n    target_align='center'\n)\n\n# Vertical labels for long category names\nchart.label(\n    feature_angle=90,\n    feature_align='center'\n)\n</code></pre> <p>Combined advanced formatting:</p> <pre><code>chart.label(\n    fig_title='Sales Performance Q3 2024',\n    sub_title='Revenue by Product Category',\n    feature_label='Product Categories',\n    target_label='Revenue',\n    feature_formatter=lambda x: x.title(),  # Capitalize categories\n    target_formatter='${:,.0f}',           # Currency with commas\n    feature_angle=30,                      # Slight rotation\n    feature_align='right',                 # Right-align for rotation\n    info='Data from sales database'\n)\n</code></pre> Notes <ul> <li>String formatters use Python's string formatting syntax and are   automatically converted to matplotlib-compatible formatters</li> <li>The chart automatically adjusts margins when using rotated labels   to prevent clipping</li> <li>Formatters and angles are applied based on the chart orientation   (target_on_y parameter)</li> <li>All formatting options work consistently across different plot types</li> </ul>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.plot","title":"<code>plot(plotter, *, skip_variate=[], kw_call={}, kw_where={}, **kwds)</code>","text":"<p>Apply a plotter with the specified data on the axis.</p> <p>Parameters:</p> <ul> <li> <code>plotter</code>               (<code>Type[Plotter]</code>)           \u2013            <p>The plotter object.</p> </li> <li> <code>skip_variate</code>               (<code>List[str]</code>, default:                   <code>[]</code> )           \u2013            <p>A list of variate names to skip during the grouping. If  provided, these variates will not be included in the groupby  operation. Default is []</p> </li> <li> <code>kw_call</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter call method.</p> </li> <li> <code>kw_where</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the where method used to filter the data.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the plotter object. Here  you can set the plotter specific initialization parameters.  You can also override the standard parameters color, marker,  target_on_y, size (marker size) and width  (for categorical feature plots). These parameters are  handled automatically by the class. Only change them if you  know what you are doing.</p> </li> </ul> Returns: <p>Self:     The SingleChart instance.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.stripes","title":"<code>stripes(stripes=[], *, mean=False, median=False, control_limits=False, spec_limits=SpecLimits(), confidence=None, strategy='norm', agreement=6, **kwds)</code>","text":"<p>Plot location and spread width lines, specification limits  and/or confidence interval areas as stripes on each Axes. The location and spread (and their confidence bands) represent the  data per axes.</p> <p>Parameters:</p> <ul> <li> <code>stripes</code>               (<code>List[Stripe]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional non-predefined stripes to be added to the chart, by default [].</p> </li> <li> <code>mean</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the mean value of the plotted data on the  axes, by default False.</p> </li> <li> <code>median</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the median value of the plotted data on the  axes, by default False.</p> </li> <li> <code>control_limits</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot control limits representing the process  spread, by default False.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits</code>, default:                   <code>SpecLimits()</code> )           \u2013            <p>If provided, specifies the specification limits.  Default is SpecLimits(float('-inf'), float('inf')).</p> </li> <li> <code>confidence</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level between 0 and 1, by default None.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance  are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int or float</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreementsigma,  e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 sigma)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for configuring StripesFacets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SingleChart</code> (              <code>Self</code> )          \u2013            <p>The instance of the SingleChart with the specified stripes  plotted on the axes.</p> </li> </ul> Notes <p>This method plots stripes on the chart axes to represent  statistical measures such as mean, median, control limits, and  specification limits. The method provides options to customize  the appearance and behavior of the stripes using various  parameters and keyword arguments.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.unique_labels","title":"<code>unique_labels(colname)</code>","text":"<p>Get sorted unique elements of given column name if in source.</p> <p>Parameters:</p> <ul> <li> <code>colname</code>               (<code>str</code>)           \u2013            <p>The name of the column in the source DataFrame.</p> </li> </ul> Returns: <p>Tuple:     Sorted unique elements of the given column name.</p>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.update_variate","title":"<code>update_variate(combination)</code>","text":"<p>Update current variate by given combination coming from  pandas DataFrame groupby function.</p> <p>Parameters:</p> <ul> <li> <code>combination</code>               (<code>Any</code>)           \u2013            <p>The combination of variables coming from the DataFrame  groupby function.</p> </li> </ul>"},{"location":"plotlib/chart/single-chart/#daspi.plotlib.chart.SingleChart.variate_data","title":"<code>variate_data(skip_variate=[])</code>","text":"<p>Generate grouped data if <code>variate_names</code> are set, otherwise  yield the entire source DataFrame.</p> <p>This method serves as a generator function that yields grouped  data based on the <code>variate_names</code> attribute if it is set.  If no <code>variate_names</code> are specified, it yields the entire source  DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>skip_variate</code>               (<code>List[str]</code>, default:                   <code>[]</code> )           \u2013            <p>A list of variate names to skip during the grouping. If  provided, these variates will not be included in the groupby  operation. Default is []</p> </li> </ul> Yields: <p>self._data : DataFrame     Containing the grouped data or the entire source DataFrame.</p>"},{"location":"plotlib/facets/","title":"Facets Module","text":""},{"location":"plotlib/facets/#daspi.plotlib.facets","title":"<code>daspi.plotlib.facets</code>","text":""},{"location":"plotlib/facets/axes-facets/","title":"Axes facets","text":""},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets","title":"<code>daspi.plotlib.facets.AxesFacets</code>","text":"<p>A class for creating a grid of subplots with customizable sharing and sizing options.    </p> <p>The class provides flexible handling the created Axes instances  through its flat property and iteration capabilities:</p> <ul> <li>Flat property:    Accesses Axes in a flattened view from left-to-right,    top-to-bottom</li> <li>Axes property:    Maintains the 2D structure for grid-based operations</li> <li>Iteration:    Yields each axis instance coming from the Flat property    sequentially to simplify plotting The class supports two different ways to create subplot layouts:</li> </ul> <p>Parameters:</p> <ul> <li> <code>nrows</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of rows of subplots in the grid, by default 1.</p> </li> <li> <code>ncols</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of columns of subplots in the grid, by default 1.</p> </li> <li> <code>sharex</code>               (<code>bool or {none, all, row, col}</code>, default:                   <code>'none'</code> )           \u2013            <p>Controls sharing of properties along the x-axis, by default 'none'.</p> </li> <li> <code>sharey</code>               (<code>bool or {none, all, row, col}</code>, default:                   <code>'none'</code> )           \u2013            <p>Controls sharing of properties along the y-axis, by default 'none'.</p> </li> <li> <code>width_ratios</code>               (<code>array-like of length ncols</code>, default:                   <code>None</code> )           \u2013            <p>Relative widths of the columns, by default None.</p> </li> <li> <code>height_ratios</code>               (<code>array-like of length nrows</code>, default:                   <code>None</code> )           \u2013            <p>Relative heights of the rows, by default None.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> <li> <code>**kwds</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the function  <code>plt.subplots</code> or to the function <code>plt.subplot_mosaic</code> if a  mosaic was specified.</p> </li> </ul> <p>Examples:</p> <ol> <li> <p>Using nrows and ncols: Creates a regular grid of subplots with specified dimensions <pre><code># Creates a 2x3 grid of regular subplots\nfacets = AxesFacets(nrows=2, ncols=3)\n</code></pre></p> </li> <li> <p>Using mosaic: Creates a layout with custom subplot arrangements and spanning <pre><code>import daspi as dsp\n# Creates a layout with spanning cells\nlayout = (\n    'AAB',\n    'CDB')\nfacets = dsp.AxesFacets(mosaic=layout)\n</code></pre></p> </li> <li> <p>Create a seaborn-style jointplot layout with custom size ratios: <pre><code>import daspi as dsp\n# Creates a layout with main scatter plot and marginal distributions\nlayout = [\n    ['hist_x', '.'],      # '.' creates an empty/blank Axes\n    ['scatter', 'hist_y']]\nfacets = AxesFacets(\n    mosaic=layout,\n    width_ratios=[4, 1],   # Make the marginal y-hist narrower\n    height_ratios=[1, 4]   # Make the marginal x-hist shorter\n    )\n</code></pre></p> </li> </ol> <p>This creates a figure with: - A main scatter plot in the bottom-left - A marginal histogram on top for x-distribution - A marginal histogram on right for y-distribution - Top-right cell is automatically empty using the '.' notation - Proportional spacing using width and height ratios</p> <p>The '.' character is a special notation in matplotlib's mosaic layout  that automatically creates an empty/invisible Axes, which is more  efficient than creating a visible Axes and then hiding it.</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.ax","title":"<code>ax</code>  <code>property</code>","text":"<p>Get the axes that is currently being worked on. This property is automatically kept current when iterating through this  class (read-only).</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>A 2D array containing the Axes instances of the figure.</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.figsize","title":"<code>figsize = (stretch_x * figsize[0], stretch_y * figsize[1])</code>  <code>instance-attribute</code>","text":"<p>The figsize passed when creating the subplots.</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.figure","title":"<code>figure</code>  <code>instance-attribute</code>","text":"<p>The figure instance to label.</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.flat","title":"<code>flat</code>  <code>property</code>","text":"<p>Get a list of all the Axes in the grid.</p> <p>Returns:</p> <ul> <li> <code>List[Axes]</code>           \u2013            <p>A list of all the Axes in the grid.</p> </li> </ul>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.mosaic","title":"<code>mosaic</code>  <code>instance-attribute</code>","text":"<p>A visual layout of how the Axes are arranged labeled as strings.</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.ncols","title":"<code>ncols</code>  <code>property</code>","text":"<p>Get the number of Axes columns in the grid (read-only).</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.nrows","title":"<code>nrows</code>  <code>property</code>","text":"<p>Get the number of Axes rows in the grid (read-only).</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the axes array (read-only).</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.sharex","title":"<code>sharex</code>  <code>property</code>","text":"<p>Get the sharing of properties along the x-axis (read-only).</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.sharey","title":"<code>sharey</code>  <code>property</code>","text":"<p>Get the sharing of properties along the y-axis (read-only).</p>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.__getitem__","title":"<code>__getitem__(index)</code>","text":"<pre><code>__getitem__(index: Tuple[slice, slice]) -&gt; NDArray\n</code></pre><pre><code>__getitem__(index: Tuple[int, slice]) -&gt; NDArray\n</code></pre><pre><code>__getitem__(index: Tuple[slice, int]) -&gt; NDArray\n</code></pre><pre><code>__getitem__(index: int | Tuple[int, int]) -&gt; Axes\n</code></pre> <p>Get the axes at the specified index in the grid. If the index is a number, the axes are fetched from left to right and from  top to bottom. If two numbers are specified, the axis is fetched  directly in the grid and it is then also possible to fetch an  axis across multiple indices if the axis is spanned across  multiple columns or rows.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int | Tuple[int, int]</code>)           \u2013            <p>The index of the axes in the grid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>The axes at the given index in the grid.</p> </li> </ul>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the axes in the grid.</p> <p>Returns:</p> <ul> <li> <code>Generator[Axes, Self, None]</code>           \u2013            <p>The generator object that yields the axes in the grid.</p> </li> </ul>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.__len__","title":"<code>__len__()</code>","text":"<p>Get the total number of axes in the grid.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The total number of axes in the grid.</p> </li> </ul>"},{"location":"plotlib/facets/axes-facets/#daspi.plotlib.facets.AxesFacets.__next__","title":"<code>__next__()</code>","text":"<p>Get the next axes in the grid.</p> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>The next axes in the grid.</p> </li> </ul>"},{"location":"plotlib/facets/label-facets/","title":"Label facets","text":""},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets","title":"<code>daspi.plotlib.facets.LabelFacets</code>","text":"<p>A class for adding labels and titles to facets of a figure with  advanced formatting.</p> <p>This class provides comprehensive labeling and formatting capabilities for matplotlib figures, including support for custom formatters, label  rotation, alignment control, and automatic margin adjustment for optimal layout.</p> <p>Parameters:</p> <ul> <li> <code>axes</code>               (<code>AxesFacets</code>)           \u2013            <p>A AxesFacets instance containing the subplots' Axes and their  arrangement.</p> </li> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Main title that should be displayed at the top of the chart, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Subtitle, which should appear directly below the main title and slightly smaller than it, by default ''.</p> </li> <li> <code>xlabel</code>               (<code>str | Tuple[str, ...]</code>, default:                   <code>''</code> )           \u2013            <p>The axis label(s) of the figure. To label multiple axes with  different names, provide a tuple; otherwise, provide a string, by default ''.</p> </li> <li> <code>ylabel</code>               (<code>str | Tuple[str, ...]</code>, default:                   <code>''</code> )           \u2013            <p>The axis label(s) of the figure. To label multiple axes with  different names, provide a tuple; otherwise, provide a string, by default ''.</p> </li> <li> <code>xlabel_formatter</code>               (<code>Formatter | Callable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Advanced formatters for axis tick labels with multiple input  types:</p> <ul> <li>String format templates: Simple format strings using    Python's string formatting syntax (e.g., '{:.2f}', '{:.1e}',   '${:.0f}', '{:.1%}') for quick and intuitive formatting</li> <li>Callable functions: Custom functions that take one   argument (value) or two arguments (value, position) and return    formatted strings for complete control</li> <li>Matplotlib Formatters: Any matplotlib.ticker.Formatter   instance for advanced formatting scenarios</li> <li>None: Use matplotlib's default formatting</li> </ul> <p>The formatter automatically handles matplotlib compatibility by wrapping simple callables in FuncFormatter and converting string templates to appropriate formatter types. By default, None.</p> </li> <li> <code>ylabel_formatter</code>               (<code>Formatter | Callable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Advanced formatters for axis tick labels with multiple input  types:</p> <ul> <li>String format templates: Simple format strings using    Python's string formatting syntax (e.g., '{:.2f}', '{:.1e}',   '${:.0f}', '{:.1%}') for quick and intuitive formatting</li> <li>Callable functions: Custom functions that take one   argument (value) or two arguments (value, position) and return    formatted strings for complete control</li> <li>Matplotlib Formatters: Any matplotlib.ticker.Formatter   instance for advanced formatting scenarios</li> <li>None: Use matplotlib's default formatting</li> </ul> <p>The formatter automatically handles matplotlib compatibility by wrapping simple callables in FuncFormatter and converting string templates to appropriate formatter types. By default, None.</p> </li> <li> <code>xlabel_angle</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Rotation angle for x and y axis tick labels in degrees. Positive values rotate counter-clockwise, negative values rotate clockwise. The chart automatically adjusts margins to accommodate rotated labels and prevent clipping. Common values:  0 (horizontal), 45 (diagonal), 90 (vertical). By default, 0.</p> </li> <li> <code>ylabel_angle</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Rotation angle for x and y axis tick labels in degrees. Positive values rotate counter-clockwise, negative values rotate clockwise. The chart automatically adjusts margins to accommodate rotated labels and prevent clipping. Common values:  0 (horizontal), 45 (diagonal), 90 (vertical). By default, 0.</p> </li> <li> <code>xlabel_align</code>               (<code>str</code>, default:                   <code>'center'</code> )           \u2013            <p>Alignment for x and y axis tick labels relative to their tick  marks:</p> <ul> <li>For x-axis: 'left', 'center', 'right' control horizontal   alignment of the label text relative to the tick position</li> <li>For y-axis: 'bottom', 'center', 'top' control vertical   alignment, where the string values map to vertical alignment   for better API consistency</li> </ul> <p>Alignment is particularly useful with rotated labels to achieve optimal positioning and readability. By default, 'center'.</p> </li> <li> <code>ylabel_align</code>               (<code>str</code>, default:                   <code>'center'</code> )           \u2013            <p>Alignment for x and y axis tick labels relative to their tick  marks:</p> <ul> <li>For x-axis: 'left', 'center', 'right' control horizontal   alignment of the label text relative to the tick position</li> <li>For y-axis: 'bottom', 'center', 'top' control vertical   alignment, where the string values map to vertical alignment   for better API consistency</li> </ul> <p>Alignment is particularly useful with rotated labels to achieve optimal positioning and readability. By default, 'center'.</p> </li> <li> <code>info</code>               (<code>bool or str</code>, default:                   <code>False</code> )           \u2013            <p>Indicates whether to include an info text at the lower left  corner in the figure. If True, the date and user are automatically  added. If a string is provided, it's appended to the automatic date/user information, separated by a comma. By default, False.</p> </li> <li> <code>rows</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The row labels of the figure for faceted plots, by default ().</p> </li> <li> <code>cols</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The column labels of the figure for faceted plots, by default ().</p> </li> <li> <code>row_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the rows for faceted plots, by default ''.</p> </li> <li> <code>col_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the columns for faceted plots, by default ''.</p> </li> <li> <code>axes_titles</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Title for each Axes, useful for JointCharts with multiple subplots, by default ().</p> </li> <li> <code>legend_data</code>               (<code>Dict[str, LegendHandlesLabels]</code>, default:                   <code>{}</code> )           \u2013            <p>The legends to be added to the figure. The key is used as the  legend title, and the values must be a tuple of tuples, where the inner tuple contains a handle as a Patch or Line2D artist and a label as a string, by default {}.</p> </li> </ul> <p>Examples:</p> <p>Basic usage with string formatters:</p> <pre><code>axes = AxesFacets(nrows=1, ncols=1)\nlabel_facets = LabelFacets(\n    axes=axes,\n    fig_title='Temperature Analysis',\n    xlabel='Time (hours)',\n    ylabel='Temperature',\n    ylabel_formatter='{:.1f}\u00b0C',  # String template\n    xlabel_formatter='{:.0f}h'    # String template\n)\nlabel_facets.draw()\n</code></pre> <p>Custom callable formatters:</p> <pre><code>def scientific_formatter(value):\n    if abs(value) &gt;= 1000:\n        return f'{value:.1e}'\n    return f'{value:.2f}'\n\nlabel_facets = LabelFacets(\n    axes=axes,\n    ylabel_formatter=scientific_formatter,\n    xlabel_formatter=lambda x: f'${x:,.0f}'  # Lambda formatter\n)\n</code></pre> <p>Rotation and alignment for readability:</p> <pre><code>label_facets = LabelFacets(\n    axes=axes,\n    xlabel='Product Categories',\n    xlabel_angle=45,      # Diagonal rotation\n    xlabel_align='right', # Right-align for better rotation appearance\n    ylabel_formatter='{:.1%}'  # Percentage format\n)\n</code></pre> <p>Advanced faceted plot labeling:</p> <pre><code>label_facets = LabelFacets(\n    axes=multi_axes,\n    fig_title='Sales Analysis by Region',\n    sub_title='Q3 2024 Performance',\n    row_title='Geographic Region',\n    col_title='Product Category',\n    rows=('North', 'South', 'East', 'West'),\n    cols=('Electronics', 'Clothing', 'Books'),\n    xlabel_formatter='${:,.0f}',\n    ylabel_formatter='{:.1f}%',\n    info='Source: Sales database'\n)\n</code></pre> Notes <ul> <li>String formatters are automatically converted to    matplotlib-compatible formatters using intelligent type detection.</li> <li>Margins are automatically adjusted when using rotated labels to   prevent clipping and ensure optimal layout.</li> <li>The class handles both single axes and complex multi-axes layouts.</li> <li>All formatting options work consistently across different   matplotlib backends and figure configurations.</li> <li>Legend positioning is automatically calculated to avoid   overlapping with other chart elements.</li> </ul>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.axes","title":"<code>axes = axes</code>  <code>instance-attribute</code>","text":"<p>A AxesFacets instance containing the subplots' Axes and their  arrangement.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.axes_titles","title":"<code>axes_titles = axes_titles</code>  <code>instance-attribute</code>","text":"<p>The titles of each axes.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.col_title","title":"<code>col_title = col_title</code>  <code>instance-attribute</code>","text":"<p>The title of the columns.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.cols","title":"<code>cols = cols</code>  <code>instance-attribute</code>","text":"<p>The column labels of the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.fig_title","title":"<code>fig_title = fig_title</code>  <code>instance-attribute</code>","text":"<p>The title to display at the top of the chart.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.figure","title":"<code>figure = self.axes.figure</code>  <code>instance-attribute</code>","text":"<p>The figure instance to label.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.info","title":"<code>info = info</code>  <code>instance-attribute</code>","text":"<p>Indicates whether to include an info text in the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.labels","title":"<code>labels = {}</code>  <code>instance-attribute</code>","text":"<p>The labels that were added to the image as text objects.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.legend","title":"<code>legend</code>  <code>property</code>","text":"<p>Get legend added to figure (read-only).</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.legend_artists","title":"<code>legend_artists</code>  <code>property</code>","text":"<p>Get legend artists (read-only).</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.legend_data","title":"<code>legend_data = legend_data</code>  <code>instance-attribute</code>","text":"<p>The legend_data to be added to the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.legend_fraction","title":"<code>legend_fraction</code>  <code>property</code>","text":"<p>Get fraction of figure size for legend (read-only).</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.legend_width","title":"<code>legend_width</code>  <code>property</code>","text":"<p>Get width of legend in pixels (read-only).</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.margin_rectangle","title":"<code>margin_rectangle</code>  <code>property</code>","text":"<p>Get rectangle of margins around the subplots used for the additional labels as fraction of figure size (read-only).</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.row_title","title":"<code>row_title = row_title</code>  <code>instance-attribute</code>","text":"<p>The title of the rows.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.rows","title":"<code>rows = rows</code>  <code>instance-attribute</code>","text":"<p>The row labels of the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.sub_title","title":"<code>sub_title = sub_title</code>  <code>instance-attribute</code>","text":"<p>The subtitle to display directly below the title of the chart.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.x_aligned","title":"<code>x_aligned</code>  <code>property</code>","text":"<p>Get aligned x position as fraction of figure width. This is used for title, subtitle and info (read-only).</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.xlabel","title":"<code>xlabel = xlabel</code>  <code>instance-attribute</code>","text":"<p>The x-axis label(s) of the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.xlabel_align","title":"<code>xlabel_align = xlabel_align</code>  <code>instance-attribute</code>","text":"<p>Alignment for x-axis tick labels.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.xlabel_angle","title":"<code>xlabel_angle = xlabel_angle</code>  <code>instance-attribute</code>","text":"<p>Rotation angle for x-axis tick labels in degrees.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.xlabel_formatter","title":"<code>xlabel_formatter = self._prepare_formatter(xlabel_formatter)</code>  <code>instance-attribute</code>","text":"<p>Function to format the x-axis tick labels.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.ylabel","title":"<code>ylabel = ylabel</code>  <code>instance-attribute</code>","text":"<p>The y-axis label(s) of the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.ylabel_align","title":"<code>ylabel_align = ylabel_align</code>  <code>instance-attribute</code>","text":"<p>Alignment for y-axis tick labels.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.ylabel_angle","title":"<code>ylabel_angle = ylabel_angle</code>  <code>instance-attribute</code>","text":"<p>Rotation angle for y-axis tick labels in degrees.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.ylabel_formatter","title":"<code>ylabel_formatter = self._prepare_formatter(ylabel_formatter)</code>  <code>instance-attribute</code>","text":"<p>Function to format the y-axis tick labels.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.clear","title":"<code>clear()</code>","text":"<p>Remove all the label facets.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.draw","title":"<code>draw()</code>","text":"<p>Draw all the label facets to the figure.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.estimate_height","title":"<code>estimate_height(text)</code>  <code>staticmethod</code>","text":"<p>Get the estimated size of the text in the figure in pixels.</p>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.estimate_rotation_margin","title":"<code>estimate_rotation_margin(angle_degrees, base_margin=25)</code>  <code>staticmethod</code>","text":"<p>Estimate additional margin needed for rotated tick labels.</p> <p>Parameters:</p> <ul> <li> <code>angle_degrees</code>               (<code>float</code>)           \u2013            <p>Rotation angle in degrees</p> </li> <li> <code>base_margin</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>Base margin for calculating rotated label space, by default 25</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Additional margin in pixels needed for the rotation</p> </li> </ul>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.get_legend_artists","title":"<code>get_legend_artists(legend)</code>  <code>staticmethod</code>","text":"<p>Get the inner children of a legend.</p> <p>Parameters:</p> <ul> <li> <code>legend</code>               (<code>Legend</code>)           \u2013            <p>The legend object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Artist]:</code>           \u2013            <p>The artists representing the inner children of the legend.</p> </li> </ul>"},{"location":"plotlib/facets/label-facets/#daspi.plotlib.facets.LabelFacets.not_shared","title":"<code>not_shared(axis)</code>  <code>staticmethod</code>","text":"<p>Check if an axis is not shared.</p>"},{"location":"plotlib/facets/stripes-facets/","title":"Stripes facets","text":""},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets","title":"<code>daspi.plotlib.facets.StripesFacets</code>","text":"<p>A class for creating location and spread width lines,  specification limits and/or confidence interval areas as stripes on  each Axes. The location and spread (and their confidence bands)  represent the data per axes.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>ArrayLike</code>)           \u2013            <p>The target data for the estimation.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>)           \u2013            <p>Whether the target data is on the y-axis or not.</p> </li> <li> <code>single_axes</code>               (<code>bool</code>)           \u2013            <p>Whether a single axis is used for the chart or whether the  stripes are used on multiple axes. This affects how the  predefined legend labels are handled. If True, the corresponding position values are added to the label.</p> </li> <li> <code>stripes</code>               (<code>List[Type[Stripe]]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional non-predefined stripes to be added to the chart,  by default [].</p> </li> <li> <code>mean</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include a mean line on the chart, by default False.</p> </li> <li> <code>median</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include a median line on the chart, by default False.</p> </li> <li> <code>control_limits</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include control limits on the chart, by default False.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits</code>, default:                   <code>SpecLimits()</code> )           \u2013            <p>The specification limits for the chart, by default SpecLimits().</p> </li> <li> <code>confidence</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level for the confidence intervals, by default None.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control limits (process spread): - eval: The strategy is determined according to the given    evaluate function. If none is given, the internal evaluate   method is used. - fit: First, the distribution that best represents the process   data is searched for and then the agreed process spread is    calculated - norm: it is assumed that the data is subject to normal   distribution. The variation tolerance is then calculated as    agreement * standard deviation - data: The quantiles for the process variation tolerance are   read directly from the data. by default 'norm'</p> </li> <li> <code>agreement</code>               (<code>float or int</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the control  limits are to be calculated. If int, the spread is determined using the normal distribution  agreementsigma, e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of  the data. The upper and lower permissible quantiles are then  calculated from this. If float, the value must be between 0 and 1.This value is then  interpreted as the acceptable proportion for the spread, e.g.  0.9973 (which corresponds to ~ 6 sigma) by default 6</p> </li> <li> <code>**kwds</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the ProcessEstimator.</p> </li> </ul>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.confidence","title":"<code>confidence</code>  <code>property</code>","text":"<p>Get the confidence level for the confidence intervals (read-only).</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.estimation","title":"<code>estimation = ProcessEstimator(samples=target, spec_limits=spec_limits, strategy=strategy, agreement=agreement, **kwds)</code>  <code>instance-attribute</code>","text":"<p>The process estimator object.</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.orientation","title":"<code>orientation</code>  <code>property</code>","text":"<p>The orientation of the chart.</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.single_axes","title":"<code>single_axes = single_axes</code>  <code>instance-attribute</code>","text":"<p>Whether a single axis is used for the chart or whether the  stripes are used on multiple axes. This affects how the predefined legend labels are handled. If True, the corresponding position values are added to the label.</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.stripes","title":"<code>stripes = {(s.identity): sfor s in stripes}</code>  <code>instance-attribute</code>","text":"<p>The stripes to plot on the chart.</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Whether the target is on the y-axis or the x-axis.</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.add_control_limit_stripes","title":"<code>add_control_limit_stripes(add_confidence_span)</code>","text":"<p>Add control limit stripes to the plot.</p> <p>This method adds stripes representing the lower and upper  control limits for the target data.</p> <p>The stripes are added using the <code>StripeLine</code> class, with the  label and position set based on the control limits from the  <code>estimation</code> attribute. If <code>add_confidence_span</code> is <code>True</code>, additional stripes representing the confidence interval for the control limits will also be added using the <code>StripeSpan</code> class.</p> <p>Parameters:</p> <ul> <li> <code>add_confidence_span</code>               (<code>bool</code>)           \u2013            <p>Whether to add confidence stripes for the control limits.</p> </li> </ul>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.add_mean_stripes","title":"<code>add_mean_stripes(add_confidence_span)</code>","text":"<p>Add mean stripes to the plot.</p> <p>This method adds a stripe representing the mean of the target  data, using the <code>StripeLine</code> class. If <code>add_confidence_span</code> is  <code>True</code>, additional stripes representing the confidence interval  for the mean will also be added using the <code>StripeSpan</code> class.</p> <p>Parameters:</p> <ul> <li> <code>add_confidence_span</code>               (<code>bool</code>)           \u2013            <p>Whether to add confidence stripes for the mean.</p> </li> </ul>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.add_median_stripes","title":"<code>add_median_stripes(add_confidence_span)</code>","text":"<p>Add median stripes to the plot.</p> <p>This method adds a stripe representing the median of the target  data, using the <code>StripeLine</code> class. If <code>add_confidence_span</code> is  <code>True</code>, additional stripes representing the confidence interval  for the median will also be added using the <code>StripeSpan</code> class.</p> <p>Parameters:</p> <ul> <li> <code>add_confidence_span</code>               (<code>bool</code>)           \u2013            <p>Whether to add confidence stripes for the median.</p> </li> </ul>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.add_specification_limit_stripes","title":"<code>add_specification_limit_stripes()</code>","text":"<p>Add specification limit stripes to the plot.</p> <p>This method adds stripes representing the lower and upper  specification limits to the plot. If a specification limit is <code>None</code>, it will be skipped.</p> <p>The stripes are added using the <code>StripeLine</code> class, with the  label and position set based on the specification limits from the <code>estimation</code> attribute.</p>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.draw","title":"<code>draw(ax)</code>","text":"<p>Draw the stripes on the specified Axes.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>The Axes on which to draw the stripes.</p> </li> </ul>"},{"location":"plotlib/facets/stripes-facets/#daspi.plotlib.facets.StripesFacets.handles_labels","title":"<code>handles_labels()</code>","text":"<p>Get the legend handles and labels for the plot.</p> <p>This method processes the <code>self.stripes</code> dictionary to extract the legend handles and labels for the plot. It separates the  handles and labels for line stripes and span stripes, and  returns them as a tuple of handles and a tuple of labels.</p> <p>Returns:</p> <ul> <li> <code>LegendHandlesLabels</code> (              <code>LegendHandlesLabels</code> )          \u2013            <p>A tuple containing the legend handles and labels.</p> </li> </ul>"},{"location":"plotlib/plotter/","title":"Plotter Module","text":""},{"location":"plotlib/plotter/#daspi.plotlib.plotter","title":"<code>daspi.plotlib.plotter</code>","text":"<p>The plotter module provides classes for creating and customizing various types of plots. It also provides a collection of classes for statistical plotting and analysis.</p> <p>This module contains several classes that are useful for visualizing and analyzing statistical data. The classes provide functionality for  creating various types of plots, including Gaussian KDE plots, violine plots, error bar plots, and confidence interval plots. These plots can be used to visually assess statistical differences, estimate kernel density, display error bars, and evaluate confidence intervals.</p> <p>The following classes are designed to provide a convenient and intuitive way to visualize and analyze statistical data. They can be used in a variety of applications, including data exploration, hypothesis testing, and data presentation.</p> Usage <p>Import the module and use the classes to create and customize plots.</p> <p>Examples:</p> <p>Create a scatter plot <pre><code>from plotter import Plotter\nfrom plotter import Scatter\nfrom plotter import LinearRegressionLine\nfrom plotter import Probability\nfrom plotter import TransformPlotter\nfrom plotter import CenterLocation\n\ndata = {...}  # Data source for the plot\nscatter_plot = Scatter(data, 'target_variable')\nscatter_plot()\n</code></pre></p> <p>Create a linear regression plot <pre><code>data = {...}  # Data source for the plot\nlinear_regression_plot = LinearRegressionLine(\n    data, 'target_variable', 'feature_variable')\nlinear_regression_plot()\n</code></pre></p> <p>Create a probability plot <pre><code>data = {...}  # Data source for the plot\nprobability_plot = Probability(data, 'target_variable', dist='norm', kind='qq')\nprobability_plot()\n</code></pre></p> <p>Create a CenterLocation plot <pre><code>data = {...}  # Data source for the plot\ncenter_plot = CenterLocation(data, 'target_variable', 'feature_variable', kind='mean')\ncenter_plot()\n</code></pre></p>"},{"location":"plotlib/plotter/bar/","title":"Bar","text":""},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar","title":"<code>daspi.plotlib.plotter.Bar</code>","text":"<p>               Bases: <code>TransformPlotter</code></p> <p>A bar plotter that extends the TransformPlotter class.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot.</p> </li> <li> <code>stack</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to stack the bars. It is checked  whether there are already bars at each feature position, if so the new ones are stacked on top of the existing ones, by default True</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>Width of the bars, by default <code>CATEGORY.FEATURE_SPACE</code></p> </li> <li> <code>kw_method</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to be passed to the method, by default {}</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>A pandas Series method to use for aggregating target values  within each feature level. Like 'sum', 'count' or similar that returns a scalar, by default None</p> </li> <li> <code>f_base</code>               (<code>int | float</code>, default:                   <code>FEATURE_BASE</code> )           \u2013            <p>Value that serves as the base location (offset) of the  feature values. Only taken into account if feature is not  given, by default <code>DEFAULT.FEATURE_BASE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Bar\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = list('abcdefghijklmno'),\n    y = list(100/x for x in range(1, 16))))\nbar = Bar(\n    source=df, target='y', feature='x')\nbar()\nbar.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = list('abcdefghijklmno'),\n    y = list(100/x for x in range(1, 16))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True,\n    ).plot(\n        dsp.Bar,\n    ).label() # neded to label feature ticks\n</code></pre> <p>You can also aggregate a function on the target column Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Bar\n\nlimit = 3.5\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50) &gt; limit)\n        + list(np.random.normal(loc=4, scale=1, size=50) &gt; limit)\n        + list(np.random.normal(loc=2, scale=1, size=50) &gt; limit))))\nbar = Bar(\n    source=df, target='y', feature='x', method='sum', ax=ax)\nbar()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\nlimit = 3.5\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50) &gt; limit)\n        + list(np.random.normal(loc=4, scale=1, size=50) &gt; limit)\n        + list(np.random.normal(loc=2, scale=1, size=50) &gt; limit))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True,\n    ).plot(\n        dsp.Bar,\n        method='sum',\n    ).label() # neded to label feature ticks\n</code></pre>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.bars","title":"<code>bars</code>  <code>property</code>","text":"<p>Get a list of BarContainer objects representing the bars in the plot.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.kw_method","title":"<code>kw_method = kw_method</code>  <code>instance-attribute</code>","text":"<p>The provided keyword arguments to be passed to the method.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.method","title":"<code>method = method</code>  <code>instance-attribute</code>","text":"<p>The provided pandas Series method to use for aggregating target values.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.stack","title":"<code>stack = stack</code>  <code>instance-attribute</code>","text":"<p>Whether to stack the bars.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.t_base","title":"<code>t_base</code>  <code>property</code>","text":"<p>Get the base values for the bars (target), contains zeros  when not stacked.</p> <p>The base values are calculated based on existing bars in the plot. If stacking is enabled, the base values are updated to reflect the top of the existing bars at each feature position. If stacking is disabled, the base values are simply zeros.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>Width of the bars.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the bar plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes <code>bar</code> (or 'barh' if target_on_y is False) method.</p> </li> </ul>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/bar/#daspi.plotlib.plotter.Bar.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the given Series method on the target data if given  and return the transformed data. If no method is given, the  target data is adopted directly.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>int | float</code>)           \u2013            <p>Base location (offset) of feature axis coming from  `feature_grouped' generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>When transformed target data (or original data if no method is specified) is non-scalar.</p> </li> </ul>"},{"location":"plotlib/plotter/beeswarm/","title":"Beeswarm","text":""},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm","title":"<code>daspi.plotlib.plotter.Beeswarm</code>","text":"<p>               Bases: <code>TransformPlotter</code></p> <p>A class to create and display a basic bee swarm plot.</p> <p>This class includes methods that organize the input data into bins  according to a specified number of bins (or a default value if none  is provided). It calculates the upper limits for each bin and  positions the data points within these bins to achieve a horizontal distribution in the plot, ensuring as little overlap as possible  among the points.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>n_bins</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of bins to divide the data into. If not specified,  it is calculated as the length of the data divided by 6.  Defaults to None</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>The width of the beeswarm, by default <code>CATEGORY.FEATURE_SPACE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Beeswarm\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nbeeswarm = Beeswarm(\n    source=df, target='y', feature='x', ax=ax)\nbeeswarm()\nbeeswarm.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True # neded to label feature ticks\n    ).plot(\n        dsp.Beeswarm,\n    ).label() # neded to label feature ticks\n</code></pre> Source <p>This code is based on the following source:  https://python-graph-gallery.com/509-introduction-to-swarm-plot-in-matplotlib/</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.n_bins","title":"<code>n_bins = n_bins</code>  <code>instance-attribute</code>","text":"<p>The number of bins to divide the data into</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>The maximum width of the beeswarm.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the jitter plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes  <code>scatter</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/beeswarm/#daspi.plotlib.plotter.Beeswarm.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Generates the spread values for the beeswarm plot by  arranging the target data into bins.</p> <p>The method divides the input data into bins based on the  specified number of bins and calculates the spread of values  within each bin to create a horizontal distribution.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float</code>)           \u2013            <p>The center position on the feature axis where the beeswarm  values will be centered.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data, coming from `feature_grouped'  generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/bland-altman/","title":"Bland altman","text":""},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman","title":"<code>daspi.plotlib.plotter.BlandAltman</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>Generate a Bland-Altman plot to compare two sets of measurements.</p> <p>Bland-Altman plots [1]_ are extensively used to evaluate the  agreement among two different instruments or two measurements  techniques. They allow identification of any systematic difference  between the measurements (i.e., fixed bias) or possible outliers.</p> <p>The mean difference (= second - first) is the estimated bias, and  the SD of the differences measures the random fluctuations around  this mean. If the mean value of the difference differs significantly  from 0 on the basis of a 1-sample t-test, this indicates the  presence of fixed bias. If there is a consistent bias, it can be  adjusted for by subtracting the mean difference from the new method.</p> <p>It is common to compute 95% limits of agreement for each comparison  (average difference \u00b1 1.96 standard deviation of the difference),  which tells us how far apart measurements by 2 methods were more  likely to be for most individuals. If the differences within  mean \u00b1 1.96 SD are not clinically important, the two methods may be  used interchangeably. The 95% limits of agreement can be unreliable  estimates of the population parameters especially for small sample  sizes so, when comparing methods or assessing repeatability, it is  important to calculate confidence intervals for the 95% limits of  agreement.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name indicating which is the first (reference  measurement) and which is the second measurement (the  measurement to be compared).</p> </li> <li> <code>identity</code>               (<code>str</code>)           \u2013            <p>Column name containing identities of each sample, must occur  once for each measurement.</p> </li> <li> <code>reverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if the order of the measurements should be  reversed, by default False</p> </li> <li> <code>agreement</code>               (<code>float</code>, default:                   <code>3.92</code> )           \u2013            <p>Multiple of the standard deviation to plot agreement limits (in both direction). The defaults is 3.92 (\u00b1 1.96), which  corresponds to 95 % confidence interval if the differences are normally distributed.</p> </li> <li> <code>confidence</code>               (<code>float or None</code>, default:                   <code>0.95</code> )           \u2013            <p>If not None, plot the specified percentage confidence interval of the mean and limits of agreement. The CIs of the mean difference and agreement limits describe a possible error in the estimate due to a sampling error. The greater the sample size, the narrower the CIs will be, by default 0.95</p> </li> <li> <code>feature_axis</code>               (<code>Literal['mean', 'data']</code>, default:                   <code>'mean'</code> )           \u2013            <p>Definition of data used as feature axis (reference axis).  - If 'mean' the mean for each measurement is calculated as (first + second)/2. - If 'data' the feature values are used for feature axis.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, an attempt is made to get the current one using <code>plt.gca</code>. If none is available, one is  created. The same applies to the Figure object. Defaults to  None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import daspi as dsp\n\nchart = dsp.SingleChart(\n        source=dsp.load_dataset('shoe-sole'),\n        target='wear',\n        feature='status',\n    ).plot(\n        dsp.BlandAltman,\n        identity='tester',\n        feature_axis='mean',\n        reverse=True)\n</code></pre> Notes <p>The code is an adaptation of the Pingouin package. https://pingouin-stats.org/generated/pingouin.plot_blandaltman.html</p> <p>The pingouin implementation is also a simplified version of the  PyCombare package: https://github.com/jaketmp/pyCompare</p> References <p>.. [1] Bland, J. M., &amp; Altman, D. (1986). Statistical methods for         assessing agreement between two methods of clinical        measurement. The lancet, 327(8476), 307-310.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.confidence","title":"<code>confidence = confidence</code>  <code>instance-attribute</code>","text":"<p>Confidence level of the confidence interval for mean and agreements.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.estimation","title":"<code>estimation = LocationDispersionEstimator(samples=(df[_target]), strategy='norm', agreement=agreement)</code>  <code>instance-attribute</code>","text":"<p>Estimator instance to estimate the mean and limits of agreement.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.identity","title":"<code>identity = identity</code>  <code>instance-attribute</code>","text":"<p>Column name containing identities of each sample.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.lines_same_color","title":"<code>lines_same_color = lines_same_color</code>  <code>instance-attribute</code>","text":"<p>Whether to use same color for lines and their confidence  intervals as for the points.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.stripes","title":"<code>stripes = {}</code>  <code>instance-attribute</code>","text":"<p>Dictionary of Stripe objects used for drawing lines and their confidence intervals.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the Bland-Altman plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes <code>scatter</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/bland-altman/#daspi.plotlib.plotter.BlandAltman.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/capability-confidence-interval/","title":"Capability confidence interval","text":""},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval","title":"<code>daspi.plotlib.plotter.CapabilityConfidenceInterval</code>","text":"<p>               Bases: <code>ConfidenceInterval</code></p> <p>Class for creating plotters with error bars as confidence  interval for the process capability values Cp or Cpk.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits</code>)           \u2013            <p>Specification limits for the target variable. This can be created using the <code>SpecLimits</code> class.</p> </li> <li> <code>kind</code>               (<code>(cp, cpk)</code>, default:                   <code>'cp'</code> )           \u2013            <p>The capability index to be calculated. Cp can be used to compare  the process variability to a specification width, while Cpk  also considers the process mean. The Cp can only be calculated  if both specification limits are given.</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of groups (variable combinations) for the Bonferroni  adjustment. A good way to do this is to pass  <code>df.groupby(list_of_variates).ngroups</code>, where <code>list_of_variates</code>  is a list containing all the categorical columns in the source  that will be used for the chart to split the data into groups  (hue, categorical features, etc.). Specify 1 to not do a  Bonferroni adjustment. Default is 1</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level for the confidence intervals, by default 0.95.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>kw_estim</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments that are passed to the  <code>ProcessEstimator</code> class. Possible keword arguments are: - error_values: Tuple[float, ...] = (), - strategy: Literal['eval', 'fit', 'norm', 'data'] = 'norm', - agreement: float | int = 6, - possible_dists: Tuple[str | rv_continuous, ...] = DIST.COMMON</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import CapabilityConfidenceInterval, SpecLimits\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 100 + ['second'] * 100 + ['third'] * 100,\n    y = (list(np.random.normal(loc=3, scale=1, size=100))\n        + list(np.random.normal(loc=4, scale=1, size=100))\n        + list(np.random.normal(loc=2, scale=1, size=100)))))\n\ntest = CapabilityConfidenceInterval(\n    source=df, target='y', feature='x', spec_limits=SpecLimits(upper=4.3), \n    kind='cpk', show_center=True, n_groups=df.x.nunique(), \n    confidence_level=0.95, bars_same_color=True, ax=ax)\ntest(kw_center=dict(s=30, marker='_'))\ntest.label_feature_ticks()\n\n#If you are interested in the calculated values, you can get them like this:\nprint(test.source)\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 100 + ['second'] * 100 + ['third'] * 100,\n    y = (list(np.random.normal(loc=3, scale=1, size=100))\n        + list(np.random.normal(loc=4, scale=1, size=100))\n        + list(np.random.normal(loc=2, scale=1, size=100)))))\n\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.CapabilityConfidenceInterval,\n        kind='cpk',\n        spec_limits=dsp.SpecLimits(upper=4.3),\n        show_center=True, \n        confidence_level=0.95,\n        n_groups=df.x.nunique(),\n        bars_same_color=True,\n    ).label() # neded to label the feature tick labels\n\n#If you are interested in the calculated values, you can get them like this:\ndf_cpk = chart.plots[0].source.copy()\ndf_cpk.index = chart.dodging.pos_to_ticklabels(df_cpk['x'])\nprint(df_cpk)\n</code></pre>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.ci_func","title":"<code>ci_func = ci_func</code>  <code>instance-attribute</code>","text":"<p>Provided function for calculating the confidence intervals.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.confidence_level","title":"<code>confidence_level = confidence_level</code>  <code>instance-attribute</code>","text":"<p>Confidence level for the confidence intervals.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.kind","title":"<code>kind = kind</code>  <code>instance-attribute</code>","text":"<p>whether to calculate the confidence interval for Cp or Cpk  ('cp' or 'cpk').</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.kw_estim","title":"<code>kw_estim = kw_estim</code>  <code>instance-attribute</code>","text":"<p>Additional keyword arguments that are passed to the  <code>ProcessEstimator</code> classes.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.n_groups","title":"<code>n_groups = n_groups</code>  <code>instance-attribute</code>","text":"<p>Number of unique feature values.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.processes","title":"<code>processes = {}</code>  <code>instance-attribute</code>","text":"<p>ProcessEstimator classes used to calculate the cp and cpk values. One for each feature level. - key: feature level as str - value: ProcessEstimator instance</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.spec_limits","title":"<code>spec_limits = spec_limits</code>  <code>instance-attribute</code>","text":"<p>Spec limits used for calculating the capability values.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.hide_feature_axis","title":"<code>hide_feature_axis()</code>","text":"<p>Hide the density axis (spine, ticks and labels).</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/capability-confidence-interval/#daspi.plotlib.plotter.CapabilityConfidenceInterval.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by using the given function `ci_func' and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/categorical-observation/","title":"Categorical observation","text":""},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter","title":"<code>daspi.plotlib.plotter.Scatter</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>A scatter plotter that extends the Plotter base class.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>size</code>               (<code>Iterable[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The size of the markers in the scatter plot, by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Scatter\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame({'x': list(x*np.pi/50 for x in range(100))})\ndf['y'] = np.cos(df['x'])\nscatter = Scatter(source=df, target='y', feature='x', ax=ax)\nscatter(color='red', s=20, marker='s', alpha=0.6)\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame({'x': list(x*np.pi/50 for x in range(100))})\ndf['y'] = np.cos(df['x'])\n\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x'\n    ).plot(\n        dsp.Scatter,\n        kw_call=dict(color='red', s=20, marker='s', alpha=0.6))\n</code></pre>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.size","title":"<code>size = size</code>  <code>instance-attribute</code>","text":"<p>The sizes of the markers in the scatter plot.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the scatter plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes  <code>scatter</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/categorical-observation/#daspi.plotlib.plotter.Scatter.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/center-location/","title":"Center location","text":""},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation","title":"<code>daspi.plotlib.plotter.CenterLocation</code>","text":"<p>               Bases: <code>TransformPlotter</code></p> <p>A center location (mean or median) plotter that extends the  TransformPlotter class.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>kind</code>               (<code>Literal['mean', 'median']</code>, default:                   <code>'mean'</code> )           \u2013            <p>The type of center to plot ('mean' or 'median'), by default 'mean'.</p> </li> <li> <code>show_line</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to draw a line between the calculated  mean or median points, by default True</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points,  by default True.</p> </li> <li> <code>f_base</code>               (<code>int | float</code>, default:                   <code>FEATURE_BASE</code> )           \u2013            <p>Value that serves as the base location (offset) of the  feature values. Only taken into account if feature is not  given, by default <code>DEFAULT.FEATURE_BASE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import CenterLocation, Scatter\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nscatter=Scatter(source=df, target='y', feature='x', ax=ax)\ncenter = CenterLocation(\n    source=df, target='y', feature='x', kind='median',\n    show_center=True, show_line=True, ax= ax)\ncenter(marker='_', markersize=10)\ncenter.label_feature_ticks()\nscatter(color='black')\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True,\n    ).plot(\n        dsp.CenterLocation,\n        kind='median',\n        show_line=True,\n        show_center=True,\n        kw_call=dict(marker='_', markersize=30)\n    ).plot(\n        dsp.Scatter,\n    ).label() # neded to label feature ticks\n</code></pre> Note <p>Be careful with the <code>show_center</code> and <code>show_line</code> flags. Either  <code>show_center</code> or <code>show_line</code> must be True, otherwise this plot makes  no sense. If both are False, nothing will be drawn.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.kind","title":"<code>kind</code>  <code>property</code> <code>writable</code>","text":"<p>Get and set the type of location ('mean' or 'median') to  plot.</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If neither 'mean' or 'median' is given when setting <code>kind</code>.</p> </li> </ul>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.linestyle","title":"<code>linestyle</code>  <code>property</code>","text":"<p>Get rcParams line style if show_line is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Whether to draw the center points.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.show_line","title":"<code>show_line = show_line</code>  <code>instance-attribute</code>","text":"<p>Whether to draw a line between the calculated means or medians.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the center plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes <code>plot</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/center-location/#daspi.plotlib.plotter.CenterLocation.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Calculate the mean or median of the target data and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>int | float</code>)           \u2013            <p>Base location (offset) of feature axis coming from  `feature_grouped' generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/confidence-interval/","title":"Confidence interval","text":""},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval","title":"<code>daspi.plotlib.plotter.ConfidenceInterval</code>","text":"<p>               Bases: <code>Errorbar</code></p> <p>Class for creating plotters with error bars representing optical distinction tests.</p> <p>This class is useful for visually testing whether there is a  statistically significant difference between groups or conditions. By plotting confidence intervals around the actual value, it  provides a visual representation of the uncertainty in the estimate  and allows for a quick assessment of whether the intervals overlap  or not.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of groups (variable combinations) for the Bonferroni  adjustment. A good way to do this is to pass  <code>df.groupby(list_of_variates).ngroups</code>, where <code>list_of_variates</code>  is a list containing all the categorical columns in the source  that will be used for the chart to split the data into groups  (hue, categorical features, etc.). Specify 1 to not do a  Bonferroni adjustment. Default is 1</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level for the confidence intervals, by default 0.95.</p> </li> <li> <code>ci_func</code>               (<code>Callable</code>, default:                   <code>mean_ci</code> )           \u2013            <p>Function for calculating the confidence intervals. The following two arguments are passed to the function: The sample data and  the confidence level. The returned values must be three floats in order: center value, lower confidence limit and upper  confidence limit. Default is <code>daspi.statistics.conficence.mean_ci</code>.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import ConfidenceInterval, variance_ci\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nci = ConfidenceInterval(\n    source=df, target='y', feature='x', show_center=True, ci_func=variance_ci,\n    n_groups=df.x.nunique(), confidence_level=0.95, bars_same_color=True,\n    ax=ax)\nci(kw_center=dict(s=30, marker='_'))\nci.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=1, scale=3, size=50))\n        + list(np.random.normal(loc=1, scale=4, size=50))\n        + list(np.random.normal(loc=1, scale=2, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.ConfidenceInterval,\n        show_center=True,\n        ci_func=dsp.variance_ci,\n        n_groups=df.x.nunique(),\n        confidence_level=0.95,\n        bars_same_color=True,\n        kw_call=dict(kw_center=dict(s=30, marker='_'))\n    ).label() # neded to label the feature tick labels\n</code></pre>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.ci_func","title":"<code>ci_func = ci_func</code>  <code>instance-attribute</code>","text":"<p>Provided function for calculating the confidence intervals.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.confidence_level","title":"<code>confidence_level = confidence_level</code>  <code>instance-attribute</code>","text":"<p>Confidence level for the confidence intervals.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.n_groups","title":"<code>n_groups = n_groups</code>  <code>instance-attribute</code>","text":"<p>Number of unique feature values.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/confidence-interval/#daspi.plotlib.plotter.ConfidenceInterval.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by using the given function `ci_func' and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/errorbar/","title":"Errorbar","text":""},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar","title":"<code>daspi.plotlib.plotter.Errorbar</code>","text":"<p>               Bases: <code>TransformPlotter</code></p> <p>Class for creating error bar plotters.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>lower</code>               (<code>str</code>)           \u2013            <p>Column name of the lower error values.</p> </li> <li> <code>upper</code>               (<code>str</code>)           \u2013            <p>Column name of the upper error values.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom daspi import Errorbar\nfrom collections import defaultdict\n\nfig, ax = plt.subplots()\ndata = defaultdict(list)\ndata['x'] = ['first', 'second', 'third']\nfor loc in [3, 4, 2]:\n    temp = np.random.normal(loc=loc, scale=1, size=10)\n    x_bar = np.mean(temp)\n    sem = np.std(temp, ddof=1) / np.sqrt(len(temp))\n    data['x_bar'].append(x_bar)\n    data['lower'].append(x_bar - sem)\n    data['upper'].append(x_bar + sem)\n\ndf = pd.DataFrame(data)\nerrorbar = Errorbar(\n    source=df, target='x_bar', feature='x', lower='lower', upper='upper',\n    show_center=True, ax=ax)\nerrorbar(kw_center=dict(color='black', s=30, marker='_')\nerrorbar.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\nfrom collections import defaultdict\n\ndata = defaultdict(list)\ndata['x'] = ['first', 'second', 'third']\nfor loc in [3, 4, 2]:\n    temp = np.random.normal(loc=loc, scale=1, size=10)\n    x_bar = np.mean(temp)\n    sem = np.std(temp, ddof=1) / np.sqrt(len(temp))\n    data['x_bar'].append(x_bar)\n    data['lower'].append(x_bar - sem)\n    data['upper'].append(x_bar + sem)\n\nchart = dsp.SingleChart(\n        source=df,\n        target='x_bar',\n        hue='x',\n        dodge=True,\n    ).plot(\n        dsp.Errorbar,\n        lower='lower',\n        upper='upper',\n        bars_same_color=True,\n        kw_call={'kw_center': dict(color='black', s=30, marker='_')}\n    ).label() # neded to add legend\n</code></pre>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/errorbar/#daspi.plotlib.plotter.Errorbar.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde-contour/","title":"Gaussian kde contour","text":""},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour","title":"<code>daspi.plotlib.plotter.GaussianKDEContour</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>Class for creating contour plotters. Use this class for bivariate plots.</p> <p>Performs a 2 dimensional kernel density estimation using Gaussian Kernels. The estimation is then shown as contour lines. The x- and y-axes remain as feature and target axes.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>fill</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to fill between the contour lines, by default True</p> </li> <li> <code>fade_outers</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the outer lines of the contour plot should be faded. This has no effect if fill is True, by default True.</p> </li> <li> <code>n_points</code>               (<code>int</code>, default:                   <code>KD_SEQUENCE_LEN</code> )           \u2013            <p>Number of points the estimate and the sequence should have.  Note that the calculated points are equal to the square of the  given number (because the contour is two-dimensional). by default KD_SEQUENCE_LEN (defined in constants.py)</p> </li> <li> <code>margin</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Margin for the sequence as factor of data range, by default 0.2.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis. If False, all contour lines have the same color.  by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import matplotlib.pyplot as plt\nfrom daspi import GaussianKDEContour, load_dataset\n\nfig, ax = plt.subplots()\ncolors = ('#1f77b4', '#ff7f0e', '#2ca02c')\ndf = load_dataset('iris')\nfor color, (name, group) in zip(colors, df.groupby('species')):\n    kde = GaussianKDEContour(\n        source=group, target='length', feature='width', color=color,\n        fill=False, fade_outers=False, margin=0.3, ax=ax)\n    kde()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import daspi as dsp\n\ndf = load_dataset('iris')\nchart = dsp.SingleChart(\n        source=df,\n        target='length',\n        feature='width',\n        hue='leaf',\n    ).plot(\n        dsp.GaussianKDEContour,\n        fill=False,\n        fade_outers=False,\n        margin=0.3\n    ).label() # neded to add legend\n</code></pre>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.cmap","title":"<code>cmap = LinearSegmentedColormap.from_list('', colors)</code>  <code>instance-attribute</code>","text":"<p>The colormap to be used for the contour plot.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.fill","title":"<code>fill = fill</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to fill between the contour lines.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Return the default keyword arguments for the plot.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.shape","title":"<code>shape = (n_points, n_points)</code>  <code>instance-attribute</code>","text":"<p>Shape used to reshape data before plotting the contours.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the plotting operation.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde-contour/#daspi.plotlib.plotter.GaussianKDEContour.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/","title":"Gaussian kde","text":""},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE","title":"<code>daspi.plotlib.plotter.GaussianKDE</code>","text":"<p>               Bases: <code>SpreadOpacity</code>, <code>TransformPlotter</code></p> <p>Class for creating Gaussian Kernel Density Estimation (KDE)  plotters. Use this class for univariate plots.</p> <p>Kernel density estimation is a way to estimate the probability  density function (PDF) of a random variable in a non-parametric way. The used gaussian_kde function of scipy.stats works for both uni-variate and multi-variate data. It includes automatic bandwidth determination. The estimation works best for a unimodal  distribution; bimodal or multi-modal distributions tend to be  oversmoothed.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>stretch</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Factor by which the curve was stretched in height, by default 1.</p> </li> <li> <code>height</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Height of the KDE curve at its maximum, by default None.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>ignore_feature</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the feature axis should be ignored. If  True, all curves have base 0 on the feature axis, by default True</p> </li> <li> <code>margin</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Margin for the sequence as factor of data range (max - min ).  If margin is 0, The two ends of the estimated density curve then  show the minimum and maximum value. Default is 0.</p> </li> <li> <code>fill</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag whether to fill in the curves, by default True</p> </li> <li> <code>agreements</code>               (<code>Tuple[float, ...] or Tuple[int, ...]</code>, default:                   <code>AGREEMENTS</code> )           \u2013            <p>Specifies the tolerated process variation for calculating  quantiles. These quantiles are used to represent the filled area  with different opacity, thus highlighting the quantiles.If you  want the filled area to be uniform without highlighting the  quantiles, provide an empty tuple. This argument is only taken  into account if fill is set to True. The agreements can be either  integers or floats, determining the process variation tolerance  in the following ways: - If integers, the quantiles are determined using the normal    distribution (agreement * \u03c3), e.g., agreement = 6 covers    ~99.75% of the data. - If floats, values must be between 0 and 1, interpreted as    acceptable proportions for the quantiles, e.g., 0.9973    corresponds to ~6\u03c3. - If empty tuple, the filled area is uniform without    highlighting the quantiles.</p> <p>Default is <code>DEFAULT.AGREEMENTS</code> = (2, 4, 6), corresponding to  (\u00b11\u03c3, \u00b12\u03c3, \u00b13\u03c3).</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>n_points</code>               (<code>int</code>, default:                   <code>KD_SEQUENCE_LEN</code> )           \u2013            <p>Number of points the kernel density estimation and sequence  should have, by default KD_SEQUENCE_LEN  (defined in constants.py).</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import GaussianKDE\n\nfig, ax = plt.subplots()\ncolors = ('#1f77b4', '#ff7f0e', '#2ca02c')\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nfor color, (name, group) in zip(colors, df.groupby('x')):\n    kde = GaussianKDE(\n        source=group, target='y', strategy='norm', agreements=(2, 4, 6),\n        target_on_y=False, color=color, margin=0.3, ax=ax)\n    kde(label=name)\nhandles, labels = ax.get_legend_handles_labels()\nagreements = kde.agreements[::-1] * df.x.nunique()\nlabels = [f'{l} {a}\u03c3' for l, a in zip(labels, agreements)]\nax.legend(handles, labels)\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        hue='x',\n        target_on_y=False,\n    ).plot(\n        dsp.GaussianKDE,\n        strategy='norm',\n        agreements=(2, 4, 6), # std for area color opacities\n        visible_spines='target',\n        hide_axis='feature',\n    ).label() # neded to label feature ticks\n</code></pre>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.estimation","title":"<code>estimation</code>  <code>instance-attribute</code>","text":"<p>The estimator used to calculate the quantiles.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.fill","title":"<code>fill = fill</code>  <code>instance-attribute</code>","text":"<p>Flag whether to fill in the curves</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.height","title":"<code>height</code>  <code>property</code>","text":"<p>Height of kde curve at its maximum.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.highlight_quantiles","title":"<code>highlight_quantiles</code>  <code>property</code>","text":"<p>Flag indicating whether the quantiles should be highlighted.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.margin","title":"<code>margin = margin</code>  <code>instance-attribute</code>","text":"<p>Margin for the sequence as factor of data range (max - min ). If margin is 0, The two ends of the estimated density curve then show  the minimum and maximum value.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.n_points","title":"<code>n_points = n_points</code>  <code>instance-attribute</code>","text":"<p>Number of points that have the kde and its sequence.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.stretch","title":"<code>stretch</code>  <code>property</code>","text":"<p>Factor by which the curve was stretched in height</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.__call__","title":"<code>__call__(kw_line={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>The estimated kernel density is plotted as a line. The curves  are additionally filled if the \"fill\" option was set to \"true\"  during initialization.</p> <p>Parameters:</p> <ul> <li> <code>kw_line</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>plot</code> method, by default {}.</p> </li> <li> <code>**kwds</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>fill_between</code> method, by default {}.</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.quantiles","title":"<code>quantiles(target_data)</code>","text":"<p>Calculate the quantiles in ascending order:</p> <p>Parameters:</p> <ul> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>quantiles in ascending order</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.subgroup_values","title":"<code>subgroup_values(sequence, quantiles)</code>","text":"<p>Generate a list of subgroup values based on the agreements.</p> <p>This method creates a list of subgroup values derived from the  instance's agreements. It iterates through the agreements and  appends each agreement to the subgroup list. If the current  agreement is the same as the first agreement, the last  subgroup value is appended instead.</p> <p>Returns:</p> <ul> <li> <code>List[float | int]:</code>           \u2013            <p>A list of subgroup values, which can include both floats  and integers.</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/gaussian-kde/#daspi.plotlib.plotter.GaussianKDE.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by estimating  its kernel density. To obtain a uniform curve, a sequence  is generated with a specific number of points in the same range  (min to max) as the target data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from  <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot. Contains the  generated sequence as target data and the estimation as feature data.</p> </li> </ul>"},{"location":"plotlib/plotter/jitter/","title":"Jitter","text":""},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter","title":"<code>daspi.plotlib.plotter.Jitter</code>","text":"<p>               Bases: <code>TransformPlotter</code></p> <p>A class for creating jitter plotters.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>The width of the jitter, by default <code>CATEGORY.FEATURE_SPACE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Jitter\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\njitter = Jitter(\n    source=df, target='y', feature='x', ax=ax)\njitter()\njitter.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True # neded to label feature ticks\n    ).plot(\n        dsp.Jitter,\n    ).label() # neded to label feature ticks\n</code></pre>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>The width of the jitter.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the jitter plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes  <code>scatter</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.jitter","title":"<code>jitter(loc, size)</code>","text":"<p>Generates normally distributed jitter values. The standard  deviation is selected so that +- 6 sigma corresponds to the  permissible width. To ensure the width, values that lie outside  this range are restricted to the limits.</p> <p>Parameters:</p> <ul> <li> <code>loc</code>               (<code>float</code>)           \u2013            <p>Center position (feature axis) of the jitted values.</p> </li> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Amount of valaues to generate</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>jitter</code> (              <code>1D array</code> )          \u2013            <p>Normally distributed values, but not wider than the given  width</p> </li> </ul>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/jitter/#daspi.plotlib.plotter.Jitter.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Normally randomize the target data for each feature value in  the feature axis direction.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>int | float</code>)           \u2013            <p>Base location (offset) of feature axis coming from  `feature_grouped' generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/line/","title":"Line","text":""},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line","title":"<code>daspi.plotlib.plotter.Line</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>A line plotter that extends the Plotter base class.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Line\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame({'x': list(x*np.pi/50 for x in range(100))})\ndf['y'] = np.cos(df['x'])\nline = Line(source=df, target='y', feature='x', ax=ax)\nline(color='red', lw=2, alpha=0.6)\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame({'x': list(x*np.pi/50 for x in range(100))})\ndf['y'] = np.cos(df['x'])\n\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x'\n    ).plot(\n        dsp.Line,\n        kw_call=dict(color='red', lw=2, alpha=0.6))\n</code></pre>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.__call__","title":"<code>__call__(marker=None, **kwds)</code>","text":"<p>Perform the line plot operation.</p> <p>Parameters:</p> <ul> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the individuals. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes <code>plot</code>  method.</p> </li> </ul>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/line/#daspi.plotlib.plotter.Line.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/linear-regression-line/","title":"Linear regression line","text":""},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine","title":"<code>daspi.plotlib.plotter.LinearRegressionLine</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>A linear regression plotter that extends the Plotter base class.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>show_scatter</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to show the individual points,  by default False.</p> </li> <li> <code>show_fit_ci</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to show the confidence interval for the fitted line as filled area, by default False.</p> </li> <li> <code>show_pred_ci</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to show the confidence interval for  predictions as additional lines, by default False</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import LinearRegressionLine\n\nfig, ax = plt.subplots()\nx = np.linspace(0, 10, 100)\ndf = pd.DataFrame(dict(\n    x=x,\n    y=x + np.random.randn(100) - 0.05 * np.square(x)))\nreg_line = LinearRegressionLine(\n    source=df, target='y', feature='x', ax=ax,\n    show_scatter=True, show_fit_ci=True, show_pred_ci=True)\nreg_line(\n    kw_scatter=dict(color='black', s=10, alpha=0.5),\n    kw_fit_ci=dict(color='skyblue'),\n    kw_pred_ci=dict(color='steelblue', alpha=1),\n    color='deepskyblue')\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\nx = np.linspace(0, 10, 100)\ndf = pd.DataFrame(dict(\n    x=x,\n    y=x + np.random.randn(100) - 0.05 * np.square(x)))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x'\n    ).plot(\n        dsp.LinearRegressionLine,\n        show_scatter=True,\n        show_fit_ci=True,\n        show_pred_ci=True,\n        kw_call=dict(\n            kw_scatter=dict(color='black', s=10, alpha=0.5),\n            kw_fit_ci=dict(color='skyblue'),\n            kw_pred_ci=dict(color='steelblue', alpha=1),\n            color='deepskyblue'))\n</code></pre>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.fit","title":"<code>fit = PLOTTER.FITTED_VALUES</code>  <code>instance-attribute</code>","text":"<p>The name of the column containing the fitted values as defined  in the PLOTTER.FITTED_VALUES.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.model","title":"<code>model = sm.OLS(df[target], sm.add_constant(df[feature])).fit()</code>  <code>instance-attribute</code>","text":"<p>The fitted results of the linear regression model.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.show_fit_ci","title":"<code>show_fit_ci = show_fit_ci</code>  <code>instance-attribute</code>","text":"<p>Whether to show the confidence interval for the fitted line.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.show_pred_ci","title":"<code>show_pred_ci = show_pred_ci</code>  <code>instance-attribute</code>","text":"<p>Whether to show the confidence interval for the predictions.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.show_scatter","title":"<code>show_scatter = show_scatter</code>  <code>instance-attribute</code>","text":"<p>Whether to show the individual points in the plot.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.x_fit","title":"<code>x_fit</code>  <code>property</code>","text":"<p>Get values used for x-axis for fitted line (read-only).</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.y_fit","title":"<code>y_fit</code>  <code>property</code>","text":"<p>Get values used for y-axis for fitted line (read-only)</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.__call__","title":"<code>__call__(kw_scatter={}, kw_fit_ci={}, kw_pred_ci={}, **kwds)</code>","text":"<p>Perform the linear regression plot operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_scatter</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the Axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>kw_fit_ci</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the confidence interval of  the fitted line (Axes <code>fill_between</code> method), by default {}.</p> </li> <li> <code>kw_pred_ci</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the confidence interval of the predictions (Axes plot method), by default {}</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the fit line plot (Axes <code>plot</code> method).</p> </li> </ul>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.ci_data","title":"<code>ci_data()</code>","text":"<p>Get confidence interval for prediction and fitted line as  DataFrame.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/linear-regression-line/#daspi.plotlib.plotter.LinearRegressionLine.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/loess-line/","title":"Loess line","text":""},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine","title":"<code>daspi.plotlib.plotter.LoessLine</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>A class for plotting a loess line.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>show_scatter</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to show the individual points,  by default False.</p> </li> <li> <code>show_fit_ci</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to show the confidence interval for the lowess line as filled area, by default False.</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Calculate confidence bands for the lowess line at this level  (0 to 1). Defaults to 0.95.</p> </li> <li> <code>fraction</code>               (<code>float | None</code>, default:                   <code>0.2</code> )           \u2013            <p>The fraction of the data used for each local regression. A good  value to start with is 2/3 (default value of statsmodels).  Reduce the value to avoid underfitting. A value below 0.2  usually leads to overfitting, except for gaussian weights.  Defaults to 0.2 because of default gaussian kernel.</p> </li> <li> <code>order</code>               (<code>Literal[0, 1, 2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The order of the local regression to be fitted. This determines  the degree of the polynomial used in the local regression:</p> <p>0: No smoothing (interpolation) 1: Linear regression 2: Quadratic regression 3: Cubic regression Default is 3.</p> </li> <li> <code>kernel</code>               (<code>Literal['tricube', 'gaussian', 'epanechnikov']</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The kernel function used to calculate the weights. Available kernels are: 'tricube': Tricube kernel function 'gaussian': Gaussian kernel function 'epanechnikov': Epanechnikov kernel function. Default is 'gaussian', because it will not run in a Singular Matrix Error.</p> </li> <li> <code>n_points</code>               (<code>int</code>, default:                   <code>LOWESS_SEQUENCE_LEN</code> )           \u2013            <p>Number of points the smoothed line and its sequence  should have, by default LOWESS_SEQUENCE_LEN  (defined in constants.py).</p> </li> <li> <code>kind</code>               (<code>Literal['LOESS', 'LOWESS']</code>, default:                   <code>'LOESS'</code> )           \u2013            <p>The type of lowess line to be plotted. Available options are: 'LOESS': Lowess line using the LOESS algorithm 'LOWESS': Lowess line using the LOWESS algorithm Default is 'LOESS' because it needs less computational power.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import LoessLine\n\nfig, ax = plt.subplots()\nx = 5*np.random.random(100)\ndf = pd.DataFrame(dict(\n    x = x,\n    y = np.sin(x) * 3*np.exp(-x) + np.random.normal(0, 0.2, 100)))\nloess_line = LoessLine(\n    source=df, target='y', feature='x',\n    show_scatter=True, show_fit_ci=True, ax=ax)\nloess_line(\n    kw_scatter=dict(color='black', s=10, alpha=0.5),\n    kw_fit_ci=dict(color='skyblue'),\n    color='deepskyblue')\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\nx = 5*np.random.random(100)\ndf = pd.DataFrame(dict(\n    x = x,\n    y = np.sin(x) * 3*np.exp(-x) + np.random.normal(0, 0.2, 100)))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x'\n    ).plot(\n        dsp.LoessLine,\n        show_scatter=True,\n        show_fit_ci=True,\n        kw_call=dict(\n            kw_scatter=dict(color='black', s=10, alpha=0.5),\n            kw_fit_ci=dict(color='skyblue'),\n            color='deepskyblue'))\n</code></pre>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.model","title":"<code>model = Model_(source=source, target=target, feature=feature)</code>  <code>instance-attribute</code>","text":"<p>The fitted results of the linear regression model.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.show_fit_ci","title":"<code>show_fit_ci = show_fit_ci</code>  <code>instance-attribute</code>","text":"<p>Whether to show the confidence interval for the fitted lowess  line.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.show_scatter","title":"<code>show_scatter = show_scatter</code>  <code>instance-attribute</code>","text":"<p>Whether to show the individual points in the plot.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.__call__","title":"<code>__call__(kw_scatter={}, kw_fit_ci={}, **kwds)</code>","text":"<p>Perform the linear regression plot operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_scatter</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the Axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>kw_fit_ci</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the confidence interval of  the lowess line (Axes <code>fill_between</code> method), by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the fit line plot (Axes <code>plot</code> method).</p> </li> </ul>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/loess-line/#daspi.plotlib.plotter.LoessLine.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/mean-test/","title":"Mean test","text":""},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest","title":"<code>daspi.plotlib.plotter.MeanTest</code>","text":"<p>               Bases: <code>ConfidenceInterval</code></p> <p>Class for creating plotters with error bars representing confidence intervals for the mean.</p> <p>This class is specifically designed for testing the statistical significance of the mean difference between groups or conditions. It uses confidence intervals to visually represent the uncertainty in the mean estimates and allows for a quick assessment of whether the intervals overlap or not.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of groups (variable combinations) for the Bonferroni  adjustment. A good way to do this is to pass  <code>df.groupby(list_of_variates).ngroups</code>, where <code>list_of_variates</code>  is a list containing all the categorical columns in the source  that will be used for the chart to split the data into groups  (hue, categorical features, etc.). Specify 1 to not do a  Bonferroni adjustment. Default is 1</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level for the confidence intervals, by default 0.95.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import MeanTest\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\ntest = MeanTest(\n    source=df, target='y', feature='x', show_center=True,\n    n_groups=df.x.nunique(), confidence_level=0.95, bars_same_color=True,\n    ax=ax)\ntest(kw_center=dict(s=30, marker='_'))\ntest.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.MeanTest,\n        show_center=True,\n        n_groups=df.x.nunique(),\n        confidence_level=0.95,\n        bars_same_color=True,\n        kw_call=dict(kw_center=dict(s=30, marker='_'))\n    ).label() # neded to label the feature tick labels\n</code></pre>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.ci_func","title":"<code>ci_func = ci_func</code>  <code>instance-attribute</code>","text":"<p>Provided function for calculating the confidence intervals.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.confidence_level","title":"<code>confidence_level = confidence_level</code>  <code>instance-attribute</code>","text":"<p>Confidence level for the confidence intervals.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.n_groups","title":"<code>n_groups = n_groups</code>  <code>instance-attribute</code>","text":"<p>Number of unique feature values.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/mean-test/#daspi.plotlib.plotter.MeanTest.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by using the given function `ci_func' and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/parallel-coordinate/","title":"Parallel coordinate","text":""},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate","title":"<code>daspi.plotlib.plotter.ParallelCoordinate</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>This plotter allows to compare the feature of several individual  observations on a set of numeric variables.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the categorical feature variable (coordinates).</p> </li> <li> <code>identity</code>               (<code>str</code>)           \u2013            <p>Column name containing identities of each sample, must occur  once for each coordinate.</p> </li> <li> <code>show_scatter</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the individual points,  by default True.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import matplotlib.pyplot as plt\nfrom daspi import ParallelCoordinate, load_dataset\n\nfig, ax = plt.subplots()\ndf = load_dataset('shoe-sole')\nparallel = ParallelCoordinate(\n    source=df, target='wear', feature='status', identity='tester',\n    show_scatter=True, ax=ax)\nparallel()\nparallel.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = dsp.load_dataset('shoe-sole')\nchart = dsp.SingleChart(\n        source=df,\n        target='wear',\n        feature='status',\n        categorical_feature=True,\n    ).plot(\n        dsp.ParallelCoordinate,\n        identity='tester',\n        show_scatter=True,\n    ).label() # neded to label feature ticks\n</code></pre>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.identity","title":"<code>identity = identity</code>  <code>instance-attribute</code>","text":"<p>Column name containing identities of each sample.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.show_scatter","title":"<code>show_scatter = show_scatter</code>  <code>instance-attribute</code>","text":"<p>Whether to show the individual points or not.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the parallel coordinate plot</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the fit line plot (Axes <code>plot</code> method).</p> </li> </ul>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/parallel-coordinate/#daspi.plotlib.plotter.ParallelCoordinate.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/pareto/","title":"Pareto","text":""},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto","title":"<code>daspi.plotlib.plotter.Pareto</code>","text":"<p>               Bases: <code>Bar</code></p> <p>A plotter to perform a pareto chart that extends the Bar plotter class.</p> <p>A Pareto chart is a type of chart that combines a bar graph and a  line graph. It is used to display and analyze data in order to  prioritize and identify the most significant factors contributing  to a particular phenomenon or problem. The line graph in a Pareto  chart shows the cumulative percentage of the total, which helps  identify the point at which a significant portion of the cumulative  total is reached.</p> <p>Pareto charts are commonly used in quality control, process  improvement, and decision-making processes. They allow users to  visually identify and focus on the most significant factors that  contribute to a problem or outcome, enabling them to allocate  resources and address the most critical issues first.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot.</p> </li> <li> <code>highlight</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The feature value whose bar should be highlighted in the  diagram, by default None.</p> </li> <li> <code>highlight_color</code>               (<code>str</code>, default:                   <code>BAD</code> )           \u2013            <p>The color to use for highlighting, by default <code>COLOR.BAD</code>.</p> </li> <li> <code>highlighted_as_last</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the highlighted bar should be at the end, by default True.</p> </li> <li> <code>no_percentage_line</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to draw a line as cumulative percentage, by default True</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>Width of the bars, by default <code>CATEGORY.FEATURE_SPACE</code>.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>A pandas Series method to use for aggregating target values  within each feature level. Like 'sum', 'count' or similar that returns a scalar, by default None.</p> </li> <li> <code>kw_method</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to be passed to the method, by default {}.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Pareto\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = list('abcdefghijklmno'),\n    y = list(100/x for x in range(1, 16))))\npareto = Pareto(\n    source=df, target='y', feature='x', ax=ax)\npareto()\n</code></pre> <p>You can also combine and highlight small frequencies:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Pareto\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = list('abcdefghijklmno'),\n    y = list(100/x for x in range(1, 16))))\nlow_values = df.y &lt;= 10\ndf2 = df[~low_values].copy()\ndf2.loc[len(df)-sum(low_values)] = ('rest', df[low_values].y.sum())\npareto = Pareto(\n    source=df2, target='y', feature='x', highlight='rest', \n    highlight_color='#ff000090', highlighted_as_last=True)\npareto()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = list('abcdefghijklmno'),\n    y = list(100/x for x in range(1, 16))))\nlow_values = df.y &lt;= 10\ndf2 = df[~low_values].copy()\ndf2.loc[len(df)-sum(low_values)] = ('rest', df[low_values].y.sum())\nchart = dsp.SingleChart(\n        source=df2,\n        target='y',\n        feature='x',\n    ).plot(\n        dsp.Pareto,\n        highlight='rest',\n        highlight_color=dsp.COLOR.BAD,\n        no_percentage_line=False\n    )\n</code></pre> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If 'categorical_feature' is True, coming from Chart objects.</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If an other Axes object in this Figure instance shares the feature axis.</p> </li> </ul>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.bars","title":"<code>bars</code>  <code>property</code>","text":"<p>Get a list of BarContainer objects representing the bars in the plot.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.highlight","title":"<code>highlight = highlight</code>  <code>instance-attribute</code>","text":"<p>The feature value whose bar should be highlighted in the chart.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.highlight_color","title":"<code>highlight_color = highlight_color</code>  <code>instance-attribute</code>","text":"<p>The color to use for highlighting.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.highlighted_as_last","title":"<code>highlighted_as_last = highlighted_as_last</code>  <code>instance-attribute</code>","text":"<p>Whether the highlighted bar should be at the end.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.indices","title":"<code>indices</code>  <code>property</code>","text":"<p>Get arranged index values to access the target data (from  source data) in the order to be plotted.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.kw_method","title":"<code>kw_method = kw_method</code>  <code>instance-attribute</code>","text":"<p>The provided keyword arguments to be passed to the method.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.method","title":"<code>method = method</code>  <code>instance-attribute</code>","text":"<p>The provided pandas Series method to use for aggregating target values.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.no_percentage_line","title":"<code>no_percentage_line = no_percentage_line</code>  <code>instance-attribute</code>","text":"<p>Whether to draw the percentage line and the percentage text.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.shared_feature_axes","title":"<code>shared_feature_axes</code>  <code>property</code>","text":"<p>True if any other ax in this figure shares the feature axes.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.stack","title":"<code>stack = stack</code>  <code>instance-attribute</code>","text":"<p>Whether to stack the bars.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.t_base","title":"<code>t_base</code>  <code>property</code>","text":"<p>Get the base values for the bars (target), contains zeros  when not stacked.</p> <p>The base values are calculated based on existing bars in the plot. If stacking is enabled, the base values are updated to reflect the top of the existing bars at each feature position. If stacking is disabled, the base values are simply zeros.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>Width of the bars.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get the values used for the x-axis so that the target is  displayed in descending order and the highlighted bar is at the end (if so specified).</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get the values used for the y-axis so that the target is  displayed in descending order and the highlighted bar is at the end (if so specified).</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the pareto plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes <code>bar</code> (or 'barh' if target_on_y is False) method.</p> </li> </ul>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.add_percentage_texts","title":"<code>add_percentage_texts()</code>","text":"<p>Add percentage texts on top of major grids</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/pareto/#daspi.plotlib.plotter.Pareto.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the given Series method on the target data if given  and return the transformed data. If no method is given, the  target data is adopted directly.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>int | float</code>)           \u2013            <p>Base location (offset) of feature axis coming from  `feature_grouped' generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>When transformed target data (or original data if no method is specified) is non-scalar.</p> </li> </ul>"},{"location":"plotlib/plotter/plotter/","title":"Plotter","text":""},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter","title":"<code>daspi.plotlib.plotter.Plotter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for creating plotters.</p> <p>This class serves as a blueprint for plotter implementations,  facilitating the visualization of data from a given source.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>DataFrame</code>)           \u2013            <p>A long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>The column name of the target variable to be plotted.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The column name of the feature variable to be plotted.  Defaults to an empty string ('').</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>A flag indicating whether the target variable is plotted on the  y-axis. Defaults to True.</p> </li> <li> <code>color</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>The color used for drawing the plot elements. If None, the first  color from the color cycle is used. Defaults to None.</p> </li> <li> <code>marker</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for scatter plots. For available markers, see: https://matplotlib.org/stable/api/markers_api.html.  Defaults to None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawnaccording to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, no changes are  made, and the axes are displayed according to the stylesheet. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that are ignored in this class but  may be used for compatibility with chart objects.</p> </li> </ul> Notes <p>This class is intended to be subclassed, and specific plotting  functionality should be implemented in derived classes.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.kw_default","title":"<code>kw_default</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Override this property to provide the default keyword  arguments for plotting as read-only.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.__call__","title":"<code>__call__()</code>  <code>abstractmethod</code>","text":"<p>Perform the plotting operation.</p> <p>This method should be overridden by subclasses to provide the  specific plotting functionality.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/plotter/#daspi.plotlib.plotter.Plotter.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/probability/","title":"Probability","text":""},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability","title":"<code>daspi.plotlib.plotter.Probability</code>","text":"<p>               Bases: <code>LinearRegressionLine</code></p> <p>A Q-Q and P-P probability plotter that extends the  LinearRegressionLine class.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>dist</code>               (<code>scipy stats rv_continuous</code>, default:                   <code>'norm'</code> )           \u2013            <p>The probability distribution use for creating feature data (the theoretical values).</p> </li> <li> <code>kind</code>               (<code>Literal['qq', 'pp', 'sq', 'sp']</code>, default:                   <code>'sq'</code> )           \u2013            <p>The type of probability plot to create. The first letter corresponds to the target, the second to the feature. Defaults to 'sq': - qq: target = sample quantile; feature = theoretical     quantile - pp: target = sample percentile; feature = theoretical      percentile - sq: target = sample data; feature = theoretical quantiles - sp: target = sample data, feature = theoretical     percentiles</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>show_scatter</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the individual points,  by default True.</p> </li> <li> <code>show_fit_ci</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the confidence interval for the fitted line as filled area, by default False.</p> </li> <li> <code>show_pred_ci</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the confidence interval for  predictions as additional lines, by default False.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Probability\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    y = np.random.weibull(a=1, size=100)))\nprob_line = Probability(\n    source=df, target='y', kind='pp', show_scatter=True, show_fit_ci=True,\n    ax=ax)\nprob_line(\n    kw_scatter=dict(color='black', s=10, alpha=0.5),\n    kw_fit_ci=dict(color='skyblue'),\n    color='deepskyblue')\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    y = np.random.weibull(a=1, size=100)))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x'\n    ).plot(\n        dsp.Probability,\n        kind='pp',\n        show_scatter=True,\n        show_fit_ci=True,\n        kw_call=dict(\n            kw_scatter=dict(color='black', s=10, alpha=0.5),\n            kw_fit_ci=dict(color='skyblue'),\n            color='deepskyblue')\n    )\n</code></pre> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If given kind is not one of 'qq', 'pp', 'sq' or 'sp'</p> </li> </ul>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.dist","title":"<code>dist = DistributionEstimator(source[target], dist)</code>  <code>instance-attribute</code>","text":"<p>The distribution estimator used for creating feature data.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.fit","title":"<code>fit = PLOTTER.FITTED_VALUES</code>  <code>instance-attribute</code>","text":"<p>The name of the column containing the fitted values as defined  in the PLOTTER.FITTED_VALUES.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.kind","title":"<code>kind = kind</code>  <code>instance-attribute</code>","text":"<p>The type of probability plot to create.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.model","title":"<code>model = sm.OLS(df[target], sm.add_constant(df[feature])).fit()</code>  <code>instance-attribute</code>","text":"<p>The fitted results of the linear regression model.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.sample_data","title":"<code>sample_data</code>  <code>property</code>","text":"<p>Get fitted samples (target data) according to given kind</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.show_fit_ci","title":"<code>show_fit_ci = show_fit_ci</code>  <code>instance-attribute</code>","text":"<p>Whether to show the confidence interval for the fitted line.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.show_pred_ci","title":"<code>show_pred_ci = show_pred_ci</code>  <code>instance-attribute</code>","text":"<p>Whether to show the confidence interval for the predictions.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.show_scatter","title":"<code>show_scatter = show_scatter</code>  <code>instance-attribute</code>","text":"<p>Whether to show the individual points in the plot.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.theoretical_data","title":"<code>theoretical_data</code>  <code>property</code>","text":"<p>Get theoretical data (quantiles or percentiles) according to  the given kind.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.x_fit","title":"<code>x_fit</code>  <code>property</code>","text":"<p>Get values used for x-axis for fitted line (read-only).</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.y_fit","title":"<code>y_fit</code>  <code>property</code>","text":"<p>Get values used for y-axis for fitted line (read-only)</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.__call__","title":"<code>__call__(kw_scatter={}, kw_fit_ci={}, kw_pred_ci={}, **kwds)</code>","text":"<p>Perform the probability plot operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_scatter</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the Axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>kw_fit_ci</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the confidence interval of  the fitted line (Axes <code>fill_between</code> method), by default {}.</p> </li> <li> <code>kw_pred_ci</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the confidence interval of the predictions (Axes plot method), by default {}</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the fit line plot (Axes <code>plot</code> method).</p> </li> </ul>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.ci_data","title":"<code>ci_data()</code>","text":"<p>Get confidence interval for prediction and fitted line as  DataFrame.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.format_axis","title":"<code>format_axis()</code>","text":"<p>Format the x-axis and y-axis based on the probability plot  type.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/probability/#daspi.plotlib.plotter.Probability.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/proportion-test/","title":"Proportion test","text":""},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest","title":"<code>daspi.plotlib.plotter.ProportionTest</code>","text":"<p>               Bases: <code>ConfidenceInterval</code></p> <p>Class for creating plotters with error bars representing  confidence intervals for proportion (events/observation).</p> <p>This class is specifically designed for testing the statistical significance of proportions. It uses confidence intervals to visually represent the uncertainty in the variation estimates and allows for a quick assessment of whether the intervals overlap or not.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name to use for the target variable. If falsy, the name will be formed from the specified <code>events</code> and <code>observations</code>  with a \"/\" character in between.</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of groups (variable combinations) for the Bonferroni  adjustment. A good way to do this is to pass  <code>df.groupby(list_of_variates).ngroups</code>, where <code>list_of_variates</code>  is a list containing all the categorical columns in the source  that will be used for the chart to split the data into groups  (hue, categorical features, etc.). Specify 1 to not do a  Bonferroni adjustment. Default is 1</p> </li> <li> <code>events</code>               (<code>str</code>)           \u2013            <p>Column name containing the values of counted events for each feature.</p> </li> <li> <code>observations</code>               (<code>str</code>)           \u2013            <p>Column name containing the values of counted observations for each feature.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>method</code>               (<code>Literal['sum', 'mean', 'median']</code>, default:                   <code>'sum'</code> )           \u2013            <p>A pandas Series method to use for aggregating target values  within each feature level. This method is only required if there  is more than one value for number of observations and number of  events for each factor level. Otherwise it is ignored,  by default 'sum'.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level for the confidence intervals, by default 0.95.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import ProportionTest, ProcessEstimator, SpecLimits, Bar\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 100 + ['second'] * 100 + ['third'] * 100,\n    y = (list(np.random.normal(loc=3, scale=1, size=100))\n        + list(np.random.normal(loc=4, scale=1, size=100))\n        + list(np.random.normal(loc=2, scale=1, size=100)))))\nspec_limits = SpecLimits(upper=4.3)\n\n# Create data that records how many are out of specification\ndata = pd.DataFrame()\nfor name, group in df.groupby('x'):\n    y = ProcessEstimator(group['y'], spec_limits=spec_limits)\n    temp = pd.DataFrame(dict(\n        x = [name],\n        proportion = y.n_nok / y.n_samples,\n        events = y.n_nok,\n        observations = y.n_samples))\n    data = pd.concat([data, temp], ignore_index=True, axis=0)\n\n# Now plot it in combination with a bar chart\nbar = Bar(source=data, target='proportion', feature='x', ax=ax)\nbar()\ntest = ProportionTest(\n    source=data, target='proportion', feature='x', events='events', \n    observations='observations', show_center=False, n_groups=data.x.nunique(), \n    confidence_level=0.95, bars_same_color=True,)\ntest()\ntest.label_feature_ticks()\ntest.target_as_percentage()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 100 + ['second'] * 100 + ['third'] * 100,\n    y = (list(np.random.normal(loc=3, scale=1, size=100))\n        + list(np.random.normal(loc=4, scale=1, size=100))\n        + list(np.random.normal(loc=2, scale=1, size=100)))))\nspec_limits = dsp.SpecLimits(upper=4.3)\n\n# Create data that records how many are out of specification\ndata = pd.DataFrame()\nfor name, group in df.groupby('x'):\n    y = ProcessEstimator(group['y'], spec_limits=spec_limits)\n    temp = pd.DataFrame(dict(\n        x = [name],\n        proportion = y.n_nok / y.n_samples,\n        events = y.n_nok,\n        observations = y.n_samples))\n    data = pd.concat([data, temp], ignore_index=True, axis=0)\n\n# Now plot it in combination with a bar chart\nchart = dsp.SingleChart(\n        source=data,\n        target='proportion',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.ProportionTest,\n        events='events', \n        observations='observations',\n        show_center=False,\n        n_groups=data.x.nunique(), \n        confidence_level=0.95,\n        bars_same_color=True,\n    ).plot(\n        dsp.Bar,\n    ).label() # neded to label the feature tick labels\n</code></pre> Notes <p>This class is a bit of a hack, as it creates its own target variable  using the ratio of events / observations. This allows it to  visualize proportions directly, even if a target column is not  explicitly provided.</p> <p>A recommended and robust approach is to precompute the proportion  yourself and pass it as the target variable. This gives you full  control over how the proportion is calculated and ensures  compatibility with other plotters or axes.</p> <p>See the Examples section for a demonstration of this approach, where  the proportion is computed manually and passed to both the Bar and  ProportionTest plotters. This method is especially useful when  combining multiple visualizations or when working with  pre-aggregated data.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.ci_func","title":"<code>ci_func = ci_func</code>  <code>instance-attribute</code>","text":"<p>Provided function for calculating the confidence intervals.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.confidence_level","title":"<code>confidence_level = confidence_level</code>  <code>instance-attribute</code>","text":"<p>Confidence level for the confidence intervals.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.method","title":"<code>method = method</code>  <code>instance-attribute</code>","text":"<p>The provided Pandas Series method for aggregating events and observations (if there are multiple) per feature level.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.n_groups","title":"<code>n_groups = n_groups</code>  <code>instance-attribute</code>","text":"<p>Number of unique feature values.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/proportion-test/#daspi.plotlib.plotter.ProportionTest.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by using the given function `ci_func' and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/","title":"Quantile boxes","text":""},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes","title":"<code>daspi.plotlib.plotter.QuantileBoxes</code>","text":"<p>               Bases: <code>SpreadOpacity</code>, <code>TransformPlotter</code></p> <p>TransformPlotter for visualizing quantiles through box plots.</p> <p>This class is designed to create box plots that represent various  quantiles of the data based on specified ranges. The ranges are used to calculate the lower and upper quantiles, which define the  boundaries of the boxes.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>A long-format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>The column name of the target variable to be plotted.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The column name of the feature variable for the plot, by  default an empty string.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the quantiles: - <code>eval</code>: The strategy is determined according to the given    evaluate function. If none is given, the internal <code>evaluate</code>   method is used. - <code>fit</code>: First, the distribution that best represents the    process data is searched for and then the agreed process    spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal    distribution. The variation tolerance is then calculated as    agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance    are read directly from the data.</p> <p>Default is 'data'.</p> </li> <li> <code>agreements</code>               (<code>Tuple[float, ...] or Tuple[int, ...]</code>, default:                   <code>AGREEMENTS</code> )           \u2013            <p>Specifies the tolerated process variation for calculating  quantiles. These quantiles are used to represent the filled area  with different opacity, thus highlighting the quantiles. The  agreements can be either integers or floats, determining the  process variation tolerance in the following ways: - If integers, the quantiles are determined using the normal    distribution (agreement * \u03c3), e.g., agreement = 6 covers    ~99.75% of the data. - If floats, values must be between 0 and 1, interpreted as    acceptable proportions for the quantiles, e.g., 0.9973    corresponds to ~6\u03c3.</p> <p>Default is <code>DEFAULT.AGREEMENTS</code> = (2, 4, 6), corresponding to  (\u00b11\u03c3, \u00b12\u03c3, \u00b13\u03c3).</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default <code>DIST.COMMON</code></p> </li> <li> <code>vary_width</code>               (<code>float</code>, default:                   <code>True</code> )           \u2013            <p>If True, the center box is the widest, while the outer boxes are  progressively narrower, reflecting the distribution of the data. Defaults to True</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>The width of the boxes. If vary_width is set to True, the  central box has this width, all others are narrower. Defaults to <code>CATEGORY.FEATURE_SPACE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>A flag indicating how to handle missing values in the feature  grouped data: - 'none': No missing values are skipped. - 'all': Grouped data is skipped if all values are missing. - 'any': Grouped data is skipped if any value is missing.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>A flag indicating whether the target variable is plotted on the  y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The color used to draw the box plots. If None, the first color  from the color cycle is used, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that are ignored in this context,  primarily serving to capture any extra arguments when this class  is used within chart objects.</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import QuantileBoxes\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nboxes = QuantileBoxes(\n    source=df, target='y', feature='x', strategy='norm',\n    agreements=(0.25, 0.5, 0.75, 0.95), vary_width=False, width=0.2,\n    ax=ax)\nboxes()\nboxes.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True # neded to label feature ticks\n    ).plot(\n        dsp.QuantileBoxes,\n        strategy='norm',\n        agreements=(0.25, 0.5, 0.75, 0.95),\n        vary_width=False,\n        width=0.2\n    ).label() # neded to label feature ticks\n</code></pre>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.estimation","title":"<code>estimation</code>  <code>instance-attribute</code>","text":"<p>The estimator used to calculate the quantiles.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.vary_width","title":"<code>vary_width = vary_width</code>  <code>instance-attribute</code>","text":"<p>Flag that indicates whether the width of the boxes should vary,  with the widest box in the middle and the narrower one towards the  outside. If False, all have the same width.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.width","title":"<code>width = width / len(agreements) if vary_width else width</code>  <code>instance-attribute</code>","text":"<p>The maximum width of the center box in the plot.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the quantiles plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes  <code>fill_between</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.quantiles","title":"<code>quantiles(target_data)</code>","text":"<p>Calculate the quantiles in ascending order:</p> <p>Parameters:</p> <ul> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>quantiles in ascending order</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.subgroup_values","title":"<code>subgroup_values(sequence, quantiles)</code>","text":"<p>Generate a list of subgroup values based on the agreements.</p> <p>This method creates a list of subgroup values derived from the  instance's agreements. It iterates through the agreements and  appends each agreement to the subgroup list. If the current  agreement is the same as the first agreement, the last  subgroup value is appended instead.</p> <p>Returns:</p> <ul> <li> <code>List[float | int]:</code>           \u2013            <p>A list of subgroup values, which can include both floats  and integers.</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Generates the spread values for the beeswarm plot by  arranging the target data into bins.</p> <p>The method divides the input data into bins based on the  specified number of bins and calculates the spread of values  within each bin to create a horizontal distribution.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float</code>)           \u2013            <p>The center position on the feature axis where the beeswarm  values will be centered.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data, coming from `feature_grouped'  generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/quantile-boxes/#daspi.plotlib.plotter.QuantileBoxes.width_values","title":"<code>width_values()</code>","text":"<p>Returns the widths of the boxes in the plot.</p>"},{"location":"plotlib/plotter/scatter/","title":"Scatter","text":""},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation","title":"<code>daspi.plotlib.plotter.CategoricalObservation</code>","text":"<p>               Bases: <code>TransformPlotter</code></p> <p>TransformPlotter for visualizing the observation order, but for  categorical features.</p> <p>This class is designed to create a scatter, line, or a combination  of these for categorical features. However, the individual points  are displayed for each feature category, ordered by observation  order, within the available categorical range.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>show_line</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to draw a line between the individual  points, by default True</p> </li> <li> <code>show_scatter</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the individual points,  by default True.</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>The width of the scatter range, by default <code>CATEGORY.FEATURE_SPACE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the scatter plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import CategoricalObservation\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nobservation = CategoricalObservation(\n    source=df, target='y', feature='x', ax=ax,\n    show_line=True, show_scatter=True,)\nobservation()\nobservation.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True # neded to label feature ticks\n    ).plot(\n        dsp.CategoricalObservation,\n        show_line=True,\n        show_scatter=True,\n    ).label() # neded to label feature ticks\n</code></pre>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.show_line","title":"<code>show_line = show_line</code>  <code>instance-attribute</code>","text":"<p>Whether to draw a line between the individual points.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.show_scatter","title":"<code>show_scatter = show_scatter</code>  <code>instance-attribute</code>","text":"<p>Whetter to draw the scatter points.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>The width of the categorical range.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.__call__","title":"<code>__call__(**kwds)</code>","text":"<p>Perform the plot operation.</p> <p>Parameters:</p> <ul> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the Axes  <code>plot</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.observation","title":"<code>observation(loc, size)</code>","text":"<p>Creates a uniform sequence of numbers with the number  <code>size</code> from <code>loc</code> minus half the width to <code>loc</code> plus half  the width.</p> <p>Parameters:</p> <ul> <li> <code>loc</code>               (<code>float</code>)           \u2013            <p>Center position (feature axis) of the scatter values.</p> </li> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Amount of valaues to generate</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>1D array</code>           \u2013            <p>Evenly distributed values.</p> </li> </ul>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/scatter/#daspi.plotlib.plotter.CategoricalObservation.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Normally randomize the target data for each feature value in  the feature axis direction.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>int | float</code>)           \u2013            <p>Base location (offset) of feature axis coming from  `feature_grouped' generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/spread-width/","title":"Spread width","text":""},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth","title":"<code>daspi.plotlib.plotter.SpreadWidth</code>","text":"<p>               Bases: <code>Errorbar</code></p> <p>Class for creating plotters with error bars representing the  spread width.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given    evaluate function. If none is given, the internal <code>evaluate</code>   method is used. - <code>fit</code>: First, the distribution that best represents the    process data is searched for and then the agreed process    spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal    distribution. The variation tolerance is then calculated as    agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance    are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int or float</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal    distribution agreementsigma,    e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of the data.    The upper and lower permissible quantiles are then    calculated from this. - If float, the value must be between 0 and 1.This value is   then interpreted as the acceptable proportion for the    spread, e.g. 0.9973 (which corresponds to ~ 6 sigma)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default <code>DIST.COMMON</code></p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points (see <code>kind</code>  option). Default is True.</p> </li> <li> <code>kind</code>               (<code>Literal['mean', 'median']</code>, default:                   <code>'mean'</code> )           \u2013            <p>The type of center to plot ('mean' or 'median'), by default 'mean'.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import SpreadWidth, Beeswarm\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nswarm = Beeswarm(source=df, target='y', feature='x')\nswarm(color=(0.3, )*4)\nspread = SpreadWidth(\n    source=df, target='y', feature='x', strategy='data', agreement=1.0, \n    kind='median', show_center=True, bars_same_color=True,\n    ax=ax)\nspread(kw_center=dict(s=30, marker='_'))\nspread.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.SpreadWidth,\n        strategy='data',\n        agreement=1.0,\n        show_center=True,\n        kind='median',\n        bars_same_color=True,\n        kw_call=dict(kw_center=dict(s=30, marker='_'))\n    ).plot(\n        dsp.Beeswarm,\n        color=(0.3, ) * 4\n    ).label() # neded to label the feature tick labels\n</code></pre> Notes <p>Under the hood, the class <code>daspi.statistics.estimation.Estimator</code> is  used. The error bar then corresponds to the control limits <code>lcl</code> and  ucl` calculated with it.</p> <p>If you want to display the minimum and maximum values (the range),  set agreement to <code>1.0</code> (important: it must be a float) or to  <code>float('inf')</code> and strategy to 'data'. This way, the control limits  correspond to the minimum and maximum of the data.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.agreement","title":"<code>agreement = agreement</code>  <code>instance-attribute</code>","text":"<p>Agreement value for the spread width estimation.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.estimation","title":"<code>estimation</code>  <code>instance-attribute</code>","text":"<p>Estimator instance used for spread width and center estimation.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.kind","title":"<code>kind</code>  <code>property</code> <code>writable</code>","text":"<p>Get and set the type of location ('mean' or 'median') to  plot.</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If neither 'mean' or 'median' is given when setting <code>kind</code>.</p> </li> </ul>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if <code>show_center</code> is True, otherwise '' is returned. By default the marker is '_'  if <code>target_on_y</code> is True, '|' otherwise (read-only).</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.possible_dists","title":"<code>possible_dists = possible_dists</code>  <code>instance-attribute</code>","text":"<p>Tuple of possible distributions for the spread width estimation.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.strategy","title":"<code>strategy = strategy</code>  <code>instance-attribute</code>","text":"<p>Strategy for estimating the spread width.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/spread-width/#daspi.plotlib.plotter.SpreadWidth.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data using the  <code>Estimator</code> class and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/standard-error-mean/","title":"Standard error mean","text":""},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean","title":"<code>daspi.plotlib.plotter.StandardErrorMean</code>","text":"<p>               Bases: <code>Errorbar</code></p> <p>Class for creating plotters with error bars representing the standard error of the mean.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black,</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> <p>by default False</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import StandardErrorMean\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nsem = StandardErrorMean(\n    source=df, target='y', feature='x',\n    show_center=True, bars_same_color=True, ax=ax)\nsem(kw_center=dict(s=30, marker='_'))\nsem.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.StandardErrorMean,\n        show_center=True,\n        bars_same_color=True,\n        kw_call=dict(kw_center=dict(s=30, marker='_'))\n    ).label() # neded to label the feature tick labels\n</code></pre>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/standard-error-mean/#daspi.plotlib.plotter.StandardErrorMean.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data using the  <code>Estimator</code> class and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/stem/","title":"Stem","text":""},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem","title":"<code>daspi.plotlib.plotter.Stem</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>A stem plotter that extends the Plotter base class.</p> <p>This class is designed to create a stem plot using the data provided  in the source DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>A long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot.</p> </li> <li> <code>bottom</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The Y/X position of the baseline (depending on the orientation  or <code>target_on_y</code>). Default is 0.</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the  y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the markers. If None, the first color  is taken from the color cycle, by default None.</p> </li> <li> <code>line_color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the vertical lines. If None, the same color is taken as the color of the markers. Default is None</p> </li> <li> <code>base_color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the base line. If None, the same color is taken as the color of the markers. Default is None</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the stem plot. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn  according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, no changes are  made, and the axes are displayed according to the stylesheet. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that may be used for compatibility  with other chart objects.</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Stem\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame({'x': list(x*np.pi/25 for x in range(50))})\ndf['y'] = np.cos(df['x'])\nstem = Stem(\n    source=df, target='y', feature='x', target_on_y=False, bottom=1,\n    color='deepskyblue', line_color='steelblue', base_color='skyblue',\n    ax=ax)\nstem(alpha=0.2, line_style='--', base_line_style='-.')\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame({'x': list(x*np.pi/25 for x in range(50))})\ndf['y'] = np.cos(df['x'])\n\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        target_on_y=False\n    ).plot(\n        dsp.Stem,\n        bottom=1,\n        color='deepskyblue',\n        line_color='steelblue',\n        base_color='skyblue',\n        kw_call=dict(alpha=0.2, line_style='--', base_line_style='-.'))\n</code></pre> Notes <p>To change the markers, vertical lines and base line when drawing use the keword arguments <code>markerfmt</code>, <code>linefmt</code> and <code>basefmt</code>. For further information see: https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.stem.html</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.base_color","title":"<code>base_color = base_color if base_color is not None else self.color</code>  <code>instance-attribute</code>","text":"<p>Color to be used to draw the base line. If None, the same color is taken as the color of the markers.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.bottom","title":"<code>bottom = bottom</code>  <code>instance-attribute</code>","text":"<p>The Y/X position of the baseline (depending on the orientation or  <code>target_on_y</code>).</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.line_color","title":"<code>line_color = line_color if line_color is not None else self.color</code>  <code>instance-attribute</code>","text":"<p>Color to be used to draw the vertical lines. If None, the same color is taken as the color of the markers.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.__call__","title":"<code>__call__(alpha=COLOR.MARKER_ALPHA, line_style=None, base_line_style=None, **kwds)</code>","text":"<p>Perform the stem plot operation.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>MARKER_ALPHA</code> )           \u2013            <p>Transparency of the marker. Default is  <code>COLOR.MARKER_ALPHA</code>.</p> </li> <li> <code>line_style</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Style of the line connecting the marker to the baseline. This option is ignored if it is None or <code>linefmt</code> is in  <code>kwds</code>. Default is <code>None</code>.</p> </li> <li> <code>base_line_style</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Style of the baseline. This option is ignored if it is  None or <code>basefmt</code> is in <code>kwds</code>. Default is <code>None</code>.</p> </li> <li> <code>**kwds</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to be passed to the Axes  <code>stem</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/stem/#daspi.plotlib.plotter.Stem.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/stripe/","title":"Stripe","text":""},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe","title":"<code>daspi.plotlib.plotter.Stripe</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for drawing a stripe (line or area) on  Matplotlib Axes.</p> <p>A stripe is a visual element used to highlight a specific region or  value on a plot, such as a threshold line or a band of interest.  This class provides a flexible interface for defining the appearance  and behavior of such elements.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The label of the stripe as it appears in the legend.</p> </li> <li> <code>position</code>               (<code>float</code>)           \u2013            <p>The central position of the stripe on the x- or y-axis.</p> </li> <li> <code>width</code>               (<code>float</code>)           \u2013            <p>The width of the stripe.</p> </li> <li> <code>orientation</code>               (<code>(horizontal, vertical)</code>, default:                   <code>'horizontal'</code> )           \u2013            <p>The orientation of the stripe. Defaults to 'horizontal'.</p> </li> <li> <code>color</code>               (<code>str</code>, default:                   <code>STRIPE</code> )           \u2013            <p>The color of the stripe, specified as a named color or hex code. Defaults to <code>COLOR.STRIPE</code>.</p> </li> <li> <code>alpha</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>The transparency level of the stripe, between 0 (fully  transparent) and 1 (fully opaque). Defaults to None.</p> </li> <li> <code>lower_limit</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The lower bound of the stripe relative to the plotting area,  expressed as a proportion between 0 and 1. Defaults to 0.0.</p> </li> <li> <code>upper_limit</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The upper bound of the stripe relative to the plotting area,  expressed as a proportion between 0 and 1. Defaults to 1.0.</p> </li> <li> <code>zorder</code>               (<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>The drawing order of the stripe relative to other plot elements. Higher values are drawn on top. Defaults to 0.7.</p> </li> <li> <code>show_position</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include the position value in the legend label. Defaults to False.</p> </li> <li> <code>decimals</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>Number of decimal places to use when formatting the position  value in the label. If None, the number is determined  automatically based on the magnitude of the position.  Defaults to None.</p> </li> </ul> Notes <p>This is an abstract base class. Subclasses must implement the  <code>__call__</code> method to draw the stripe on a given Axes, and the  <code>handle</code> property to return the legend handle.</p> <p>The <code>label</code> property automatically wraps the label in dollar signs  (<code>$</code>) so that it is interpreted as a LaTeX-style math expression in  the legend. If <code>show_position</code> is True, the position value is  appended to the label.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.alpha","title":"<code>alpha = alpha</code>  <code>instance-attribute</code>","text":"<p>Value used for blending the color.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.color","title":"<code>color = color</code>  <code>instance-attribute</code>","text":"<p>The color of the stripe as string or hex value.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.decimals","title":"<code>decimals</code>  <code>property</code> <code>writable</code>","text":"<p>Get number of decimals used to format position value in label. If None is given for setting decimals, it is determined  based on the size of the position value see <code>determine_decimals</code> method.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.handle","title":"<code>handle</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the handle of the stripe used for legend.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.identity","title":"<code>identity</code>  <code>property</code>","text":"<p>Get the identity of the strip. Needed so that it only appears once in the legend. The identity is composed of the label and the color (read-only).</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.label","title":"<code>label</code>  <code>property</code> <code>writable</code>","text":"<p>Get the label of the stripe. The label is always returned with a leading and trailing $ sign so that it is interpreted as a mathematical expression in the legend.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.linestyle","title":"<code>linestyle</code>  <code>instance-attribute</code>","text":"<p>The linestyle of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.lower_limit","title":"<code>lower_limit = lower_limit</code>  <code>instance-attribute</code>","text":"<p>The lower limit (start) of the stripe relative to the plotting area. Should be between 0 and 1.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.orientation","title":"<code>orientation = orientation</code>  <code>instance-attribute</code>","text":"<p>The orientation of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.position","title":"<code>position = position</code>  <code>instance-attribute</code>","text":"<p>The position of the stripe on the x- or y-axis.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.show_position","title":"<code>show_position = show_position</code>  <code>instance-attribute</code>","text":"<p>Whether position value of the stripe should be displayed the  label.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.upper_limit","title":"<code>upper_limit = upper_limit</code>  <code>instance-attribute</code>","text":"<p>The upper limit (end) of the stripe relative to the plotting area. Should be between 0 and 1.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>The width of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.zorder","title":"<code>zorder = zorder</code>  <code>instance-attribute</code>","text":"<p>The zorder of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.__call__","title":"<code>__call__(ax)</code>  <code>abstractmethod</code>","text":"<p>Draw the stripe on the given Axes object.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.Stripe.determine_decimals","title":"<code>determine_decimals(value)</code>  <code>staticmethod</code>","text":"<p>Determine the number of decimal places to format values for  e.g. legend labels. The number of decimal places depends on the size of the provided value.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan","title":"<code>daspi.plotlib.plotter.StripeSpan</code>","text":"<p>               Bases: <code>Stripe</code></p> <p>Concrete implementation of <code>Stripe</code> for drawing wide spans (bands)  on Matplotlib Axes.</p> <p>This class is used to highlight a continuous region between two  positions on a plot, such as confidence intervals, tolerance bands,  or shaded areas of interest. It supports both direct specification  of the lower and upper bounds, or a central position with width.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The label of the stripe as it appears in the legend.</p> </li> <li> <code>lower_position</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>The lower bound of the stripe on the x- or y-axis. Must be  provided if <code>position</code> and <code>width</code> are not given. Defaults to None.</p> </li> <li> <code>upper_position</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>The upper bound of the stripe on the x- or y-axis. Must be  provided if <code>position</code> and <code>width</code> are not given. Defaults to None.</p> </li> <li> <code>position</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>The central position of the stripe. Must be provided if  <code>lower_position</code> and <code>upper_position</code> are not given. Defaults to None.</p> </li> <li> <code>width</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>The width of the stripe. Must be provided if <code>lower_position</code>  and <code>upper_position</code> are not given. Defaults to None.</p> </li> <li> <code>orientation</code>               (<code>(horizontal, vertical)</code>, default:                   <code>'horizontal'</code> )           \u2013            <p>The orientation of the stripe. Defaults to 'horizontal'.</p> </li> <li> <code>color</code>               (<code>str</code>, default:                   <code>STRIPE</code> )           \u2013            <p>The fill color of the stripe. Can be a named color or hex code. Defaults to <code>COLOR.STRIPE</code>.</p> </li> <li> <code>alpha</code>               (<code>float or None</code>, default:                   <code>CI_ALPHA</code> )           \u2013            <p>Transparency level of the stripe, between 0 (transparent) and 1  (opaque). Defaults to <code>COLOR.CI_ALPHA</code>.</p> </li> <li> <code>lower_limit</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The lower limit of the stripe relative to the plotting area  (0 to 1). Defaults to 0.0.</p> </li> <li> <code>upper_limit</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The upper limit of the stripe relative to the plotting area  (0 to 1). Defaults to 1.0.</p> </li> <li> <code>zorder</code>               (<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>Drawing order of the stripe. Higher values are drawn above lower  ones. Defaults to 0.7.</p> </li> <li> <code>border_linewidth</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Width of the border line. Can also be set via <code>lw</code> or  <code>linewidth</code> in <code>**kwds</code>. Defaults to 0.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for appearance customization.  Priority order: - Line width: <code>lw</code>, <code>linewidth</code>, then <code>border_linewidth</code> - Color: <code>c</code>, then <code>color</code> - Style: <code>ls</code>, then <code>linestyle</code></p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Line, StripeSpan, SpecLimits, COLOR\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(x = np.random.weibull(a=1.5, size=100)))\nline = Line(source=df, target='x', ax=ax)\nline(marker='o')\nspec_limits=SpecLimits(lower=0, upper=2.5)\nok_area = StripeSpan(\n    label=r'OK',\n    lower_position=spec_limits.lower,\n    upper_position=spec_limits.upper,\n    color=COLOR.GOOD,\n    orientation='horizontal')\nok_area(ax=ax)\n\nax.legend([ok_area.handle], [ok_area.label])\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(x = np.random.weibull(a=1.5, size=100)))\nspec_limits=dsp.SpecLimits(lower=0, upper=2.5)\nok_area = StripeSpan(\n    label=r'OK',\n    lower_position=spec_limits.lower,\n    upper_position=spec_limits.upper,\n    color=COLOR.GOOD,\n    orientation='horizontal')\nchart = dsp.SingleChart(\n        source=df,\n        target='x',\n    ).plot(\n        dsp.Line,\n        kw_call={'marker': 'o'}\n    ).stripes(\n        [ok_area]\n    ).label() # neded to add the legend\n</code></pre> Notes <p>You must specify either: - <code>lower_position</code> and <code>upper_position</code>, or - <code>position</code> and <code>width</code></p> <p>but not both. The class will compute the missing values accordingly.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.alpha","title":"<code>alpha = alpha</code>  <code>instance-attribute</code>","text":"<p>Value used for blending the color.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.border_linewidth","title":"<code>border_linewidth = kwds.get('lw', kwds.get('linewidth', border_linewidth))</code>  <code>instance-attribute</code>","text":"<p>Width of the border line. Could also be set during initialisation via <code>lw</code> or <code>linewidth</code>.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.color","title":"<code>color = color</code>  <code>instance-attribute</code>","text":"<p>The color of the stripe as string or hex value.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.decimals","title":"<code>decimals</code>  <code>property</code> <code>writable</code>","text":"<p>Get number of decimals used to format position value in label. If None is given for setting decimals, it is determined  based on the size of the position value see <code>determine_decimals</code> method.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.handle","title":"<code>handle</code>  <code>property</code>","text":"<p>Get the handle of the stripe used for legend.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.identity","title":"<code>identity</code>  <code>property</code>","text":"<p>Get the identity of the strip. Needed so that it only appears once in the legend. The identity is composed of the label and the color (read-only).</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.label","title":"<code>label</code>  <code>property</code> <code>writable</code>","text":"<p>Get the label of the stripe. The label is always returned with a leading and trailing $ sign so that it is interpreted as a mathematical expression in the legend.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.linestyle","title":"<code>linestyle</code>  <code>instance-attribute</code>","text":"<p>The linestyle of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.lower_limit","title":"<code>lower_limit = lower_limit</code>  <code>instance-attribute</code>","text":"<p>The lower limit (start) of the stripe relative to the plotting area. Should be between 0 and 1.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.lower_position","title":"<code>lower_position</code>  <code>instance-attribute</code>","text":"<p>Target position of the lower border of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.orientation","title":"<code>orientation = orientation</code>  <code>instance-attribute</code>","text":"<p>The orientation of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.position","title":"<code>position = position</code>  <code>instance-attribute</code>","text":"<p>The position of the stripe on the x- or y-axis.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.show_position","title":"<code>show_position = show_position</code>  <code>instance-attribute</code>","text":"<p>Whether position value of the stripe should be displayed the  label.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.upper_limit","title":"<code>upper_limit = upper_limit</code>  <code>instance-attribute</code>","text":"<p>The upper limit (end) of the stripe relative to the plotting area. Should be between 0 and 1.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.upper_position","title":"<code>upper_position</code>  <code>instance-attribute</code>","text":"<p>Target position of the upper border of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>The width of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.zorder","title":"<code>zorder = zorder</code>  <code>instance-attribute</code>","text":"<p>The zorder of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.__call__","title":"<code>__call__(ax)</code>","text":"<p>Draw the stripe on the given Axes object.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeSpan.determine_decimals","title":"<code>determine_decimals(value)</code>  <code>staticmethod</code>","text":"<p>Determine the number of decimal places to format values for  e.g. legend labels. The number of decimal places depends on the size of the provided value.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine","title":"<code>daspi.plotlib.plotter.StripeLine</code>","text":"<p>               Bases: <code>Stripe</code></p> <p>Concrete implementation of <code>Stripe</code> for drawing straight lines on Matplotlib Axes.</p> <p>This class is used to draw horizontal or vertical lines that highlight specific  positions on a plot, such as thresholds, limits, or reference values. It supports  customization of line style, color, transparency, and legend labeling.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The label of the stripe as it appears in the legend.</p> </li> <li> <code>position</code>               (<code>float</code>)           \u2013            <p>The position of the stripe on the x- or y-axis.</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>WIDTH</code> )           \u2013            <p>The line width of the stripe. Can be overridden by <code>lw</code> or <code>linewidth</code> in <code>**kwds</code>. Defaults to <code>LINE.WIDTH</code>.</p> </li> <li> <code>orientation</code>               (<code>(horizontal, vertical)</code>, default:                   <code>'horizontal'</code> )           \u2013            <p>The orientation of the stripe. Defaults to 'horizontal'.</p> </li> <li> <code>color</code>               (<code>str</code>, default:                   <code>STRIPE</code> )           \u2013            <p>The color of the stripe, specified as a named color or hex code. Can be overridden by <code>c</code> in <code>**kwds</code>. Defaults to <code>COLOR.STRIPE</code>.</p> </li> <li> <code>alpha</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>Transparency level of the stripe, between 0 (transparent) and 1 (opaque). Defaults to None.</p> </li> <li> <code>lower_limit</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The lower bound of the stripe relative to the plotting area (0 to 1). Defaults to 0.0.</p> </li> <li> <code>upper_limit</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The upper bound of the stripe relative to the plotting area (0 to 1). Defaults to 1.0.</p> </li> <li> <code>zorder</code>               (<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>Drawing order of the stripe. Higher values are drawn above lower ones. Defaults to 0.7.</p> </li> <li> <code>show_position</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include the position value in the legend label. Defaults to False.</p> </li> <li> <code>decimals</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>Number of decimal places to use when formatting the position in the label. If None, the number is determined automatically based on the value.</p> </li> <li> <code>linestyle</code>               (<code>LineStyle</code>, default:                   <code>DASHED</code> )           \u2013            <p>The line style of the stripe (e.g., solid, dashed). Can be overridden by <code>ls</code> in <code>**kwds</code>. Defaults to <code>LINE.DASHED</code>.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for fine-tuning appearance. Priority order: - Line width: <code>lw</code>, <code>linewidth</code>, then <code>width</code> - Color: <code>c</code>, then <code>color</code> - Style: <code>ls</code>, then <code>linestyle</code></p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import GaussianKDE, StripeLine, LocationDispersionEstimator\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(x = np.random.weibull(a=1.5, size=1000)))\nkde = GaussianKDE(source=df, target='x', target_on_y=False)\nkde()\nx = LocationDispersionEstimator(df.x)\nmean = StripeLine(\n    label=r'\bar x = 'f'{x.mean:.2f}',\n    position=x.mean,\n    color=\"#145a5aa0\",\n    upper_limit=0.9,\n    orientation='vertical')\nmean(ax=ax)\nmedian = StripeLine(\n    label=r'        ilde x = 'f'{x.median:.2f}',\n    position=x.median,\n    color=\"#5a47149f\",\n    upper_limit=0.9,\n    orientation='vertical')\nmedian(ax=ax)\nax.set(ylim=(0, None))\nax.legend([mean.handle, median.handle], [mean.label, median.label])\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(x = np.random.weibull(a=1.5, size=1000)))\nx = LocationDispersionEstimator(df.x)\nmean = StripeLine(\n    label=r'\bar x = 'f'{x.mean:.2f}',\n    position=x.mean,\n    color=\"#145a5aa0\",\n    upper_limit=0.9,\n    orientation='vertical')\nmedian = StripeLine(\n    label=r'        ilde x = 'f'{x.median:.2f}',\n    position=x.median,\n    color=\"#5a47149f\",\n    upper_limit=0.9,\n    orientation='vertical')\nchart = dsp.SingleChart(\n        source=df,\n        target='x',\n        target_on_y=False\n    ).plot(dsp.GaussianKDE,\n    ).stripes([mean, median]\n    ).label() # neded to add the legend\n</code></pre> <p>The last example only serves to demonstrate how custom lines can be  added. The median and mean are already predefined and can be easily  plotted by setting the appropriate flag. With the following example,  we get a similar result:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(x = np.random.weibull(a=1.5, size=1000)))\nchart = dsp.SingleChart(\n        source=df,\n        target='x',\n        target_on_y=False\n    ).plot(dsp.GaussianKDE,\n    ).stripes(\n        mean=True,\n        median=True,\n    ).label() # neded to add the legend\n</code></pre> Notes <p>This class is part of the DaSPi visualization toolkit and is  designed to integrate seamlessly with other chart components. It  ensures that each stripe is only drawn once per Axes instance.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.alpha","title":"<code>alpha = alpha</code>  <code>instance-attribute</code>","text":"<p>Value used for blending the color.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.color","title":"<code>color = color</code>  <code>instance-attribute</code>","text":"<p>The color of the stripe as string or hex value.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.decimals","title":"<code>decimals</code>  <code>property</code> <code>writable</code>","text":"<p>Get number of decimals used to format position value in label. If None is given for setting decimals, it is determined  based on the size of the position value see <code>determine_decimals</code> method.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.handle","title":"<code>handle</code>  <code>property</code>","text":"<p>Get the handle of the stripe used for legend.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.identity","title":"<code>identity</code>  <code>property</code>","text":"<p>Get the identity of the strip. Needed so that it only appears once in the legend. The identity is composed of the label and the color (read-only).</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.label","title":"<code>label</code>  <code>property</code> <code>writable</code>","text":"<p>Get the label of the stripe. The label is always returned with a leading and trailing $ sign so that it is interpreted as a mathematical expression in the legend.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.linestyle","title":"<code>linestyle = kwds.get('ls', linestyle)</code>  <code>instance-attribute</code>","text":"<p>The linestyle of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.lower_limit","title":"<code>lower_limit = lower_limit</code>  <code>instance-attribute</code>","text":"<p>The lower limit (start) of the stripe relative to the plotting area. Should be between 0 and 1.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.orientation","title":"<code>orientation = orientation</code>  <code>instance-attribute</code>","text":"<p>The orientation of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.position","title":"<code>position = position</code>  <code>instance-attribute</code>","text":"<p>The position of the stripe on the x- or y-axis.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.show_position","title":"<code>show_position = show_position</code>  <code>instance-attribute</code>","text":"<p>Whether position value of the stripe should be displayed the  label.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.upper_limit","title":"<code>upper_limit = upper_limit</code>  <code>instance-attribute</code>","text":"<p>The upper limit (end) of the stripe relative to the plotting area. Should be between 0 and 1.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":"<p>The width of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.zorder","title":"<code>zorder = zorder</code>  <code>instance-attribute</code>","text":"<p>The zorder of the stripe.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.__call__","title":"<code>__call__(ax)</code>","text":"<p>Draw the stripe on the given Axes object.</p>"},{"location":"plotlib/plotter/stripe/#daspi.plotlib.plotter.StripeLine.determine_decimals","title":"<code>determine_decimals(value)</code>  <code>staticmethod</code>","text":"<p>Determine the number of decimal places to format values for  e.g. legend labels. The number of decimal places depends on the size of the provided value.</p>"},{"location":"plotlib/plotter/subplot/","title":"Subplot","text":""},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot","title":"<code>daspi.plotlib.plotter.HideSubplot</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>Class for hiding all visual components of the x- and y-axis.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes | None</code>)           \u2013            <p>The axes object (subplot) in the figure to hide.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.__call__","title":"<code>__call__(*args, **kwds)</code>","text":"<p>Hide all visual components of the x- and y-axis.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.HideSubplot.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot","title":"<code>daspi.plotlib.plotter.SkipSubplot</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>Class for skip plotting at current axes in a JointChart.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Get empty dict (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.__call__","title":"<code>__call__(*args, **kwds)</code>","text":"<p>Do Nothing</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.__init__","title":"<code>__init__(*args, **kwds)</code>","text":"<p>Initialize the class and store nothing.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/subplot/#daspi.plotlib.plotter.SkipSubplot.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/transform-plotter/","title":"Transform plotter","text":""},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter","title":"<code>daspi.plotlib.plotter.TransformPlotter</code>","text":"<p>               Bases: <code>Plotter</code></p> <p>Abstract base class for creating plotters.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>f_base</code>               (<code>int | float</code>, default:                   <code>FEATURE_BASE</code> )           \u2013            <p>Value that serves as the base location (offset) of the  feature values. Only taken into account if feature is not  given, by default <code>DEFAULT.FEATURE_BASE</code>.</p> </li> <li> <code>skip_na</code>               (<code>Literal['none', 'all', 'any']</code>, default:                   <code>None</code> )           \u2013            <p>Flag indicating whether to skip missing values in the feature  grouped data, by default None - None, no missing values are skipped - all', grouped data is skipped if all values are missing - any', grouped data is skipped if any value is missing</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on  the y-axis, by default True</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first  color is taken from the color cycle, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Those arguments have no effect. Only serves to catch further arguments that have no use here (occurs when this class is  used within chart objects).</p> </li> </ul>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.kw_default","title":"<code>kw_default</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Override this property to provide the default keyword  arguments for plotting as read-only.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.__call__","title":"<code>__call__()</code>  <code>abstractmethod</code>","text":"<p>Perform the plotting operation.</p> <p>This method should be overridden by subclasses to provide the specific plotting functionality.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/transform-plotter/#daspi.plotlib.plotter.TransformPlotter.transform","title":"<code>transform(feature_data, target_data)</code>  <code>abstractmethod</code>","text":"<p>Perform the transformation on the target data and return the transformed data.</p> <p>This method should be overridden by subclasses to provide the specific plotting functionality.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>int | float</code>)           \u2013            <p>Base location (offset) of feature axis coming from  `feature_grouped' generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/variation-test/","title":"Variation test","text":""},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest","title":"<code>daspi.plotlib.plotter.VariationTest</code>","text":"<p>               Bases: <code>ConfidenceInterval</code></p> <p>Class for creating plotters with error bars representing  confidence intervals for variation measures.</p> <p>This class is specifically designed for testing the statistical significance of variation measures, such as standard deviation or variance, between groups or conditions. It uses confidence intervals to visually represent the uncertainty in the variation estimates and allows for a quick assessment of whether the intervals overlap or not.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of groups (variable combinations) for the Bonferroni  adjustment. A good way to do this is to pass  <code>df.groupby(list_of_variates).ngroups</code>, where <code>list_of_variates</code>  is a list containing all the categorical columns in the source  that will be used for the chart to split the data into groups  (hue, categorical features, etc.). Specify 1 to not do a  Bonferroni adjustment. Default is 1</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>show_center</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to show the center points, by default True.</p> </li> <li> <code>bars_same_color</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether to use same color for error bars as  markers for center. If False, the error bars are black, by default False</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level for the confidence intervals, by default 0.95.</p> </li> <li> <code>kind</code>               (<code>Literal['stdev', 'variance']</code>, default:                   <code>'stdev'</code> )           \u2013            <p>Type of variation measure to use, by default 'stdev'.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>marker</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The marker style for the center points. Available markers see: https://matplotlib.org/stable/api/markers_api.html,  by default None</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import VariationTest\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=1, scale=3, size=50))\n        + list(np.random.normal(loc=1, scale=4, size=50))\n        + list(np.random.normal(loc=1, scale=2, size=50)))))\ntest = VariationTest(\n    source=df, target='y', feature='x', show_center=True,\n    n_groups=df.x.nunique(), confidence_level=0.95, bars_same_color=True,\n    ax=ax)\ntest(kw_center=dict(s=30, marker='_'))\ntest.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=1, scale=3, size=50))\n        + list(np.random.normal(loc=1, scale=4, size=50))\n        + list(np.random.normal(loc=1, scale=2, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.VariationTest,\n        show_center=True,\n        n_groups=df.x.nunique(),\n        confidence_level=0.95,\n        bars_same_color=True,\n        kw_call=dict(kw_center=dict(s=30, marker='_'))\n    ).label() # neded to label the feature tick labels\n</code></pre>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.bars_same_color","title":"<code>bars_same_color = bars_same_color</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to use same color for error bars as  markers for center.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.ci_func","title":"<code>ci_func = ci_func</code>  <code>instance-attribute</code>","text":"<p>Provided function for calculating the confidence intervals.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.confidence_level","title":"<code>confidence_level = confidence_level</code>  <code>instance-attribute</code>","text":"<p>Confidence level for the confidence intervals.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.err","title":"<code>err</code>  <code>property</code>","text":"<p>Get separated error lengths as 2D array.  First row contains the lower errors, the second row contains the  upper errors.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.lower","title":"<code>lower = lower</code>  <code>instance-attribute</code>","text":"<p>Column name of the lower error values.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get the marker style for the center points if show_center is True, otherwise '' is returned (read-only).</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.n_groups","title":"<code>n_groups = n_groups</code>  <code>instance-attribute</code>","text":"<p>Number of unique feature values.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.show_center","title":"<code>show_center = show_center</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to show the center points.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.upper","title":"<code>upper = upper</code>  <code>instance-attribute</code>","text":"<p>Column name of the upper error values.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.__call__","title":"<code>__call__(kw_center={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>Parameters:</p> <ul> <li> <code>kw_center</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>scatter</code> method, by default {}.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for the axes <code>errorbar</code> method.</p> </li> </ul>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/variation-test/#daspi.plotlib.plotter.VariationTest.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by using the given function `ci_func' and return the transformed data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot.</p> </li> </ul>"},{"location":"plotlib/plotter/violine/","title":"Violine","text":""},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine","title":"<code>daspi.plotlib.plotter.Violine</code>","text":"<p>               Bases: <code>GaussianKDE</code></p> <p>Class for creating violine plotters.</p> <p>This violin plot is composed of a double-sided Gaussian kernel density estimate. The width of the violin is stretched to fill the available width.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name of the feature variable for the plot, by default ''.</p> </li> <li> <code>width</code>               (<code>float</code>, default:                   <code>FEATURE_SPACE</code> )           \u2013            <p>Width of the violine, by default CATEGORY.FEATURE_SPACE.</p> </li> <li> <code>margin</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Margin for the sequence as factor of data range (max - min ).  If margin is 0, The two ends of the estimated density curve then  show the minimum and maximum value. Default is 0.</p> </li> <li> <code>fill</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag whether to fill in the curves, by default True</p> </li> <li> <code>agreements</code>               (<code>Tuple[float, ...] or Tuple[int, ...]</code>, default:                   <code>AGREEMENTS</code> )           \u2013            <p>Specifies the tolerated process variation for calculating  quantiles. These quantiles are used to represent the filled area  with different opacity, thus highlighting the quantiles.If you  want the filled area to be uniform without highlighting the  quantiles, provide an empty tuple. This argument is only taken  into account if fill is set to True. The agreements can be either  integers or floats, determining the process variation tolerance  in the following ways: - If integers, the quantiles are determined using the normal    distribution (agreement * \u03c3), e.g., agreement = 6 covers    ~99.75% of the data. - If floats, values must be between 0 and 1, interpreted as    acceptable proportions for the quantiles, e.g., 0.9973    corresponds to ~6\u03c3. - If empty tuple, the filled area is uniform without    highlighting the quantiles.</p> <p>Default is <code>DEFAULT.AGREEMENTS</code> = (2, 4, 6), corresponding to  (\u00b11\u03c3, \u00b12\u03c3, \u00b13\u03c3).</p> </li> <li> <code>target_on_y</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether the target variable is plotted on the y-axis, by default True.</p> </li> <li> <code>color</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Color to be used to draw the artists. If None, the first color is taken from the color cycle, by default None.</p> </li> <li> <code>ax</code>               (<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes object for the plot. If None, the current axes is  fetched using <code>plt.gca()</code>. If no axes are available, a new one  is created. Defaults to None.</p> </li> <li> <code>visible_spines</code>               (<code>Literal['target', 'feature', 'none'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which spines are visible, the others are hidden. If 'none', no spines are visible. If None, the spines are drawn according to the stylesheet. Defaults to None.</p> </li> <li> <code>hide_axis</code>               (<code>Literal['target', 'feature', 'both'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which axes should be hidden. If None, both axes  are displayed. Defaults to None.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments that have no effect and are only used to catch further arguments that have no use here (occurs when this class is used within chart objects).</p> </li> </ul> <p>Examples:</p> <p>Apply to an existing Axes object:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom daspi import Violine\n\nfig, ax = plt.subplots()\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nvioline = Violine(\n    source=df, target='y', feature='x', fill=True, margin=0.3, \n    agreements=(), ax=ax)\nvioline()\nvioline.label_feature_ticks()\n</code></pre> <p>Apply using the plot method of a DaSPi Chart object:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    x = ['first'] * 50 + ['second'] * 50 + ['third'] * 50,\n    y = (\n        list(np.random.normal(loc=3, scale=1, size=50))\n        + list(np.random.normal(loc=4, scale=1, size=50))\n        + list(np.random.normal(loc=2, scale=1, size=50)))))\nchart = dsp.SingleChart(\n        source=df,\n        target='y',\n        feature='x',\n        categorical_feature=True, # neded to label the feature tick labels\n    ).plot(\n        dsp.Violine,\n        fill=False,\n        margin=0.3\n    ).label() # neded to label the feature tick labels\n</code></pre>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.ax","title":"<code>ax</code>  <code>instance-attribute</code>","text":"<p>The axes object for the plot.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.color","title":"<code>color</code>  <code>property</code>","text":"<p>Get color of drawn artist</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.estimation","title":"<code>estimation</code>  <code>instance-attribute</code>","text":"<p>The estimator used to calculate the quantiles.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.fig","title":"<code>fig</code>  <code>instance-attribute</code>","text":"<p>The top level container for all the plot elements.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.fill","title":"<code>fill = fill</code>  <code>instance-attribute</code>","text":"<p>Flag whether to fill in the curves</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.height","title":"<code>height</code>  <code>property</code>","text":"<p>Height of kde curve at its maximum.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.highlight_quantiles","title":"<code>highlight_quantiles</code>  <code>property</code>","text":"<p>Flag indicating whether the quantiles should be highlighted.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.kw_default","title":"<code>kw_default</code>  <code>property</code>","text":"<p>Default keyword arguments for plotting (read-only)</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.margin","title":"<code>margin = margin</code>  <code>instance-attribute</code>","text":"<p>Margin for the sequence as factor of data range (max - min ). If margin is 0, The two ends of the estimated density curve then show  the minimum and maximum value.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.marker","title":"<code>marker</code>  <code>property</code>","text":"<p>Get marker of drawn artist</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.n_points","title":"<code>n_points = n_points</code>  <code>instance-attribute</code>","text":"<p>Number of points that have the kde and its sequence.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.skip_na","title":"<code>skip_na = skip_na</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether to skip missing values in the feature  grouped data. - <code>None</code>: no missing values are skipped - <code>'all'</code>: grouped data is skipped if all values are missing - <code>'any'</code>: grouped data is skipped if any value is missing</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.stretch","title":"<code>stretch</code>  <code>property</code>","text":"<p>Factor by which the curve was stretched in height</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.target_on_y","title":"<code>target_on_y = target_on_y</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether the target variable is plotted on the y-axis.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.visible_spines","title":"<code>visible_spines</code>  <code>property</code> <code>writable</code>","text":"<p>Get which spines are visible if specified.</p> <p>Set which spines should be visible, the others are hidden. If 'none', no spines are visible. If None, no changes are made  and the spines are drawn according to the stylesheet.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.x","title":"<code>x</code>  <code>property</code>","text":"<p>Get values used for x-axis (read-only).</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.x_column","title":"<code>x_column</code>  <code>property</code>","text":"<p>Get column name used to access data for x-axis (read-only).</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.y","title":"<code>y</code>  <code>property</code>","text":"<p>Get values used for y-axis (read-only)</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.y_column","title":"<code>y_column</code>  <code>property</code>","text":"<p>Get column name used to access data for y-axis (read-only).</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.__call__","title":"<code>__call__(kw_line={}, **kwds)</code>","text":"<p>Perform the plotting operation.</p> <p>The estimated kernel density is plotted as a line. The curves  are additionally filled if the \"fill\" option was set to \"true\"  during initialization.</p> <p>Parameters:</p> <ul> <li> <code>kw_line</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>plot</code> method, by default {}.</p> </li> <li> <code>**kwds</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the axes <code>fill_between</code> method, by default {}.</p> </li> </ul>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.feature_grouped","title":"<code>feature_grouped(source)</code>","text":"<p>Group the data by the feature variable and yield the  transformed data for each group.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>feature_data</code> (              <code>int | float</code> )          \u2013            <p>Base location (offset) of feature axis.</p> </li> <li> <code>target_data</code> (              <code>pandas Series</code> )          \u2013            <p>feature grouped target data used for transformation.</p> </li> </ul>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.figure_axes","title":"<code>figure_axes(ax)</code>  <code>staticmethod</code>","text":"<p>Create a figure and axes object if not provided.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.label_feature_ticks","title":"<code>label_feature_ticks()</code>","text":"<p>Label the feature ticks with categorical feature names.</p> <p>This method gets the original feature values from the source DataFrame and labels the feature ticks with the feature names. Call this method if feature values are categorical.</p>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.quantiles","title":"<code>quantiles(target_data)</code>","text":"<p>Calculate the quantiles in ascending order:</p> <p>Parameters:</p> <ul> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>feature grouped target data used for transformation, coming from `feature_grouped' generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>quantiles in ascending order</p> </li> </ul>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.shared_axes","title":"<code>shared_axes(ax, which, exclude=True)</code>  <code>staticmethod</code>","text":"<p>Get all the axes from the figure of the given <code>ax</code> and  compare whether the <code>ax</code> share the given axis.  Get a map of boolean values as a list where all are <code>True</code> when  the axis is shared.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Base axes object to add second axis</p> </li> <li> <code>which</code>               (<code>(x, y)</code>, default:                   <code>'x'</code> )           \u2013            <p>From which axis a second one should be added</p> </li> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True excludes the given <code>ax</code> in the returned map</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>Flat map for axes that shares same axis</p> </li> </ul>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.subgroup_values","title":"<code>subgroup_values(sequence, quantiles)</code>","text":"<p>Generate a list of subgroup values based on the agreements.</p> <p>This method creates a list of subgroup values derived from the  instance's agreements. It iterates through the agreements and  appends each agreement to the subgroup list. If the current  agreement is the same as the first agreement, the last  subgroup value is appended instead.</p> <p>Returns:</p> <ul> <li> <code>List[float | int]:</code>           \u2013            <p>A list of subgroup values, which can include both floats  and integers.</p> </li> </ul>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.target_as_percentage","title":"<code>target_as_percentage(xmax=1.0, decimals=None, symbol='%')</code>","text":"<p>Format the numbers on target axis to percentage.</p> <p>Parameters:</p> <ul> <li> <code>xmax</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Determines how the number is converted into a percentage.  xmax is the data value that corresponds to 100%. Percentages  are computed as x / xmax * 100. So if the data is already  scaled to be percentages, xmax will be 100. Another common  situation is where xmax is 1.0.</p> </li> <li> <code>decimals</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of decimal places to place after the point. If  None (the default), the number will be computed  automatically.</p> </li> <li> <code>symbol</code>               (<code>str | None</code>, default:                   <code>'%'</code> )           \u2013            <p>A string that will be appended to the label. It may be None  or empty to indicate that no symbol should be used. LaTeX  special characters are escaped in symbol whenever latex mode  is enabled, unless is_latex is True.</p> </li> </ul>"},{"location":"plotlib/plotter/violine/#daspi.plotlib.plotter.Violine.transform","title":"<code>transform(feature_data, target_data)</code>","text":"<p>Perform the transformation on the target data by estimating  its kernel density. To obtain a uniform curve, a sequence  is generated with a specific number of points in the same range  (min to max) as the target data.</p> <p>Parameters:</p> <ul> <li> <code>feature_data</code>               (<code>float | int</code>)           \u2013            <p>Base location (offset) of feature axis coming from  <code>feature_grouped</code> generator.</p> </li> <li> <code>target_data</code>               (<code>pandas Series</code>)           \u2013            <p>Feature grouped target data used for transformation, coming from <code>feature_grouped</code> generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>pandas DataFrame</code> )          \u2013            <p>The transformed data source for the plot. Contains the  generated sequence as target data and the estimation as feature data.</p> </li> </ul>"},{"location":"plotlib/precast/","title":"Precast Module","text":""},{"location":"plotlib/precast/#daspi.plotlib.precast","title":"<code>daspi.plotlib.precast</code>","text":""},{"location":"plotlib/precast/bivariate-univariate-charts/","title":"Bivariate univariate charts","text":""},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts","title":"<code>daspi.plotlib.precast.BivariateUnivariateCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>Provides a set of charts for visualizing the relationship between a target variable and a feature variable.</p> <p>This class prepares a grid for drawing a bivariate plot with  marginal univariate plots: - Bottom left there is a large square axis for the bivariate   diagram. For example, use a <code>LinearRegressionLine</code> plotter to show    the dependence of the target variable on the feature variable. - Top left there is a small square axis for the univariate   plot of the feature variable. - Bottom right there is a small square axis for the univariate   plot of the target variable. - Top right there is a small square axis hidden as soon a plot is    done.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>DataFrame</code>)           \u2013            <p>The source data.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>The target (dependant) variable.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>The feature (independant) variable.</p> </li> <li> <code>hue</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The hue variable.</p> </li> <li> <code>dodge_univariates</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to dodge the univariate plots, by default False.</p> </li> <li> <code>categorical_feature_univariates</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to treat the feature variable for univariate charts as categorical, by default False.</p> </li> <li> <code>ratios</code>               (<code>List[float]</code>, default:                   <code>[3, 1]</code> )           \u2013            <p>The ratios of the bivariate axes height to the univariate axes  height, by default [4, 1].</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> <li> <code>colors</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Tuple of unique colors used for hue categories as hex or str. If not provided, the default colors will be used, by default ().</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('painkillers-dissolution')\nhue = 'brand'\nn_groups = df.groupby(hue).ngroups\nchart = dsp.BivariateUnivariateCharts(\n        source=df,\n        target='dissolution',\n        feature='temperature',\n        hue=hue,\n        dodge_univariates=True,\n    ).plot_univariates(\n        dsp.MeanTest, n_groups=n_groups\n    ).plot_univariates(\n        dsp.QuantileBoxes, strategy='fit'\n    ).plot_bivariate(\n        dsp.LinearRegressionLine, show_fit_ci=True\n    ).label(\n        fig_title='Regression and distribution analysis',\n        sub_title='Painkillers dissolution time vs. temperature',\n        feature_label='Water temperature (\u00b0C)',\n        target_label='Dissolution time (s)',\n        axes_titles=('95 % Bonferroni confidence interval of mean', '', '', ''),\n        info=True\n    )\n</code></pre> <p>Information about which distribution is used to calculate the quantile boxes can be obtained as follows:</p> <pre><code>brands = (brand for brand in df[hue].unique().tolist()*2)\nfor plot in chart.plots:\n    if isinstance(plot, dsp.QuantileBoxes):\n        print(f'{next(brands)} {plot.target}: {plot.estimation.dist.dist_name}')\n</code></pre>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.bivariate_ax","title":"<code>bivariate_ax</code>  <code>property</code>","text":"<p>Get the bivariate axis (read-only).</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.hidden_ax","title":"<code>hidden_ax</code>  <code>property</code>","text":"<p>Get the top right axis (read-only).</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.univariate_axs","title":"<code>univariate_axs</code>  <code>property</code>","text":"<p>Get the univariate axes (read-only).</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.hide_top_right_ax","title":"<code>hide_top_right_ax()</code>","text":"<p>Hides the top right axis if it is not already hidden.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.label","title":"<code>label(*, fig_title='', sub_title='', feature_label='', target_label='', info=False, axes_titles=(), rows=(), cols=(), row_title='', col_title='')</code>","text":"<p>Add labels and titles to the chart.</p> <p>This method sets various labels and titles for the chart, including figure title, subplot title, axis labels, row and column titles, and additional information.</p> <p>Parameters:</p> <ul> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The main title for the entire figure, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The subtitle for the entire figure, by default ''.</p> </li> <li> <code>feature_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the feature variable (x-axis), by default ''. If set to True, the feature variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>target_label</code>               (<code>str | bool | None</code>, default:                   <code>''</code> )           \u2013            <p>The label for the target variable (y-axis), by default ''. If set to True, the target variable name will be used. If set to False or None, no label will be added.</p> </li> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Additional information to display on the chart. If True, the date and user information will be automatically added at the lower left corner of the figure. If a string is provided, it will be shown next to the date and user, separated by a comma. By default, no additional information is displayed.</p> </li> <li> <code>axes_titles</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Title for each Axes, by default ()</p> </li> <li> <code>rows</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The row labels of the figure, by default ().</p> </li> <li> <code>cols</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The column labels of the figure, by default ().</p> </li> <li> <code>row_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the rows, by default ''.</p> </li> <li> <code>col_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the columns, by default ''.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>BivariateUnivariateCharts</code> instance, for method chaining.</p> </li> </ul> Notes <p>This method allows customization of chart labels and titles to enhance readability and provide context for the visualized data.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.plot_bivariate","title":"<code>plot_bivariate(plotter, *, kw_call={}, kw_where={}, **kwds)</code>","text":"<p>Plots the bivariate plot on the bottom left axis.</p> <p>Parameters:</p> <ul> <li> <code>plotter</code>               (<code>Type[Plotter]</code>)           \u2013            <p>The plotter to use for the univariate plots.</p> </li> <li> <code>kw_call</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter call method.</p> </li> <li> <code>kw_where</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the where method used to filter the data.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the super plot method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>BivariateUnivariateCharts</code> instance, for method  chaining.</p> </li> </ul>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.plot_univariates","title":"<code>plot_univariates(plotter, *, kw_call={}, kw_where={}, **kwds)</code>","text":"<p>Plots the univariate plots on the top left and bottom right axes.</p> <p>Parameters:</p> <ul> <li> <code>plotter</code>               (<code>Type[Plotter]</code>)           \u2013            <p>The plotter to use for the univariate plots.</p> </li> <li> <code>kw_call</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the plotter call method.</p> </li> <li> <code>kw_where</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the where method used to filter the data.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the super plot method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>BivariateUnivariateCharts</code> instance, for method  chaining.</p> </li> </ul>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/bivariate-univariate-charts/#daspi.plotlib.precast.BivariateUnivariateCharts.stripes","title":"<code>stripes(stripes=[], *, mean=False, median=False, control_limits=False, spec_limits=SpecLimits(), confidence=None, strategy='norm', agreement=6, **kwds)</code>","text":"<p>Plot location and spread width lines, specification limits  and/or confidence interval areas as stripes on each Axes. The location and spread (and their confidence bands) represent the  data per axes.</p> <p>Parameters:</p> <ul> <li> <code>stripes</code>               (<code>List[Stripe] | Tuple[List[Stripe]]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional non-predefined stripes to be added to the chart. Default is [].</p> </li> <li> <code>mean</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the mean value of the plotted data on the  axes, by default False.</p> </li> <li> <code>median</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the median value of the plotted data on the  axes, by default False.</p> </li> <li> <code>control_limits</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot control limits representing the process  spread, by default False.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>, default:                   <code>SpecLimits()</code> )           \u2013            <p>If provided, specifies the specification limits. Default is SpecLimits().</p> </li> <li> <code>confidence</code>               (<code>float | None | Tuple[float | None, ...]</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level between 0 and 1, by default None.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance  are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int | float | Tuple[int | float, ...]</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreementsigma,  e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 sigma)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for configuring StripesFacets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JointChart</code> (              <code>Self</code> )          \u2013            <p>The instance of the JointChart with the specified stripes  plotted on the axes.</p> </li> </ul> Notes <p>The given arguments are applied to all axes! If stripes should only be drawn on selected axes, select the  desired subchart via <code>charts</code> attributes. Then use its <code>stripes</code> method.</p> <p>This method plots stripes on the chart axes to represent  statistical measures such as mean, median, control limits, and  specification limits. The method provides options to customize  the appearance and behavior of the stripes using various  parameters and keyword arguments.</p>"},{"location":"plotlib/precast/gage-rnr-charts/","title":"Gage rnr charts","text":""},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts","title":"<code>daspi.plotlib.precast.GageRnRCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>A class for visualizing the parameters of a GageRnR model.</p> <p>Parameters:</p> <ul> <li> <code>rnr_model</code>               (<code>GageRnRModel</code>)           \u2013            <p>The GageRnR model whose parameters will be visualized.</p> </li> <li> <code>spread_accepted_limit</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The maximum value for the the spread proportion where it is  accepted. Default is 0.1 (10 %).</p> </li> <li> <code>spread_rejected_limit</code>               (<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The minimum limit where the spread proportion is rejected. Default is 0.3 (30 %).</p> </li> <li> <code>u_accepted_limit</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>The maximum value for the the u proportion where it is accepted. Default is 0.15 (15 %).</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0])\nmodel = dsp.GageRnRModel(\n    source=df,\n    target='result_rnr',\n    part='part',\n    gage=gage,\n    u_av='operator')\n\nchart = dsp.GageRnRCharts(model, stretch_figsize=True\n    ).plot(\n    ).stripes(\n    ).label()\nmodel\n</code></pre>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.av_gv","title":"<code>av_gv</code>  <code>property</code>","text":"<p>Column name of the variable that identifies the operator for  type 2 Gage R&amp;R or the gage variate for type 3 Gage R&amp;R (read-only).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.model","title":"<code>model = rnr_model</code>  <code>instance-attribute</code>","text":"<p>The GageRnR model whose parameters are visualized.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.part","title":"<code>part</code>  <code>property</code>","text":"<p>Column name of the part (unit under test) variable  (read-only).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.spread_accepted_limit","title":"<code>spread_accepted_limit = spread_accepted_limit</code>  <code>instance-attribute</code>","text":"<p>The maximum value for the the spread proportion where it is  accepted (10 %).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.spread_rejected_limit","title":"<code>spread_rejected_limit = spread_rejected_limit</code>  <code>instance-attribute</code>","text":"<p>The minimum limit where the spread proportion is rejected (30 %).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.u_accepted_limit","title":"<code>u_accepted_limit = u_accepted_limit</code>  <code>instance-attribute</code>","text":"<p>The minimum limit where the measuremen unsertainty proportion is rejected (15 %).</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.label","title":"<code>label(info=False, **kwds)</code>","text":"<p>Adds titles and labels to the charts generated by the  <code>plot()</code> method.</p> <p>Parameters:</p> <ul> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the method will add an informative subtitle to  the chart. If a string is provided, it will be used as the  subtitle, by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>label()</code> method of the <code>JointChart</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ParameterRelevanceCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.plot","title":"<code>plot()</code>","text":"<p>Plot the GageRnR charts.</p>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/gage-rnr-charts/#daspi.plotlib.precast.GageRnRCharts.stripes","title":"<code>stripes()</code>","text":"<p>Adds lines for the limits for the spread and uncertainties  proportions.</p>"},{"location":"plotlib/precast/gage-study-charts/","title":"Gage study charts","text":""},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts","title":"<code>daspi.plotlib.precast.GageStudyCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>A class for visualizing the parameters of a GageStudy model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>GageStudyModel</code>)           \u2013            <p>The GageStudy model whose parameters will be visualized.</p> </li> <li> <code>dist</code>               (<code>scipy stats rv_continuous</code>, default:                   <code>'norm'</code> )           \u2013            <p>The probability distribution use for creating feature data (the theoretical values). Default is 'norm'.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> </ul> <p>Examples:</p> <p>Run the following command in a jupyter notebook to get the html output of <code>gage</code> or you can also use <code>print(repr(gage))</code> instead:</p> <pre><code>import daspi as dsp\ndf = dsp.load_dataset('grnr_layer_thickness')\ngage = dsp.GageStudyModel(\n    source=df,\n    target='result_gage',\n    reference='reference',\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0],\n    bias_corrected=True,)\nchart = dsp.GageStudyCharts(gage, stretch_figsize=1.5).plot().stripes().label()\ngage\n</code></pre>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.dist","title":"<code>dist = dist</code>  <code>instance-attribute</code>","text":"<p>The probability distribution use for creating feature data (the theoretical values).</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.has_multiple_references","title":"<code>has_multiple_references = source[reference].nunique() &gt; 1</code>  <code>instance-attribute</code>","text":"<p>Whether the GageStudy model has multiple references.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":"<p>The GageStudy model whose parameters are visualized.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.label","title":"<code>label(info=False, **kwds)</code>","text":"<p>Adds titles and labels to the charts generated by the  <code>plot()</code> method.</p> <p>Parameters:</p> <ul> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the method will add an informative subtitle to  the chart. If a string is provided, it will be used as the  subtitle, by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>label()</code> method of the <code>JointChart</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ParameterRelevanceCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/gage-study-charts/#daspi.plotlib.precast.GageStudyCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/pair-comparison-charts/","title":"Pair comparison charts","text":""},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts","title":"<code>daspi.plotlib.precast.PairComparisonCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>Provides a set of charts for visualizing the pairwise  comparison of two variables.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>DataFrame</code>)           \u2013            <p>The source data.</p> </li> <li> <code>target</code>               (<code>str or Tuple[str]</code>)           \u2013            <p>The target variable(s).</p> </li> <li> <code>feature</code>               (<code>str or Tuple[str]</code>)           \u2013            <p>The feature variable(s).</p> </li> <li> <code>identity</code>               (<code>str</code>)           \u2013            <p>Column name containing identities of each sample, must occur  once for each measurement.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('shoe-sole')\nchart = dsp.PairComparisonCharts(\n        source=df,\n        target='wear',\n        feature='status',\n        identity='tester'\n    ).plot(\n    ).label(\n        info=True\n    )\n</code></pre>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.identity","title":"<code>identity = identity</code>  <code>instance-attribute</code>","text":"<p>Column name containing identities of each sample.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.label","title":"<code>label(info=False, **kwds)</code>","text":"<p>Adds titles and labels to the charts generated by the  <code>plot()</code> method.</p> <p>Parameters:</p> <ul> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the method will add an informative subtitle to  the chart. If a string is provided, it will be used as the  subtitle, by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>label()</code> method of the <code>JointChart</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>PairComparisonCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.plot","title":"<code>plot()</code>","text":"<p>Generates a set of two charts for visualizing the difference between each pair. - BlandAltman where the difference is shown on the y-axis - ParallelCoordinate including a MeanTest and Violine plot, to  reflect the difference within the absolute values.</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code> </code> )          \u2013            <p>The <code>PairComparisonCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/pair-comparison-charts/#daspi.plotlib.precast.PairComparisonCharts.stripes","title":"<code>stripes(stripes=[], *, mean=False, median=False, control_limits=False, spec_limits=SpecLimits(), confidence=None, strategy='norm', agreement=6, **kwds)</code>","text":"<p>Plot location and spread width lines, specification limits  and/or confidence interval areas as stripes on each Axes. The location and spread (and their confidence bands) represent the  data per axes.</p> <p>Parameters:</p> <ul> <li> <code>stripes</code>               (<code>List[Stripe] | Tuple[List[Stripe]]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional non-predefined stripes to be added to the chart. Default is [].</p> </li> <li> <code>mean</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the mean value of the plotted data on the  axes, by default False.</p> </li> <li> <code>median</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the median value of the plotted data on the  axes, by default False.</p> </li> <li> <code>control_limits</code>               (<code>bool or Tuple[bool, ...]</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot control limits representing the process  spread, by default False.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>, default:                   <code>SpecLimits()</code> )           \u2013            <p>If provided, specifies the specification limits. Default is SpecLimits().</p> </li> <li> <code>confidence</code>               (<code>float | None | Tuple[float | None, ...]</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level between 0 and 1, by default None.</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance  are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int | float | Tuple[int | float, ...]</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreementsigma,  e.g. agreement = 6 -&gt; 6sigma ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 sigma)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments for configuring StripesFacets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JointChart</code> (              <code>Self</code> )          \u2013            <p>The instance of the JointChart with the specified stripes  plotted on the axes.</p> </li> </ul> Notes <p>The given arguments are applied to all axes! If stripes should only be drawn on selected axes, select the  desired subchart via <code>charts</code> attributes. Then use its <code>stripes</code> method.</p> <p>This method plots stripes on the chart axes to represent  statistical measures such as mean, median, control limits, and  specification limits. The method provides options to customize  the appearance and behavior of the stripes using various  parameters and keyword arguments.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/","title":"Parameter relevance charts","text":""},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts","title":"<code>daspi.plotlib.precast.ParameterRelevanceCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>Provides a set of charts for visualizing the relevance of a linear regression model's parameters.</p> <p>The <code>ParameterRelevanceCharts</code> class takes a <code>LinearModel</code> instance  and generates a set of two charts for visualizing the relevance of the model's parameters: - Pareto chart of the parameter standardized effects - Pareto chart of the Sum of Squares for each parameter</p> <p>On the first chart, the standardized effect of each parameter is  visualized as a Pareto chart. The red line indicates the alpha level of significance.</p> <p>Parameters:</p> <ul> <li> <code>linear_model</code>               (<code>LinearModel</code>)           \u2013            <p>The linear regression model whose parameters will be visualized.</p> </li> <li> <code>drop_intercept</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to drop the intercept from the model, by default True.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\nimport pandas as pd\n\ndf = dsp.load_dataset('painkillers-dissolution')\nmodel = dsp.LinearModel(\n    source=df,\n    target='dissolution',\n    features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n    disturbances=['temperature', 'preparation'],\n    order=2)\ndf_gof = pd.concat(model.recursive_elimination())\ndsp.ParameterRelevanceCharts(model).plot().stripes().label(info=True)\n</code></pre>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.lm","title":"<code>lm = linear_model</code>  <code>instance-attribute</code>","text":"<p>The linear regression model whose parameters are visualized.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.label","title":"<code>label(info=False, **kwds)</code>","text":"<p>Adds titles and labels to the charts generated by the  <code>plot()</code> method.</p> <p>Parameters:</p> <ul> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the method will add an informative subtitle to  the chart. If a string is provided, it will be used as the  subtitle, by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>label()</code> method of the <code>JointChart</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ParameterRelevanceCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.plot","title":"<code>plot()</code>","text":"<p>Generates a set of two charts for visualizing the relevance  of the model's parameters: - Pareto chart of the parameter standardized effects - Pareto chart of the Sum of Squares for each parameter</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code> </code> )          \u2013            <p>The <code>ParameterRelevanceCharts</code> instance, for method chaining.</p> </li> </ul> Notes <p>The <code>plot()</code> method will generate two charts. The first chart will contain the Pareto chart of the parameter standardized effects. The second chart will contain the Pareto chart of the Sum of Squares for each parameter.</p> <p>The red line in the Pareto charts represents the threshold for the effect of a parameter. The threshold is calculated as the alpha risk where the parameter is not relevant.</p>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/parameter-relevance-charts/#daspi.plotlib.precast.ParameterRelevanceCharts.stripes","title":"<code>stripes()</code>","text":"<p>Adds a line at position 0 for each subplot except for the  probability plot. This line represents the fit of the model.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/","title":"Process capability analysis charts","text":""},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts","title":"<code>daspi.plotlib.precast.ProcessCapabilityAnalysisCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>A class for creating process capability analysis charts.</p> <p>This class extends the <code>JointChart</code> class and provides methods for creating process capability analysis charts. It allows you to visualize process capability analysis data and perform various analysis tasks.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>DataFrame</code>)           \u2013            <p>The source data.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>The target (dependant) variable.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits</code>)           \u2013            <p>The specification limits for the process capability analysis.</p> </li> <li> <code>hue</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The hue variable for the chart, by default ''.</p> </li> <li> <code>dist</code>               (<code>scipy stats rv_continuous</code>, default:                   <code>'norm'</code> )           \u2013            <p>The probability distribution use for creating feature data (the theoretical values). Default is 'norm'.</p> </li> <li> <code>error_values</code>               (<code>tuple of float</code>, default:                   <code>()</code> )           \u2013            <p>If the process data may contain coded values for measurement  errors or similar, they can be specified here,  by default [].</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - norm: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - data: The quantiles for the process variation tolerance  are read directly from the data. by default 'norm'</p> </li> <li> <code>agreement</code>               (<code>float or int</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreement\u03c3,  e.g. agreement = 6 -&gt; 6\u03c3 ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 \u03c3) by default 6</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default DIST.COMMON</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('drop_card')\ntarget = 'distance'\n\nchart = dsp.ProcessCapabilityAnalysisCharts(\n        source=df,\n        target=target,\n        spec_limits=dsp.SpecLimits(0, float(df.loc[0, 'usl'])),\n        hue='method'\n    ).plot(\n    ).stripes(\n    ).label(\n        fig_title='Process Capability Analysis',\n        sub_title='Drop Card Experiment',\n        target_label='Distance (cm)',\n        info=True)\n</code></pre>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.dist","title":"<code>dist = dist</code>  <code>instance-attribute</code>","text":"<p>The probability distribution use for creating feature data (the theoretical values).</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.kw_estim","title":"<code>kw_estim = dict(error_values=error_values, strategy=strategy, agreement=agreement, possible_dists=possible_dists)</code>  <code>instance-attribute</code>","text":"<p>Keyword arguments for the ProcessEstimator instances used for  calculating the capability indices.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.n_groups","title":"<code>n_groups = source.groupby(hue).ngroups if hue else 1</code>  <code>instance-attribute</code>","text":"<p>The number of hue groups in the source data.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.spec_limits","title":"<code>spec_limits = spec_limits</code>  <code>instance-attribute</code>","text":"<p>The specification limits for the process capability analysis.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.label","title":"<code>label(*, fig_title='', sub_title='', feature_label=(), target_label='', info=False)</code>","text":"<p>Label the process capability analysis charts.</p> <p>This method labels the process capability analysis charts with custom labels and titles.</p> <p>Parameters:</p> <ul> <li> <code>fig_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the figure, by default ''.</p> </li> <li> <code>sub_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The subtitle of the figure, by default ''.</p> </li> <li> <code>feature_label</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The labels for the features. If not provided, default labels will be used. The tuple should contain five elements. By default, the labels are: ('Observation order', '', 'Quantiles of standard normal distribution',  '', '')</p> </li> <li> <code>target_label</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The label for the target variable, by default ''.</p> </li> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display information about the chart. If True, the information will be displayed. If a string is provided, it will be used as the title of the information box. By default, the information is not displayed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ProcessCapabilityAnalysisCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.plot","title":"<code>plot(**kwds_cpi)</code>","text":"<p>Plot the process capability analysis charts.</p> <p>This method plots the process capability analysis charts, including scatter plots, probability density functions, Gaussian kernel density estimation, and capability confidence intervals.</p> <p>Parameters:</p> <ul> <li> <code>kwds_cpi</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the capability confidence interval plot.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ProcessCapabilityAnalysisCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.process_descriptions","title":"<code>process_descriptions(exclude=())</code>","text":"<p>Get a DataFrame containing the descriptions of each process.</p> <p>This method generates a DataFrame that contains the descriptions of each process, excluding any specified columns.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Attributes to exclude from the summary statistics, by default ().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame containing the descriptions of each process.</p> </li> </ul>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.processes","title":"<code>processes()</code>","text":"<p>Get a dictionary of ProcessEstimator instances that are used  for calculating the capability indices.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, ProcessEstimator]</code>           \u2013            <p>A dictionary where: - Keys: The hue categories or the target name if no hue is    used. - Values: The corresponding ProcessEstimator instances.</p> </li> </ul>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/process-capability-analysis-charts/#daspi.plotlib.precast.ProcessCapabilityAnalysisCharts.stripes","title":"<code>stripes(*, mean=True, median=True, control_limits=True)</code>","text":"<p>This method adds stripes to the process capability analysis  charts, including mean, median, control limits and specification  limits.</p> <p>Parameters:</p> <ul> <li> <code>mean</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to add a line for the mean, by default True.</p> </li> <li> <code>median</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to add a line for the median (if applicable), by default True.</p> </li> <li> <code>control_limits</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to add lines for the control limits (if applicable), by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ProcessCapabilityAnalysisCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/residual-charts/","title":"Residual charts","text":""},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts","title":"<code>daspi.plotlib.precast.ResidualsCharts</code>","text":"<p>               Bases: <code>JointChart</code></p> <p>Provides a set of charts for visualizing the residuals of a linear  regression model.</p> <p>The <code>ResidualsCharts</code> class takes a <code>LinearModel</code> instance and  generates a set of four charts: - Probability plot of the residuals - Gaussian kernel density estimate of the residuals - Scatter plot of the predicted values vs. the observed values - Line plot of the predicted values vs. the observed values</p> <p>The <code>plot()</code> method generates the charts, and the <code>label()</code> method  adds titles and labels to the charts.</p> <p>Parameters:</p> <ul> <li> <code>linear_model</code>               (<code>LinearModel</code>)           \u2013            <p>The linear regression model whose residuals will be visualized.</p> </li> <li> <code>stretch_figsize</code>               (<code>bool | float | Tuple[float, float]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the height and width of the figure are stretched based  on the number rows and columns in the axes grid. If a float is  provided, the figure size is stretched by the given factor. If a  tuple of two floats is provided, the figure size is stretched by  the given factors for the x and y axis, respectively. by default False.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\nimport pandas as pd\n\ndf = dsp.load_dataset('painkillers-dissolution')\nmodel = dsp.LinearModel(\n    source=df,\n    target='dissolution',\n    features=['employee', 'stirrer', 'brand', 'catalyst', 'water'],\n    disturbances=['temperature', 'preparation'],\n    order=2)\ndf_gof = pd.concat(model.recursive_elimination())\ndsp.ResidualsCharts(model).plot().stripes().label(info=True)\n</code></pre>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.axes","title":"<code>axes</code>  <code>instance-attribute</code>","text":"<p>AcesFacets instance for creating a grid of subplots with customizable sharing and sizing options.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.axes_share_feature","title":"<code>axes_share_feature</code>  <code>property</code>","text":"<p>Get the sharing of properties along the feature-axis (read-only).</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.axes_share_target","title":"<code>axes_share_target</code>  <code>property</code>","text":"<p>Get the sharing of properties along the target-axis (read-only).</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.categorical_features","title":"<code>categorical_features = tuple((dodge or categorical) for (dodge, categorical) in (zip(self.dodges, self.normalize_to_tuple(categorical_feature))))</code>  <code>instance-attribute</code>","text":"<p>Flags indicating if feature is categorical for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.charts","title":"<code>charts = []</code>  <code>instance-attribute</code>","text":"<p>List of SingleChart instances created for each Axis throughout the chart.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.dodges","title":"<code>dodges = self.normalize_to_tuple(dodge)</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether dodging is enabled for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>Column name for the feature variable to be visualized.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.features","title":"<code>features = self.normalize_to_tuple(feature)</code>  <code>instance-attribute</code>","text":"<p>Column names for the feature variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.figure","title":"<code>figure</code>  <code>property</code>","text":"<p>Get the top level container for all the plot elements (read-only).</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.hues","title":"<code>hues = self.normalize_to_tuple(hue)</code>  <code>instance-attribute</code>","text":"<p>The hue variable (column) for color differentiation for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.label_facets","title":"<code>label_facets</code>  <code>instance-attribute</code>","text":"<p>LabelFacets instance for adding labels and titles to facets of a figure.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.legend_data","title":"<code>legend_data</code>  <code>property</code>","text":"<p>Get dictionary of handles and labels (read-only). - keys: titles as str - values: handles and labels as tuple of tuples</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.lm","title":"<code>lm = linear_model</code>  <code>instance-attribute</code>","text":"<p>The linear regression model whose residuals are visualized.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.n_axes","title":"<code>n_axes</code>  <code>property</code>","text":"<p>Get amount of axes</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.plots","title":"<code>plots</code>  <code>property</code>","text":"<p>Get plotter objects used in <code>plot</code> method</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.same_target_on_y","title":"<code>same_target_on_y</code>  <code>property</code>","text":"<p>True if all target_on_y have the same boolean value.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.shapes","title":"<code>shapes = self.normalize_to_tuple(shape)</code>  <code>instance-attribute</code>","text":"<p>The shape variables (column) for marker differentiation for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.sizes","title":"<code>sizes = self.normalize_to_tuple(size)</code>  <code>instance-attribute</code>","text":"<p>The size variable (column) for marker size differentiation for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.source","title":"<code>source = source.copy()</code>  <code>instance-attribute</code>","text":"<p>Pandas DataFrame containing the source data in long-format.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.sources","title":"<code>sources = self.normalize_to_tuple(source)</code>  <code>instance-attribute</code>","text":"<p>The source data associated with each subplot</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.stripes_facets","title":"<code>stripes_facets</code>  <code>instance-attribute</code>","text":"<p>StripesFacets instance for creating location and spread width lines, specification limits and/or confidence interval areas as stripes on each Axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>Column name for the target variable to be visualized.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.target_on_y","title":"<code>target_on_y = self.target_on_ys[0]</code>  <code>instance-attribute</code>","text":"<p>Flag indicating whether target is on y-axis for current chart.  This flag is set during iterating over charts.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.target_on_ys","title":"<code>target_on_ys = self.normalize_to_tuple(target_on_y)</code>  <code>instance-attribute</code>","text":"<p>Flags indicating whether target is on y-axis for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.targets","title":"<code>targets = self.normalize_to_tuple(target)</code>  <code>instance-attribute</code>","text":"<p>Column names for the target variable to be visualized for each axes.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.axis_labels","title":"<code>axis_labels(feature_label, target_label)</code>","text":"<p>Get the x and y axis labels based on the provided  <code>feature_label</code> and <code>target_label</code>.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.close","title":"<code>close()</code>","text":"<p>\"Close figure</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.itercharts","title":"<code>itercharts()</code>","text":"<p>Iter over charts simultaneosly iters over axes of  <code>axes</code>. That ensures that the current Axes to which the  current chart belongs is set. The</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.label","title":"<code>label(info=False, **kwds)</code>","text":"<p>Adds titles and labels to the charts generated by the  <code>plot()</code> method.</p> <p>Parameters:</p> <ul> <li> <code>info</code>               (<code>bool | str</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the method will add an informative subtitle to  the chart. If a string is provided, it will be used as the  subtitle, by default False.</p> </li> <li> <code>**kwds</code>           \u2013            <p>Additional keyword arguments to be passed to the <code>label()</code> method of the <code>JointChart</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>ResidualsCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.normalize_to_tuple","title":"<code>normalize_to_tuple(attribute)</code>","text":"<p>Normalize the input attribute to ensure it is a tuple with a length equal to the number of subplots (n_axes). If a single value is provided,  it is replicated to create a tuple with the same length as n_axes.</p> <p>Parameters:</p> <ul> <li> <code>attribute</code>               (<code>(str, float, int, bool, list, tuple or None)</code>)           \u2013            <p>A single value or a list/tuple of values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the normalized values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input type is not supported</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If the length of the attribute does not match n_axes after  normalization.</p> </li> </ul> <p>Examples:</p> <p>Suppose n_axes is 3: - If attribute is 5, it will return (5, 5, 5). - If attribute is [], it will return ([], [], []). - If attribute is (1, 2, 3), it will return (1, 2, 3). - If attribute is (1, 2), it will raise a ValueError.</p>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.plot","title":"<code>plot()</code>","text":"<p>Generates a set of four charts for visualizing the residuals  of a linear regression model: - Probability plot of the residuals - Gaussian kernel density estimate of the residuals - Scatter plot of the predicted values vs. the observed values - Line plot of the predicted values vs. the observed values</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code> </code> )          \u2013            <p>The <code>ResidualsCharts</code> instance, for method chaining.</p> </li> </ul>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.single_label_allowed","title":"<code>single_label_allowed(is_target)</code>","text":"<p>Determines whether a single label is allowed for the  specified axis.</p> <p>This method checks whether a single axis label is allowed for  either target or feature dimensions based on certain conditions. The <code>same_target_on_y</code> attribute is allways considered. It is  also checked whether the number of unique values in the  respective dimension (features or targets) is 1 or whether the  sharing of the axis is set to True or 'all'.</p> <p>Parameters:</p> <ul> <li> <code>is_target</code>               (<code>bool</code>)           \u2013            <p>If True, checks for target labels; otherwise, checks for  feature labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a single label is allowed, False otherwise.</p> </li> </ul>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.specification_limits_iterator","title":"<code>specification_limits_iterator(spec_limits)</code>","text":"<p>Generates specification limits based on the provided input.</p> <p>Parameters:</p> <ul> <li> <code>spec_limits</code>               (<code>SpecLimits | Tuple[SpecLimits, ...]</code>)           \u2013            <p>The specification limits to generate from. If a single limit pair is provided, it will be used for all axes. If a tuple  of values is provided, each value corresponds to an axes.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>SpecLimits</code>           \u2013            <p>The generated spec limits.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generator = spec_limits_gen((1.0, 2.0))\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n&gt;&gt;&gt; next(generator)\n(1.0, 2.0)\n</code></pre>"},{"location":"plotlib/precast/residual-charts/#daspi.plotlib.precast.ResidualsCharts.stripes","title":"<code>stripes()</code>","text":"<p>Adds a line at position 0 for each subplot except for the  probability plot. This line represents the fit of the model.</p>"},{"location":"statistics/","title":"Statistics Library","text":""},{"location":"statistics/#daspi.statistics","title":"<code>daspi.statistics</code>","text":""},{"location":"statistics/confidence/","title":"Index","text":""},{"location":"statistics/confidence/#daspi.statistics.confidence","title":"<code>daspi.statistics.confidence</code>","text":""},{"location":"statistics/confidence/#daspi.statistics.confidence.mean_ci","title":"<code>mean_ci(sample, level=0.95, n_groups=1)</code>","text":"<p>Two sided confidence interval for mean of data.</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Used for Bonferroni method.  Amount of groups to adjust the alpha risk within each group, that the total risk is not exceeded, by default 1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>x_bar</code> (              <code>float</code> )          \u2013            <p>expected value</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul> Notes <p>The underlying <code>t.interval</code> function assumes that the data follows a t-distribution. Additionally, this method assumes that the sample is  representative of the population and that the data is independent  and identically distributed.</p>"},{"location":"statistics/confidence/#daspi.statistics.confidence.median_ci","title":"<code>median_ci(sample, level=0.95, n_groups=1)</code>","text":"<p>Two sided confidence interval for median of data</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Used for Bonferroni method.  Amount of groups to adjust the alpha risk within each group, that the total risk is not exceeded, by default 1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>median</code> (              <code>float</code> )          \u2013            <p>median of data</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul> Notes <p>The underlying <code>t.interval</code> function assumes that the data follows a t-distribution. Additionally, this method assumes that the sample is  representative of the population and that the data is independent  and identically distributed.</p>"},{"location":"statistics/confidence/#daspi.statistics.confidence.variance_ci","title":"<code>variance_ci(sample, level=0.95, n_groups=1)</code>","text":"<p>Two sided confidence interval for variance of data</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Used for Bonferroni method.  Amount of groups to adjust the alpha risk within each group, that the total risk is not exceeded, by default 1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>s2</code> (              <code>float</code> )          \u2013            <p>variance of data</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul>"},{"location":"statistics/confidence/#daspi.statistics.confidence.stdev_ci","title":"<code>stdev_ci(sample, level=0.95, n_groups=1)</code>","text":"<p>Two sided confidence interval for standard deviation of data</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Used for Bonferroni method.  Amount of groups to adjust the alpha risk within each group, that the total risk is not exceeded, by default 1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>s</code> (              <code>float</code> )          \u2013            <p>variance of data</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul>"},{"location":"statistics/confidence/#daspi.statistics.confidence.proportion_ci","title":"<code>proportion_ci(events, observations, level=0.95, n_groups=1)</code>","text":"<p>Confidence interval for a binomial proportion with a asymptotic  normal approximation.</p> <p>Parameters:</p> <ul> <li> <code>events</code>               (<code>int</code>)           \u2013            <p>Counted number of events.</p> </li> <li> <code>observations</code>               (<code>int</code>)           \u2013            <p>Total number of observations.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level, default 0.95</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Used for Bonferroni method.  Amount of groups to adjust the alpha risk within each group, that the total risk is not exceeded, by default 1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>portion</code> (              <code>float</code> )          \u2013            <p>Portion as ratio events/observations.</p> </li> <li> <code>lower, upper : float</code>           \u2013            <p>The lower and upper confidence level with coverage approximately  ci.</p> </li> </ul>"},{"location":"statistics/confidence/#daspi.statistics.confidence.bonferroni_ci","title":"<code>bonferroni_ci(data, target, feature, level=0.95, ci_func=stdev_ci, n_groups=None, name='midpoint')</code>","text":"<p>Calculate confidence interval after bonferroni correction. The Bonferroni correction is a method to adjust the significance  level alpha.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>data frame containing sample and feature data</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>name of target sample data column</p> </li> <li> <code>feature</code>               (<code>str | List[str]</code>)           \u2013            <p>name of categorical feature. The confidence intervals are  calculated separately for these groups</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, default 0.95</p> </li> <li> <code>ci_func</code>               (<code>(mean_ci, stdev_ci, variance_ci)</code>, default:                   <code>mean_ci</code> )           \u2013            <p>function to calculate needed confidence interval that returns the values in order: midpoint, lower ci, upper ci</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Used for Bonferroni correction.  Amount of groups to adjust the alpha risk within each group, that the total risk is not exceeded,  If none is given, it calculates the number based on the given  groups (ngroups attribute of groupby object), by default None</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'midpoint'</code> )           \u2013            <p>name of midpoints, by default 'midpoint'</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>DataFrame</code> )          \u2013            <p>data containing groups, midpoints and confidence limits</p> </li> </ul> Notes <p>The Bonferroni correction is always necessary if you carry out  several \"multiple\" tests. In this case, the probability of the type I error for all tests together is no longer 5% (or 1%), but significantly more. This means that the risk that you will receive at least one significant result, even though there is no effect at all, is significantly increased with multiple tests. This is also referred to as alpha error accumulation or alpha inflation.</p>"},{"location":"statistics/confidence/#daspi.statistics.confidence.delta_mean_ci","title":"<code>delta_mean_ci(sample1, sample2, level=0.95)</code>","text":"<p>Two sided confidence interval for mean difference of two independent variables.</p> <p>Parameters:</p> <ul> <li> <code>sample1</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the first samples.</p> </li> <li> <code>sample2</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the second samples.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level between 0 and 1, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>delta</code> (              <code>float</code> )          \u2013            <p>Difference of means of data</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul>"},{"location":"statistics/confidence/#daspi.statistics.confidence.delta_variance_ci","title":"<code>delta_variance_ci(sample1, sample2, level=0.95)</code>","text":"<p>two sided confidence interval for variance difference of two independent variables.</p> <p>Parameters:</p> <ul> <li> <code>sample1</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the first sample.</p> </li> <li> <code>sample2</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the second sample.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level between 0 and 1, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>delta</code> (              <code>float</code> )          \u2013            <p>difference of variance of data</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul> Notes <p>This function is a ChatGPT solution and therefore does not guarantee that this solution is correct.</p>"},{"location":"statistics/confidence/#daspi.statistics.confidence.delta_proportions_ci","title":"<code>delta_proportions_ci(events1, observations1, events2, observations2, level=0.95)</code>","text":"<p>Confidence intervals for comparing two independent proportions This assumes that we have two independent binomial sample.</p> <p>Parameters:</p> <ul> <li> <code>events1</code>               (<code>int</code>)           \u2013            <p>Counted number of events of sample 1.</p> </li> <li> <code>observations1</code>               (<code>int</code>)           \u2013            <p>Total number of observations of sample 1.</p> </li> <li> <code>events2</code>               (<code>int</code>)           \u2013            <p>Counted number of events of sample 2.</p> </li> <li> <code>observations2</code>               (<code>int</code>)           \u2013            <p>Total number of observations of sample 2.</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>Confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>delta</code> (              <code>float</code> )          \u2013            <p>Difference of variance of data</p> </li> <li> <code>lower</code> (              <code>float</code> )          \u2013            <p>Lower confidence level</p> </li> <li> <code>upper</code> (              <code>float</code> )          \u2013            <p>Upper confidence levell</p> </li> </ul>"},{"location":"statistics/confidence/#daspi.statistics.confidence.fit_ci","title":"<code>fit_ci(model, level=0.95)</code>","text":"<p>calculate confidence interval fitted line. Applies to fitted WLS  and OLS models, not to general GLS</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>statsmodels RegressionResults</code>)           \u2013            <p>fitted OLS or WLS model</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>fitted</code> (              <code>NDArray</code> )          \u2013            <p>For coherence with the other functions, the fitted target  samples are returned as one-dimensional numpy array,</p> </li> <li> <code>lower</code> (              <code>NDArray</code> )          \u2013            <p>Lower confidence limits of fitting line as one-dimensional numpy  array.</p> </li> <li> <code>upper</code> (              <code>NDArray</code> )          \u2013            <p>Upper confidence limits of fitting line as one-dimensional numpy  array.</p> </li> </ul> Notes <p>Using hat_matrix to calculate fit_se only works for fitted values</p> <p>This function is based on the summary_table function from the  statsmodels.stats.outliers_influence module, see:  https://www.statsmodels.org/dev/_modules/statsmodels/stats/outliers_influence.html</p>"},{"location":"statistics/confidence/#daspi.statistics.confidence.prediction_ci","title":"<code>prediction_ci(model, level=0.95)</code>","text":"<p>calculate confidence interval for prediction and to observe  outliers. Applies to fitted WLS and OLS models, not to general GLS.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>statsmodels RegressionResults</code>)           \u2013            <p>fitted OLS or WLS model</p> </li> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>fitted</code> (              <code>NDArray</code> )          \u2013            <p>For coherence with the other functions, the fitted target  samples are returned as one-dimensional numpy array,</p> </li> <li> <code>lower</code> (              <code>NDArray</code> )          \u2013            <p>Lower confidence limits of prediction as one-dimensional numpy  array.</p> </li> <li> <code>upper</code> (              <code>NDArray</code> )          \u2013            <p>Upper confidence limits of prediction as one-dimensional numpy  array.</p> </li> </ul>"},{"location":"statistics/confidence/#daspi.statistics.confidence.confidence_to_alpha","title":"<code>confidence_to_alpha(confidence_level, two_sided=True, n_groups=1)</code>","text":"<p>Calculate significance level as alpha risk by given confidence  level</p> <p>Parameters:</p> <ul> <li> <code>confidence_level</code>               (<code>float in (0, 1)</code>)           \u2013            <p>level of confidence interval</p> </li> <li> <code>two_sided</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>True if alpha is to be calculated for a two-sided confidence interval, by default True</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Used for Bonferroni method.  Number of groups to adjust the alpha risk within each group, that the total risk is not exceeded, by default 1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>alpha</code> (              <code>float</code> )          \u2013            <p>significance level as alpha risk</p> </li> </ul>"},{"location":"statistics/estimation/","title":"Index","text":""},{"location":"statistics/estimation/#daspi.statistics.estimation","title":"<code>daspi.statistics.estimation</code>","text":""},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty","title":"<code>MeasurementUncertainty</code>","text":"<p>A class to represent and calculate measurement uncertainty.</p> <p>This class provides multiple ways to define measurement uncertainty: 1. From error limit and distribution factor 2. From expanded uncertainty and coverage factor k 3. From standard uncertainty directly</p> <p>Parameters:</p> <ul> <li> <code>standard</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The standard uncertainty (u). If provided the parameters  expanded and error_limit are ignored. To initialize a  non-significant measurement uncertainty, set standard to 0.</p> </li> <li> <code>error_limit</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The maximum allowable deviation from the true value, also known  as the tolerance range. This parameter represents the worst-case  scenario for measurement error, indicating how much the measured  value can differ from the actual value. It is used to calculate  the standard uncertainty based on the specified distribution  factor. The value must be positive, as a negative error limit  does not have a physical meaning in the context of measurement  uncertainty.</p> </li> <li> <code>distribution_factor</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The distribution factor based on the assumed distribution. Common values: - \u221a3 \u2248 1.732 for rectangular (uniform) distribution - 2 for triangular distribution - 1 for normal distribution (if error_limit is already 1\u03c3)</p> </li> <li> <code>expanded</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The expanded uncertainty (U).</p> </li> <li> <code>k</code>               (<code>int | float</code>, default:                   <code>2</code> )           \u2013            <p>The coverage factor for expanded uncertainty. It is used as a  multiplier to determine the expanded uncertainty based on the  standard uncertainty. The value of <code>k</code> is typically set to  reflect the desired confidence level in the  measurement  results. Default is 2, typical values are: - k=2 corresponds to a confidence interval of 95.45% - k=3 corresponds to a confidence interval of 99.73%</p> </li> <li> <code>confidence_level</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The confidence level (0 to 1) to calculate coverage factor for  normal distribution. Default is 0.95 (95% confidence).</p> </li> <li> <code>distribution</code>               (<code>(rectangular, triangular, normal)</code>, default:                   <code>'rectangular'</code> )           \u2013            <p>The assumed probability distribution for calculating  distribution factor. Only used if distribution_factor is not  explicitly provided. Default is 'rectangular'.</p> </li> </ul> Notes <p>To initialize a non-significant measurement uncertainty, set  standard to 0. This uncertainty can then be used for further  calculations and combined with others, but it does not affect the  \"addition\" of uncertainties.</p> <p>Examples:</p> <p>Create uncertainty from error limit (rectangular distribution):</p> <pre><code># Error limit \u00b10.1, rectangular distribution\nu_1 = dsp.MeasurementUncertainty(error_limit=0.1)\nprint(f\"Standard uncertainty: {u_1.standard:.4f}\")\n</code></pre> <p>Create uncertainty from expanded uncertainty:</p> <pre><code># Expanded uncertainty U = 0.2 with k = 2\nu_2 = dsp.MeasurementUncertainty(\n    expanded=0.2, k=2)\nprint(f\"Standard uncertainty: {u_2.standard:.4f}\")\n</code></pre> <p>Create uncertainty directly:</p> <pre><code># Direct standard uncertainty\nu_3 = dsp.MeasurementUncertainty(standard=0.05)\nprint(f\"Expanded uncertainty (k=2): {u_3.expanded(2):.4f}\")\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If insufficient or conflicting parameters are provided.</p> </li> <li> <code>AssertionError</code>             \u2013            <p>If parameter values are invalid (negative, out of range, etc.).</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.confidence_level","title":"<code>confidence_level</code>  <code>property</code>","text":"<p>Get the confidence level used for calculations (read-only).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.distribution","title":"<code>distribution</code>  <code>property</code>","text":"<p>Get the assumed probability distribution (read-only).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.distribution_factor","title":"<code>distribution_factor</code>  <code>property</code>","text":"<p>Get the distribution factor (read-only).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.error_limit","title":"<code>error_limit</code>  <code>property</code>","text":"<p>Get the error limit associated with the measurement  uncertainty.</p> <p>This property returns the maximum allowable deviation from the  true value, which is also known as the tolerance range. If the  error limit was not provided during initialization, it will be  calculated from the standard uncertainty and the distribution  factor. The calculation is based on the assumption that the  error follows the specified probability distribution. (error_limit = u \u00d7 distribution_factor) (read-only).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.expanded","title":"<code>expanded</code>  <code>property</code>","text":"<p>Get expanded uncertainty. If it was not provided during initialization, it will be calculated from the standard uncertainty and coverage factor k (U = k \u00d7 u) (read-only).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.k","title":"<code>k</code>  <code>property</code>","text":"<p>Get the coverage factor <code>k</code> used in uncertainty  calculations (read-only).</p> <p>This property returns the coverage factor, which is a multiplier  used to determine the expanded uncertainty based on the standard  uncertainty. The value of <code>k</code> is typically set to reflect the  desired confidence level in the measurement results.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.standard","title":"<code>standard</code>  <code>property</code>","text":"<p>Get the standard uncertainty (u) (read-only).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__add__","title":"<code>__add__(other)</code>","text":"<p>Add uncertainties using root sum of squares.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__bool__","title":"<code>__bool__()</code>","text":"<p>Check if uncertainty is non-zero.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if uncertainties are equal.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Check if uncertainty is greater than or equal to another.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Check if uncertainty is greater than another.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__le__","title":"<code>__le__(other)</code>","text":"<p>Check if uncertainty is less than or equal to another.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Check if uncertainty is less than another.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__mul__","title":"<code>__mul__(factor)</code>","text":"<p>Multiply uncertainty by a factor.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Check if uncertainties are not equal.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__rmul__","title":"<code>__rmul__(factor)</code>","text":"<p>Right multiplication (factor * uncertainty).</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the uncertainty.</p>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.combine_with","title":"<code>combine_with(*others, method='rss')</code>","text":"<p>Combine this uncertainty with other uncertainties.</p> <p>Parameters:</p> <ul> <li> <code>*others</code>               (<code>MeasurementUncertainty | float</code>, default:                   <code>()</code> )           \u2013            <p>Other uncertainty instances to combine with.</p> </li> <li> <code>method</code>               (<code>(rss, linear)</code>, default:                   <code>'rss'</code> )           \u2013            <p>Combination method: - 'rss': Root sum of squares (for independent uncertainties) - 'linear': Linear addition (for fully correlated uncertainties) Default is 'rss'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MeasurementUncertainty</code>           \u2013            <p>A new instance with the combined uncertainty.</p> </li> </ul> <p>Examples:</p> <pre><code>u_1 = dsp.MeasurementUncertainty(standard=0.1)\nu_2 = dsp.MeasurementUncertainty(error_limit=0.05)\nu_3 = dsp.MeasurementUncertainty(expanded=0.2, k=2)\n\n# Combine using root sum of squares (default)\ncombined_rss = u_1.combine_with(u_2, u_3)\n\n# Combine using linear addition\ncombined_linear = u_1.combine_with(u_2, u_3, method='linear')\n</code></pre>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.quality_indicator","title":"<code>quality_indicator(tolerance)</code>","text":"<p>Calculate the quality indicator Q.</p> <p>Q serves as a quality indicator for the measurement process,  reflecting how well the measurement system performs in relation  to the specified requirements and tolerances. </p> \\[ U = k * u \\] \\[ Q_{MP} = \\frac{2*U}{T} \\]"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.relative","title":"<code>relative(measured_value)</code>","text":"<p>Calculate the relative standard uncertainty as a percentage.</p> <p>Parameters:</p> <ul> <li> <code>measured_value</code>               (<code>float</code>)           \u2013            <p>The measured value to calculate relative uncertainty for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The relative uncertainty as a percentage.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If measured_value is zero.</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.MeasurementUncertainty.summary","title":"<code>summary()</code>","text":"<p>Get a summary of uncertainty values.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, float | str]</code>           \u2013            <p>Dictionary containing various uncertainty representations.</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.root_sum_squares","title":"<code>root_sum_squares(*args)</code>","text":"<p>Calculate the root sum of squares of the given arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>float or int</code>, default:                   <code>()</code> )           \u2013            <p>Values to be summed up</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The root sum of squares of the given arguments.</p> </li> </ul> Notes <p>The root sum of squares is calculated as follows:</p> <p>$$     \\sqrt{x_1^2 + x_2^2 + ... + x_n^2}</p> <p>$$</p> <p>If only one argument is provided, it returns the argument itself.</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If no arguments are provided or if any argument is not of type int or float.</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.estimate_distribution","title":"<code>estimate_distribution(data, dists=DIST.COMMON)</code>","text":"<p>First, the p-score is calculated by performing a  Kolmogorov-Smirnov test to determine how well each distribution fits the data. Whatever has the highest P-score is considered the most accurate. This is because a higher p-score means the hypothesis is closest to reality.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>NumericSample1D</code>)           \u2013            <p>1d array of data for which a distribution is to be searched</p> </li> <li> <code>dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default DIST.COMMON</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dist</code> (              <code>scipy.stats rv_continuous</code> )          \u2013            <p>A generic continous distribution class of best fit</p> </li> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The two-tailed p-value for the best fit</p> </li> <li> <code>shape_params</code> (              <code>Tuple[float, ...]</code> )          \u2013            <p>Estimates for any shape parameters (if applicable), followed  by those for location and scale. For most random variables,  shape statistics will be returned, but there are exceptions  (e.g. norm). Can be used to generate values with the help of returned dist</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.estimate_kernel_density","title":"<code>estimate_kernel_density(data, *, stretch=1, height=None, base=0, n_points=DEFAULT.KD_SEQUENCE_LEN, margin=0.5)</code>","text":"<p>Estimates the kernel density of data and returns values that are  useful for a plot. If those values are plotted in combination with  a histogram, set height as max value of the hostogram.</p> <p>Kernel density estimation is a way to estimate the probability  density function (PDF) of a random variable in a non-parametric way.  The used gaussian_kde function of scipy.stats works for both  uni-variate and multi-variate data. It includes automatic bandwidth  determination. The estimation works best for a unimodal  distribution; bimodal or multi-modal distributions tend to be  oversmoothed.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>NumericSample1D</code>)           \u2013            <p>1-D array of datapoints to estimate from.</p> </li> <li> <code>stretch</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Stretch the distribution estimate by the given factor, is only  considered if \"height\" is None, by default 1</p> </li> <li> <code>height</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>If the KDE curve is plotted in combination with other data  (e.g. a histogram), you can use height to specify the height at  the maximum point of the KDE curve. If this value is specified,  the area under the curve will not be normalized, by default None</p> </li> <li> <code>base</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The curve is shifted in the estimated direction by the given  amount. This is usefull for violine plots, by default 0</p> </li> <li> <code>n_points</code>               (<code>int</code>, default:                   <code>KD_SEQUENCE_LEN</code> )           \u2013            <p>Number of points the estimation and sequence should have, by default KD_SEQUENCE_LEN (defined in constants.py)</p> </li> <li> <code>margin</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Margin for the sequence as factor of data range (max - min ).  If margin is 0, The two ends of the estimated density curve then  show the minimum and maximum value. Default is 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>sequence</code> (              <code>1D array</code> )          \u2013            <p>Data points at regular intervals from input data minimum to  maximum</p> </li> <li> <code>estimation</code> (              <code>1D array</code> )          \u2013            <p>Data points of kernel density estimation</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.estimate_kernel_density_2d","title":"<code>estimate_kernel_density_2d(feature, target, *, n_points=DEFAULT.KD_SEQUENCE_LEN, margin=0.5)</code>","text":"<p>Estimates the kernel density of 2 dimensional data and returns  values that are useful for a contour plot.</p> <p>Kernel density estimation is a way to estimate the probability  density function (PDF) of a random variable in a non-parametric way.  The used gaussian_kde function of scipy.stats works for both  uni-variate and multi-variate data. It includes automatic bandwidth  determination. The estimation works best for a unimodal  distribution; bimodal or multi-modal distributions tend to be  oversmoothed.</p> <p>Parameters:</p> <ul> <li> <code>feature</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the exogenous samples.</p> </li> <li> <code>target</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the endogenous  samples.</p> </li> <li> <code>n_points</code>               (<code>int</code>, default:                   <code>KD_SEQUENCE_LEN</code> )           \u2013            <p>Number of points the estimation and sequence should have, by default KD_SEQUENCE_LEN (defined in constants.py)</p> </li> <li> <code>margin</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Margin for the sequence as factor of data range, by default 0.5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>feature_seq</code> (              <code>2D array</code> )          \u2013            <p>Data points at regular intervals from input data minimum to  maximum used for feature data</p> </li> <li> <code>target_seq</code> (              <code>2D array</code> )          \u2013            <p>Data points at regular intervals from input data minimum to  maximum used for target data</p> </li> <li> <code>estimation</code> (              <code>2D array</code> )          \u2013            <p>Data points of kernel density estimation</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError:</code>             \u2013            <p>If the provided data is empty, contains only zeros or all values are identical.</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.estimate_capability_confidence","title":"<code>estimate_capability_confidence(process, *, kind='cpk', level=0.95, n_groups=1)</code>","text":"<p>Calculates the confidence interval for the process capability  index (Cp or Cpk) of a process.</p> <p>This function is an extension of the <code>cp_ci</code> and <code>cpk_ci</code> functions. It instantiates a <code>ProcessEstimator</code> and then determines the  confidence intervals using the Cp or Cpk values from the estimator.</p> <p>Parameters:</p> <ul> <li> <code>process</code>               (<code>ProcessEstimator</code>)           \u2013            <p>Process Estimator instance, is required to get the necessary  process information such as capability indices and number of  samples.</p> </li> <li> <code>kind</code>               (<code>Literal['cp', 'cpk]</code>, default:                   <code>'cpk'</code> )           \u2013            <p>Specifies whether to calculate the confidence interval for Cp or  Cpk ('cp' or 'cpk'). Defaults is 'cpk'.</p> </li> <li> <code>level</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>The desired confidence level for the interval, expressed as a  decimal. Default is 0.95 (95% confidence).</p> </li> <li> <code>n_groups</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of groups for Bonferroni correction to adjust for  multiple comparisons. Default is 1, indicating no correction</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float]:</code>           \u2013            <p>A tuple containing the estimate, lower bound, and upper bound of  the confidence interval for the specified process capability  index.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError:</code>             \u2013            <p>If provided kind is not 'cp' or 'cpk'.</p> </li> <li> <code>ValueError:</code>             \u2013            <p>If no limit is provided or if only one limit is provided and  kind is set to 'cp'.</p> </li> </ul>"},{"location":"statistics/estimation/#daspi.statistics.estimation.estimate_resolution","title":"<code>estimate_resolution(data)</code>","text":"<p>Estimate the resolution based on the length of the samples  digits.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>NumericSample1D</code>)           \u2013            <p>1-D array of datapoints to estimate from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The estimated resolution.</p> </li> </ul>"},{"location":"statistics/estimation/distribution-estimator/","title":"Distribution estimator","text":""},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator","title":"<code>daspi.statistics.estimation.DistributionEstimator</code>","text":"<p>               Bases: <code>BaseEstimator</code></p> <p>A class to estimate the distribution of a given 1D numeric sample.</p> <p>This class provides methods to estimate distribution by fitting a continuous distribution from <code>scipy.stats</code> to the provided samples. It uses the Kolmogorov-Smirnov test to evaluate the fit of the distribution to the data. The distribution with a higher p-value is considered a better fit.</p> <p>Parameters:</p> <ul> <li> <code>samples</code>               (<code>NumericSample1D</code>)           \u2013            <p>The 1D numeric sample for which the distribution is to be  estimated. This should be a Series or array-like object containing numeric values.</p> </li> <li> <code>dist</code>               (<code>str rv_continuous</code>, default:                   <code>None</code> )           \u2013            <p>Distributions to which the data may be subject. Only continuous  distributions of scipy.stats are allowed. Default is 'norm'</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default <code>DIST.COMMON</code></p> </li> <li> <code>nan_policy</code>               (<code>(propagate, 'raise', omit)</code>, default:                   <code>'propagate'</code> )           \u2013            <p>How to handle NaN values in the samples.  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis, default is 'omit'.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set to  'raise'.</p> </li> <li> <code>UserWarning</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set  to 'omit' or 'propagate'. The warning indicates that NaN values  will be omitted from the analysis or may lead to unexpected  results.</p> </li> </ul> Sources <p>The theoretical quantiles and percentiles are calculated the same  way as statsmodels ProbPlot class does, see: https://www.statsmodels.org/dev/_modules/statsmodels/graphics/gofplots.html</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.D","title":"<code>D</code>  <code>property</code>","text":"<p>Get the Kolmogorov-Smirnov test statistic, either D, D+ or  D-.</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.aic","title":"<code>aic</code>  <code>property</code>","text":"<p>Get the Akaike information criterion (AIC) (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.attrs_describe","title":"<code>attrs_describe</code>  <code>property</code>","text":"<p>Get attribute names used for <code>describe</code> method.</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.bic","title":"<code>bic</code>  <code>property</code>","text":"<p>Get the Bayesian information criterion (BIC) (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.dist","title":"<code>dist</code>  <code>property</code> <code>writable</code>","text":"<p>This is the generic continuous distribution class of the  provided or evaluated distribution.</p> <p>Set the distribution to be used for estimation. If a string  is provided, it will be converted to a continuous distribution  class using <code>ensure_generic</code>. If None, the distribution will be  estimated from the samples.</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.dist_name","title":"<code>dist_name</code>  <code>property</code>","text":"<p>Get the name of the estimated distribution (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.excess","title":"<code>excess</code>  <code>property</code>","text":"<p>Get the Fisher kurtosis (excess) of filtered samples. Calculations are corrected for statistical bias (read-only). The curvature of the distribution corresponds to the  curvature of a normal distribution when the excess is close to  zero. Distributions with negative excess kurtosis are said to be  platykurtic, this distribution produces fewer and/or less  extreme outliers than the normal distribution (e.g. the uniform  distribution has no outliers). Distributions with a positive  excess kurtosis are said to be leptokurtic (e.g. the Laplace  distribution, which has tails that asymptotically approach zero  more slowly than a Gaussian, and therefore produces more  outliers than the normal distribution):     - excess &lt; 0: less extreme outliers than normal distribution     - excess &gt; 0: more extreme outliers than normal distribution</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.filtered","title":"<code>filtered</code>  <code>property</code>","text":"<p>Get the samples without error values and no missing value  (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.frozen","title":"<code>frozen</code>  <code>property</code>","text":"<p>This is the frozen continuous RV object of dist property  (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Get the <code>loc</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.log_likelihood","title":"<code>log_likelihood</code>  <code>property</code>","text":"<p>Get the log-likelihood of the provided or evaluated  distribution (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.n_filtered","title":"<code>n_filtered</code>  <code>property</code>","text":"<p>Get sample size of filtered samples (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.n_missing","title":"<code>n_missing</code>  <code>property</code>","text":"<p>Get amount of missing values (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Get sample size of unfiltered samples (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.nan_policy","title":"<code>nan_policy</code>  <code>property</code>","text":"<p>How to handle NaN values in the samples (read-only).  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.p_ad","title":"<code>p_ad</code>  <code>property</code>","text":"<p>Get the probability that the filtered samples are subject of the normal distribution by performing a Anderson-Darling test (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.p_excess","title":"<code>p_excess</code>  <code>property</code>","text":"<p>Get the probability that the excess of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.p_ks","title":"<code>p_ks</code>  <code>property</code>","text":"<p>Get the two-tailed p-value of kolmogorov-smirnof test for  the provided or fitted  distribution. A higher p-value indicates  a better fit to the data (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.p_skew","title":"<code>p_skew</code>  <code>property</code>","text":"<p>Get the probability that the skewness of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.possible_dists","title":"<code>possible_dists = possible_dists</code>  <code>instance-attribute</code>","text":"<p>Distributions given during initialization to which the data may  be subject.</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.predicted","title":"<code>predicted</code>  <code>property</code>","text":"<p>Get the predicted values of the provided or evaluated  distribution by using the order statistic medians (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.sample_percentiles","title":"<code>sample_percentiles</code>  <code>property</code>","text":"<p>Get the empirical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.sample_quantiles","title":"<code>sample_quantiles</code>  <code>property</code>","text":"<p>Get the sample quantiles (sorted filtered samples) (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.samples","title":"<code>samples</code>  <code>property</code>","text":"<p>Get the raw samples as it was given during instantiation as pandas Series (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Get the <code>scale</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.shape_params","title":"<code>shape_params</code>  <code>property</code>","text":"<p>Estimates for any distribution shape parameters (if  applicable), followed by those for location and scale. For most  random variables, shape statistics will be returned, but there  are exceptions (e.g. norm). Can be used to generate values with  the help of the dist attribute (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.skew","title":"<code>skew</code>  <code>property</code>","text":"<p>Get the skewness of the filtered samples (read-only). Calculations are corrected for statistical bias. For normally distributed data, the skewness should be about zero.  For unimodal continuous distributions, a skewness value greater  than zero means that there is more weight in the right tail of  the distribution:     - skew &lt; 0: left-skewed -&gt; long tail left     - skew &gt; 0: right-skewed -&gt; long tail right</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.sorted","title":"<code>sorted</code>  <code>property</code>","text":"<p>Get the filtered samples sorted by value with new index (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.ss","title":"<code>ss</code>  <code>property</code>","text":"<p>Get the sum of squared residuals (SS) using the sorted values and the predicted values (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.theoretical_percentiles","title":"<code>theoretical_percentiles</code>  <code>property</code>","text":"<p>Get the theoretical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.theoretical_quantiles","title":"<code>theoretical_quantiles</code>  <code>property</code>","text":"<p>Get the theoretical quantiles (osm, or order statistic  medians) of the filtered samples. This quantiles are calculated the same way as in <code>scipy.stats.probplot()</code> function  (read-only).</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.describe","title":"<code>describe(exclude=(), colname=None)</code>","text":"<p>Generate descriptive statistics.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Attributes to exclude from the summary statistics, by default ()</p> </li> <li> <code>colname</code>               (<code>str | Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Column name for the resulting DataFrame, by default None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stats</code> (              <code>DataFrame</code> )          \u2013            <p>Summary statistics as pandas DataFrame. The indices of the DataFrame are the attributes that have been computed and the column name is the name of the samples.</p> </li> </ul>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.distribution","title":"<code>distribution()</code>","text":"<p>Estimate the distribution by selecting the one from the provided distributions that best reflects the filtered data.</p> <p>Returns:</p> <ul> <li> <code>dist</code> (              <code>scipy.stats rv_continuous</code> )          \u2013            <p>A generic continous distribution class of best fit</p> </li> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The two-tailed p-value for the best fit</p> </li> <li> <code>shape_params</code> (              <code>Tuple[float, ...]</code> )          \u2013            <p>Estimates for any shape parameters (if applicable), followed by those for location and scale. For most random variables, shape statistics will be returned, but there are exceptions (e.g. norm). Can be used to generate values with the help of returned dist</p> </li> </ul> Notes <p>First, the p-score is calculated by performing a  Kolmogorov-Smirnov test to determine how well each distribution  fits the samples. Whatever has the highest P-score is considered the most accurate. This is because a higher p-score means the  hypothesis is closest to reality.</p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.follows_norm_curve","title":"<code>follows_norm_curve(alpha=0.05, excess_test=True, skew_test=True, ad_test=False)</code>","text":"<p>Checks whether the sample data is subject to normal  distribution by performing one or more of the following tests  (depending on the input): - Skewness test - Bulge test - Anderson-Darling test</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>skew_test</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, an skew test will also be carried out, by default  True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an excess test will also be carried out, by default True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an Anderson Darling test will also be carried out, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>remain_h0</code> (              <code>bool</code> )          \u2013            <p>True if all p-values of the tests performed are greater than  alpha, otherwise False</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If all flags are False.</p> </li> </ul>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.mask_missing","title":"<code>mask_missing()</code>","text":"<p>Returns a boolean mask indicating which samples are missing  (NaN).</p> <p>This mask can be used to filter or analyze entries in the  <code>samples</code> attribute that contain missing values.</p> <p>Returns:</p> <ul> <li> <code>Series[bool]:</code>           \u2013            <p>A boolean Series where True indicates a missing sample.</p> </li> </ul>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.mask_ok","title":"<code>mask_ok()</code>","text":"<p>Returns a boolean mask indicating which samples are valid  (OK).</p> <p>A sample is considered OK if it is: - Not missing (i.e., not NaN)</p> <p>Returns:</p> <ul> <li> <code>Series[bool]</code>           \u2013            <p>A boolean Series where True indicates a valid sample.</p> </li> </ul>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.plotting_positions","title":"<code>plotting_positions(nobs, alpha=0.0, beta=None)</code>  <code>staticmethod</code>","text":"<p>Generates sequence of plotting positions</p> <p>Parameters:</p> <ul> <li> <code>nobs</code>               (<code>int</code>)           \u2013            <p>Number of probability points to plot</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>alpha parameter for the plotting position of an expected order statistic</p> </li> <li> <code>beta</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>beta parameter for the plotting position of an expected order statistic. If None, then beta is set to alpha.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The plotting positions</p> </li> </ul> Notes <p>The plotting positions are given by </p> \\[ i \\in [1, nobs]) \\] \\[ \\frac{(i - \\alpha)}{nobs + 1 - \\alpha - \\beta} \\] <p>Additional information on alpha and beta see: <code>scipy.stats.mstats.plotting_positions</code></p>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.stable_mean","title":"<code>stable_mean(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the mean remains stable across the samples. </p> <p>The sample data is divided into subgroups and the mean of their  sections are checked using the F test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/distribution-estimator/#daspi.statistics.estimation.DistributionEstimator.stable_variance","title":"<code>stable_variance(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the variance remains stable across the samples. </p> <p>The sample data is divided into subgroups and the variances of their sections are checked using the Levene test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/","title":"Gage estimator","text":""},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator","title":"<code>daspi.statistics.estimation.GageEstimator</code>","text":"<p>               Bases: <code>LocationDispersionEstimator</code></p> <p>Estimates the process capability of a single measurement system using the Gage Study Type 1 method.</p> <p>Parameters:</p> <ul> <li> <code>samples</code>               (<code>NumericSample1D</code>)           \u2013            <p>The samples used to estimate the process capability.</p> </li> <li> <code>reference</code>               (<code>float | None</code>)           \u2013            <p>The reference value of the sample under test.</p> </li> <li> <code>u_cal</code>               (<code>MeasurementUncertainty | float</code>)           \u2013            <p>The measurement uncertainty of the gage used to measure the  reference value. If a float is specified, it is assumed to be  the expanded uncertainty with a coverage factor of <code>k = 2</code>.</p> </li> <li> <code>tolerance</code>               (<code>float | SpecLimits | Specification</code>)           \u2013            <p>The tolerance range for the measurement.</p> </li> <li> <code>resolution</code>               (<code>float | None</code>)           \u2013            <p>The resolution of the measurement system. If None, the  resolution is estimated from the samples.</p> </li> <li> <code>tolerance_ratio</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>The proportion of the tolerance range (between 0 and 1) used  to calculate the adjusted limits, default is 0.2 (20%).</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given    evaluate function. If none is given, the internal <code>evaluate</code>   method is used. - <code>fit</code>: First, the distribution that best represents the    process data is searched for and then the agreed process    spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal    distribution. The variation tolerance is then calculated as    agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance    are read directly from the data.</p> <p>Default is 'eval'.</p> </li> <li> <code>agreement</code>               (<code>int | float</code>, default:                   <code>4</code> )           \u2013            <p>The multiplier of the standard deviation for Cg and Cgk values. If an integer is given, the value is interpreted as the number of standard deviations (e.g., 4 for 4\u03c3). If a float is given, it is interpreted as the acceptable proportion for the spread, e.g. 0.9544 (which corresponds to ~ 4 \u03c3). Simply put,  this is twice the coverage factor k. Default is 4, because  a common coverage factor k is 2.</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default <code>DIST.COMMON</code></p> </li> <li> <code>evaluate</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Provide a function that evaluates the <code>strategy</code>. If <code>strategy</code> is set to 'eval', this function is used to determine the strategy. The function should take the <code>samples</code> as input and return a string that corresponds to a valid strategy 'fit', 'norm', or 'data'. If not provided, the internal <code>evaluate</code> method is used. For more information on the <code>evaluate</code> method, see the class documentation. Default is None.</p> </li> <li> <code>cg_limit</code>               (<code>float</code>, default:                   <code>1.33</code> )           \u2013            <p>The limit for the capability index, default is 1.33.</p> </li> <li> <code>cgk_limit</code>               (<code>float</code>, default:                   <code>1.33</code> )           \u2013            <p>The limit for the capability index, default is 1.33.</p> </li> <li> <code>resolution_ratio_limit</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The limit for the resolution proportion, default is 0.05.</p> </li> <li> <code>nan_policy</code>               (<code>(propagate, 'raise', omit)</code>, default:                   <code>'propagate'</code> )           \u2013            <p>How to handle NaN values in the samples.  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis, default is 'omit'.</p> </li> </ul> <p>Examples:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('grnr_adjustment')\ngage = dsp.GageEstimator(\n    samples=df['result_gage'],\n    reference=df['reference'][0],\n    u_cal=df['U_cal'][0],\n    tolerance=df['tolerance'][0],\n    resolution=df['resolution'][0])\nprint(gage.describe())\n</code></pre> <pre><code>                   result_gage\nn_samples         6.000000e+01\nn_missing         6.000000e+00\nn_outlier         0.000000e+00\nmin               1.000700e+00\nmax               1.001600e+00\nR                 9.000000e-04\nmean              1.000809e+00\nmedian            1.000800e+00\nstd               1.306999e-04\nsem               1.778600e-05\np_ad              9.866969e-20\nlower             9.870000e-01\nupper             1.013000e+00\ncg                3.315484e+01\ncgk               3.109092e+01\nbias              8.092593e-04\np_bias            3.723292e-44\nT_min_cg          5.214925e-03\nT_min_cgk         1.330752e-02\nT_min_res         2.000000e-03\nresolution_ratio  7.692308e-04\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set to  'raise'.</p> </li> <li> <code>UserWarning</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set  to 'omit' or 'propagate'. The warning indicates that NaN values  will be omitted from the analysis or may lead to unexpected  results.</p> </li> </ul> References <p>[1] Dr. Bill McNeese, BPI Consulting, LLC (09.2012)     https://www.spcforexcel.com/knowledge/measurement-systems-analysis-gage-rr/anova-gage-rr-part-1/</p> <p>[2] VDA Band 5, Mess- und Pr\u00fcfprozesse. Eignung, Planung und Management     (Juli 2021) 3. \u00fcberarbeitete Auflage</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.D","title":"<code>D</code>  <code>property</code>","text":"<p>Get the Kolmogorov-Smirnov test statistic, either D, D+ or  D-.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.R","title":"<code>R</code>  <code>property</code>","text":"<p>Get range of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.T_min_cg","title":"<code>T_min_cg</code>  <code>property</code>","text":"<p>The minimum allowed tolerance for this testing system based on the capability cg of the process (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.T_min_cgk","title":"<code>T_min_cgk</code>  <code>property</code>","text":"<p>The minimum allowed tolerance for this testing system based on the capability cgk of the process (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.T_min_res","title":"<code>T_min_res</code>  <code>property</code>","text":"<p>The minimum allowed tolerance for this testing system based on the resolution of the testing system (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.agreement","title":"<code>agreement</code>  <code>property</code> <code>writable</code>","text":"<p>Get the agreement multiplier for the \u03c3 (standard deviation)  used in calculating Cp and Cpk values.</p> <p>The agreement is defined as twice the coverage factor <code>k</code>.  Setting this value will reset the Cp and Cpk values to None,  reflecting that the underlying uncertainty parameters have  changed.</p> <p>When setting the agreement using a percentile, provide the  acceptable proportion for the spread, such as 0.9973,  which corresponds to approximately 6\u03c3 (six standard deviations). The agreement value must be specified as either: - A percentage (0.0 &lt; agreement &lt;= 1.0) indicating the   acceptable proportion for the spread. - A multiple of the standard deviation (agreement &gt;= 1).</p> <p>Special Case: - If the agreement is set to 1 (indicating a standard deviation    multiplier), enter it as an integer (1).  - For percentiles or a broader range, use a floating-point    representation (e.g., 1.0) or <code>float('inf')</code> for an infinite   range.</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the provided agreement value is not in the valid range  (0.0 &lt; agreement &lt;= 1.0 for percentiles or agreement &gt;= 1  for standard deviation multipliers).</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.aic","title":"<code>aic</code>  <code>property</code>","text":"<p>Get the Akaike information criterion (AIC) (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.attrs_describe","title":"<code>attrs_describe</code>  <code>property</code>","text":"<p>Get attribute names used for <code>describe</code> method.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.bias","title":"<code>bias</code>  <code>property</code>","text":"<p>The bias of the process (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.bic","title":"<code>bic</code>  <code>property</code>","text":"<p>Get the Bayesian information criterion (BIC) (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.cg","title":"<code>cg</code>  <code>property</code>","text":"<p>The repeatability of the measuring system without taking bias into account (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.cg_limit","title":"<code>cg_limit</code>  <code>property</code>","text":"<p>The limit of the capability index (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.cgk","title":"<code>cgk</code>  <code>property</code>","text":"<p>The repeatability of the measuring system taking into account  the bias(read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.cgk_limit","title":"<code>cgk_limit</code>  <code>property</code>","text":"<p>The limit of the capability index (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.dist","title":"<code>dist</code>  <code>property</code> <code>writable</code>","text":"<p>This is the generic continuous distribution class of the  provided or evaluated distribution.</p> <p>Set the distribution to be used for estimation. If a string  is provided, it will be converted to a continuous distribution  class using <code>ensure_generic</code>. If None, the distribution will be  estimated from the samples.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.dist_name","title":"<code>dist_name</code>  <code>property</code>","text":"<p>Get the name of the estimated distribution (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.dof","title":"<code>dof</code>  <code>property</code>","text":"<p>Get degree of freedom for filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.excess","title":"<code>excess</code>  <code>property</code>","text":"<p>Get the Fisher kurtosis (excess) of filtered samples. Calculations are corrected for statistical bias (read-only). The curvature of the distribution corresponds to the  curvature of a normal distribution when the excess is close to  zero. Distributions with negative excess kurtosis are said to be  platykurtic, this distribution produces fewer and/or less  extreme outliers than the normal distribution (e.g. the uniform  distribution has no outliers). Distributions with a positive  excess kurtosis are said to be leptokurtic (e.g. the Laplace  distribution, which has tails that asymptotically approach zero  more slowly than a Gaussian, and therefore produces more  outliers than the normal distribution):     - excess &lt; 0: less extreme outliers than normal distribution     - excess &gt; 0: more extreme outliers than normal distribution</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.filtered","title":"<code>filtered</code>  <code>property</code>","text":"<p>Get the samples without error values and no missing value  (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.frozen","title":"<code>frozen</code>  <code>property</code>","text":"<p>This is the frozen continuous RV object of dist property  (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.k","title":"<code>k</code>  <code>property</code>","text":"<p>Get the coverage factor <code>k</code> used in uncertainty  calculations (read-only).</p> <p>This property returns the coverage factor, which is a multiplier  used to determine the expanded uncertainty based on the standard  uncertainty. The value of <code>k</code> is typically set to reflect the  desired confidence level in the measurement results.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.lcl","title":"<code>lcl</code>  <code>property</code>","text":"<p>Get lower control limit according to given strategy and  agreement (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.limits","title":"<code>limits</code>  <code>property</code>","text":"<p>The adjusted specification limits of the process (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Get the <code>loc</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.log_likelihood","title":"<code>log_likelihood</code>  <code>property</code>","text":"<p>Get the log-likelihood of the provided or evaluated  distribution (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>The adjusted lower specification limit (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.max","title":"<code>max</code>  <code>property</code>","text":"<p>Get the maximum value of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.mean","title":"<code>mean</code>  <code>property</code>","text":"<p>Get mean of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.median","title":"<code>median</code>  <code>property</code>","text":"<p>Get median of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.min","title":"<code>min</code>  <code>property</code>","text":"<p>Get the minimum value of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.n_filtered","title":"<code>n_filtered</code>  <code>property</code>","text":"<p>Get sample size of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.n_missing","title":"<code>n_missing</code>  <code>property</code>","text":"<p>Get amount of missing values (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.n_outlier","title":"<code>n_outlier</code>  <code>property</code>","text":"<p>The number of outliers in the measurement process (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Get sample size of unfiltered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.nan_policy","title":"<code>nan_policy</code>  <code>property</code>","text":"<p>How to handle NaN values in the samples (read-only).  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.nominal","title":"<code>nominal</code>  <code>property</code>","text":"<p>The nominal value of the specification (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.p_ad","title":"<code>p_ad</code>  <code>property</code>","text":"<p>Get the probability that the filtered samples are subject of the normal distribution by performing a Anderson-Darling test (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.p_bias","title":"<code>p_bias</code>  <code>property</code>","text":"<p>The probability of the bias being significant by performing a t-test (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.p_excess","title":"<code>p_excess</code>  <code>property</code>","text":"<p>Get the probability that the excess of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.p_ks","title":"<code>p_ks</code>  <code>property</code>","text":"<p>Get the two-tailed p-value of kolmogorov-smirnof test for  the provided or fitted  distribution. A higher p-value indicates  a better fit to the data (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.p_skew","title":"<code>p_skew</code>  <code>property</code>","text":"<p>Get the probability that the skewness of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.possible_dists","title":"<code>possible_dists = possible_dists</code>  <code>instance-attribute</code>","text":"<p>Distributions given during initialization to which the data may  be subject.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.predicted","title":"<code>predicted</code>  <code>property</code>","text":"<p>Get the predicted values of the provided or evaluated  distribution by using the order statistic medians (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.process","title":"<code>process</code>  <code>property</code>","text":"<p>The process for which the measurement system is to be  evaluated (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.q_low","title":"<code>q_low</code>  <code>property</code>","text":"<p>Get quantil for lower control limit according to given  agreement. If the samples is subject to normal distribution and  the agreement is given as 6, this value corresponds to the  0.135 % quantile: 6 \u03c3 ~ 99.73 % of the samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.q_upp","title":"<code>q_upp</code>  <code>property</code>","text":"<p>Get quantil for upper control limit according to given  agreement. If the sample data is subject to normal distribution  and the agreement is given as 6, this value corresponds to the  Q_0.99865: 0.99865-quantile or 99.865-percentile (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.reference","title":"<code>reference</code>  <code>property</code> <code>writable</code>","text":"<p>The calibrated value of the sample under test.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.resolution","title":"<code>resolution</code>  <code>property</code> <code>writable</code>","text":"<p>The resolution of the measurement.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.resolution_ratio_limit","title":"<code>resolution_ratio_limit</code>  <code>property</code> <code>writable</code>","text":"<p>The limit of the resolution ratio.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.sample_percentiles","title":"<code>sample_percentiles</code>  <code>property</code>","text":"<p>Get the empirical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.sample_quantiles","title":"<code>sample_quantiles</code>  <code>property</code>","text":"<p>Get the sample quantiles (sorted filtered samples) (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.samples","title":"<code>samples</code>  <code>property</code>","text":"<p>Get the raw samples as it was given during instantiation as pandas Series (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Get the <code>scale</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.sem","title":"<code>sem</code>  <code>property</code>","text":"<p>Get standard error mean of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.shape_params","title":"<code>shape_params</code>  <code>property</code>","text":"<p>Estimates for any distribution shape parameters (if  applicable), followed by those for location and scale. For most  random variables, shape statistics will be returned, but there  are exceptions (e.g. norm). Can be used to generate values with  the help of the dist attribute (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.skew","title":"<code>skew</code>  <code>property</code>","text":"<p>Get the skewness of the filtered samples (read-only). Calculations are corrected for statistical bias. For normally distributed data, the skewness should be about zero.  For unimodal continuous distributions, a skewness value greater  than zero means that there is more weight in the right tail of  the distribution:     - skew &lt; 0: left-skewed -&gt; long tail left     - skew &gt; 0: right-skewed -&gt; long tail right</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.sorted","title":"<code>sorted</code>  <code>property</code>","text":"<p>Get the filtered samples sorted by value with new index (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.specification","title":"<code>specification</code>  <code>property</code> <code>writable</code>","text":"<p>The specification holding the limits, nominal and tolerance  of the process.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.ss","title":"<code>ss</code>  <code>property</code>","text":"<p>Get the sum of squared residuals (SS) using the sorted values and the predicted values (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.std","title":"<code>std</code>  <code>property</code>","text":"<p>Get standard deviation of filtered samples (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.strategy","title":"<code>strategy</code>  <code>property</code> <code>writable</code>","text":"<p>Strategy used to determine the control limits. The control  limits can also be interpreted as the process range.</p> <p>Set strategy as one of {'eval', 'fit', 'norm', 'data'}     - eval: If no evaluate function is given, the strategy is      determined according to the internal evaluate method.      - fit: First, the distribution is searched for that best      represents the process data and then the process variation      tolerance is calculated     - norm: it is assumed that the data is subject to normal      distribution. The variation tolerance is then calculated as      agreement * standard deviation     - data: The quantiles for the process variation tolerance      are read directly from the samples.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.theoretical_percentiles","title":"<code>theoretical_percentiles</code>  <code>property</code>","text":"<p>Get the theoretical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.theoretical_quantiles","title":"<code>theoretical_quantiles</code>  <code>property</code>","text":"<p>Get the theoretical quantiles (osm, or order statistic  medians) of the filtered samples. This quantiles are calculated the same way as in <code>scipy.stats.probplot()</code> function  (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.tolerance","title":"<code>tolerance</code>  <code>property</code>","text":"<p>The tolerance of the specification (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.tolerance_adj","title":"<code>tolerance_adj</code>  <code>property</code>","text":"<p>The adjusted tolerance of the specification  (tolerance_ratio * tolerance) (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.tolerance_ratio","title":"<code>tolerance_ratio</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the ratio of the tolerance range used in the calculation  of adjusted limits. This value represents the proportion of the  total tolerance that is allocated for adjustments.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.u_cal","title":"<code>u_cal</code>  <code>property</code>","text":"<p>The expanded uncertainty of the calibration.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.ucl","title":"<code>ucl</code>  <code>property</code>","text":"<p>Get upper control limit according to given strategy and  agreement (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>The adjusted upper specification limit (read-only).</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.check","title":"<code>check()</code>","text":"<p>Perform a few checks to determine if the testing system is  capable of measuring the process.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.describe","title":"<code>describe(exclude=(), colname=None)</code>","text":"<p>Generate descriptive statistics.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Attributes to exclude from the summary statistics, by default ()</p> </li> <li> <code>colname</code>               (<code>str | Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Column name for the resulting DataFrame, by default None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stats</code> (              <code>DataFrame</code> )          \u2013            <p>Summary statistics as pandas DataFrame. The indices of the DataFrame are the attributes that have been computed and the column name is the name of the samples.</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.distribution","title":"<code>distribution()</code>","text":"<p>Estimate the distribution by selecting the one from the provided distributions that best reflects the filtered data.</p> <p>Returns:</p> <ul> <li> <code>dist</code> (              <code>scipy.stats rv_continuous</code> )          \u2013            <p>A generic continous distribution class of best fit</p> </li> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The two-tailed p-value for the best fit</p> </li> <li> <code>shape_params</code> (              <code>Tuple[float, ...]</code> )          \u2013            <p>Estimates for any shape parameters (if applicable), followed by those for location and scale. For most random variables, shape statistics will be returned, but there are exceptions (e.g. norm). Can be used to generate values with the help of returned dist</p> </li> </ul> Notes <p>First, the p-score is calculated by performing a  Kolmogorov-Smirnov test to determine how well each distribution  fits the samples. Whatever has the highest P-score is considered the most accurate. This is because a higher p-score means the  hypothesis is closest to reality.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.estimate_resolution","title":"<code>estimate_resolution()</code>","text":"<p>Estimate the resolution of the testing system.</p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate strategy to calculate control limits. If no evaluate function is given the strategy is evaluated as follows:</p> <ol> <li>If variance is not stable within the samples -&gt; strategy = 'data'</li> <li>If variance and mean is stable and samples follow a normal  curve -&gt; strategy = 'norm'</li> <li>If variance and mean is stable but samples don't follow a normal curve -&gt; strategy = 'fit'</li> <li>If variance is stable but mean not and samples follow a  normal curve -&gt; strategy = 'norm'</li> <li>If variance is stable but mean not and samples don't follow a  normal curve -&gt; strategy = 'data'</li> </ol> <p>Returns:</p> <ul> <li> <code>strategy</code> (              <code>{fit, norm, data}</code> )          \u2013            <p>Evaluated strategy to calculate control limits</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.follows_norm_curve","title":"<code>follows_norm_curve(alpha=0.05, excess_test=True, skew_test=True, ad_test=False)</code>","text":"<p>Checks whether the sample data is subject to normal  distribution by performing one or more of the following tests  (depending on the input): - Skewness test - Bulge test - Anderson-Darling test</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>skew_test</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, an skew test will also be carried out, by default  True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an excess test will also be carried out, by default True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an Anderson Darling test will also be carried out, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>remain_h0</code> (              <code>bool</code> )          \u2013            <p>True if all p-values of the tests performed are greater than  alpha, otherwise False</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If all flags are False.</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.mask_missing","title":"<code>mask_missing()</code>","text":"<p>Returns a boolean mask indicating which samples are missing  (NaN).</p> <p>This mask can be used to filter or analyze entries in the  <code>samples</code> attribute that contain missing values.</p> <p>Returns:</p> <ul> <li> <code>Series[bool]:</code>           \u2013            <p>A boolean Series where True indicates a missing sample.</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.mask_ok","title":"<code>mask_ok()</code>","text":"<p>Returns a boolean mask indicating which samples are valid  (OK).</p> <p>A sample is considered OK if it is: - Not missing (i.e., not NaN)</p> <p>Returns:</p> <ul> <li> <code>Series[bool]</code>           \u2013            <p>A boolean Series where True indicates a valid sample.</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.mean_ci","title":"<code>mean_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for mean of filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.median_ci","title":"<code>median_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for median of filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.plotting_positions","title":"<code>plotting_positions(nobs, alpha=0.0, beta=None)</code>  <code>staticmethod</code>","text":"<p>Generates sequence of plotting positions</p> <p>Parameters:</p> <ul> <li> <code>nobs</code>               (<code>int</code>)           \u2013            <p>Number of probability points to plot</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>alpha parameter for the plotting position of an expected order statistic</p> </li> <li> <code>beta</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>beta parameter for the plotting position of an expected order statistic. If None, then beta is set to alpha.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The plotting positions</p> </li> </ul> Notes <p>The plotting positions are given by </p> \\[ i \\in [1, nobs]) \\] \\[ \\frac{(i - \\alpha)}{nobs + 1 - \\alpha - \\beta} \\] <p>Additional information on alpha and beta see: <code>scipy.stats.mstats.plotting_positions</code></p>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.stable_mean","title":"<code>stable_mean(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the mean remains stable across the samples. </p> <p>The sample data is divided into subgroups and the mean of their  sections are checked using the F test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.stable_variance","title":"<code>stable_variance(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the variance remains stable across the samples. </p> <p>The sample data is divided into subgroups and the variances of their sections are checked using the Levene test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.stdev_ci","title":"<code>stdev_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for standard deviation of  filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/gage-estimator/#daspi.statistics.estimation.GageEstimator.z_transform","title":"<code>z_transform(x)</code>","text":"<p>Transform value to z-score.</p> <p>This method produces a value from a distribution with a mean of  0 and a standard deviation of 1. The value indicates how many standard deviations the value is from the mean.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>value to be transformed</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>z</code> (              <code>float</code> )          \u2013            <p>z-score</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/","title":"Location dispersion estimator","text":""},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator","title":"<code>daspi.statistics.estimation.LocationDispersionEstimator</code>","text":"<p>               Bases: <code>DistributionEstimator</code></p> <p>An object for various statistical estimators</p> <p>The attributes are calculated lazily. After the class is  instantiated, all attributes are set to None. As soon as an  attribute (actually Property) is called, the value is calculated and stored so that the calculation is only performed once</p> <p>Parameters:</p> <ul> <li> <code>samples</code>               (<code>NumericSample1D</code>)           \u2013            <p>sample data</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given    evaluate function. If none is given, the internal <code>evaluate</code>   method is used. - <code>fit</code>: First, the distribution that best represents the    process data is searched for and then the agreed process    spread is calculated - <code>norm</code>: it is assumed that the data is subject to normal    distribution. The variation tolerance is then calculated as    agreement * standard deviation - <code>data</code>: The quantiles for the process variation tolerance    are read directly from the data.</p> <p>Default is 'norm'.</p> </li> <li> <code>agreement</code>               (<code>int or float</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal    distribution agreement\u03c3,    e.g. agreement = 6 -&gt; 6\u03c3 ~ covers 99.75 % of the data.    The upper and lower permissible quantiles are then    calculated from this. - If float, the value must be between 0 and 1.This value is   then interpreted as the acceptable proportion for the    spread, e.g. 0.9973 (which corresponds to ~ 6 \u03c3)</p> <p>Default is 6 because SixSigma ;-)</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default <code>DIST.COMMON</code></p> </li> <li> <code>evaluate</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Provide a function that evaluates the <code>strategy</code>. If <code>strategy</code> is set to 'eval', this function is used to determine the strategy. The function should take the <code>samples</code> as input and return a string that corresponds to a valid strategy 'fit', 'norm', or 'data'. If not provided, the internal <code>evaluate</code> method is used. For more information on the <code>evaluate</code> method, see the class documentation. Default is None.</p> </li> <li> <code>nan_policy</code>               (<code>(propagate, 'raise', omit)</code>, default:                   <code>'propagate'</code> )           \u2013            <p>How to handle NaN values in the samples.  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis, default is 'omit'.</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nimport daspi as dsp\n\nnp.random.seed(1)\nsamples = data = np.random.weibull(a=1.5, size=100)\nestimation = dsp.LocationDispersionEstimator(\n    samples=samples,\n    strategy='fit',\n    agreement=6,\n    possible_dists=dsp.DIST.COMMON_NOT_NORM)\nprint(estimation.describe())\n</code></pre> <p>So you will receive the following output:</p> <pre><code>                  None\nn_samples          100\nn_missing            0\nmin           0.002356\nmax           2.724595\nR             2.722239\nmean           0.86943\nmedian         0.74006\nstd           0.593666\nsem           0.059367\ndist       weibull_min\np_ks          0.968613\np_ad          0.000455\nexcess        0.163836\np_excess      0.599041\nskew          0.802202\np_skew        0.001918\nstrategy           fit\nlcl          -0.004917\nucl            3.43952\n</code></pre> Notes <p>A special case occurs when the agreement is 1. For a corresponding standard deviation, enter 1 as an integer. If you want percentiles  or the entire range, enter it as a floating-point number (1.0) or as  <code>float('inf')</code>. If strategy is 'data', <code>lcl</code> and <code>ucl</code> correspond to  <code>min</code> and <code>max</code>, otherwise we get <code>-inf</code> and <code>inf</code>.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set to  'raise'.</p> </li> <li> <code>UserWarning</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set  to 'omit' or 'propagate'. The warning indicates that NaN values  will be omitted from the analysis or may lead to unexpected  results.</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.D","title":"<code>D</code>  <code>property</code>","text":"<p>Get the Kolmogorov-Smirnov test statistic, either D, D+ or  D-.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.R","title":"<code>R</code>  <code>property</code>","text":"<p>Get range of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.agreement","title":"<code>agreement</code>  <code>property</code> <code>writable</code>","text":"<p>Get the agreement multiplier for the \u03c3 (standard deviation)  used in calculating Cp and Cpk values.</p> <p>The agreement is defined as twice the coverage factor <code>k</code>.  Setting this value will reset the Cp and Cpk values to None,  reflecting that the underlying uncertainty parameters have  changed.</p> <p>When setting the agreement using a percentile, provide the  acceptable proportion for the spread, such as 0.9973,  which corresponds to approximately 6\u03c3 (six standard deviations). The agreement value must be specified as either: - A percentage (0.0 &lt; agreement &lt;= 1.0) indicating the   acceptable proportion for the spread. - A multiple of the standard deviation (agreement &gt;= 1).</p> <p>Special Case: - If the agreement is set to 1 (indicating a standard deviation    multiplier), enter it as an integer (1).  - For percentiles or a broader range, use a floating-point    representation (e.g., 1.0) or <code>float('inf')</code> for an infinite   range.</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the provided agreement value is not in the valid range  (0.0 &lt; agreement &lt;= 1.0 for percentiles or agreement &gt;= 1  for standard deviation multipliers).</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.aic","title":"<code>aic</code>  <code>property</code>","text":"<p>Get the Akaike information criterion (AIC) (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.attrs_describe","title":"<code>attrs_describe</code>  <code>property</code>","text":"<p>Get attribute names used for <code>describe</code> method.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.bic","title":"<code>bic</code>  <code>property</code>","text":"<p>Get the Bayesian information criterion (BIC) (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.dist","title":"<code>dist</code>  <code>property</code> <code>writable</code>","text":"<p>This is the generic continuous distribution class of the  provided or evaluated distribution.</p> <p>Set the distribution to be used for estimation. If a string  is provided, it will be converted to a continuous distribution  class using <code>ensure_generic</code>. If None, the distribution will be  estimated from the samples.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.dist_name","title":"<code>dist_name</code>  <code>property</code>","text":"<p>Get the name of the estimated distribution (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.dof","title":"<code>dof</code>  <code>property</code>","text":"<p>Get degree of freedom for filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.excess","title":"<code>excess</code>  <code>property</code>","text":"<p>Get the Fisher kurtosis (excess) of filtered samples. Calculations are corrected for statistical bias (read-only). The curvature of the distribution corresponds to the  curvature of a normal distribution when the excess is close to  zero. Distributions with negative excess kurtosis are said to be  platykurtic, this distribution produces fewer and/or less  extreme outliers than the normal distribution (e.g. the uniform  distribution has no outliers). Distributions with a positive  excess kurtosis are said to be leptokurtic (e.g. the Laplace  distribution, which has tails that asymptotically approach zero  more slowly than a Gaussian, and therefore produces more  outliers than the normal distribution):     - excess &lt; 0: less extreme outliers than normal distribution     - excess &gt; 0: more extreme outliers than normal distribution</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.filtered","title":"<code>filtered</code>  <code>property</code>","text":"<p>Get the samples without error values and no missing value  (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.frozen","title":"<code>frozen</code>  <code>property</code>","text":"<p>This is the frozen continuous RV object of dist property  (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.k","title":"<code>k</code>  <code>property</code>","text":"<p>Get the coverage factor <code>k</code> used in uncertainty  calculations (read-only).</p> <p>This property returns the coverage factor, which is a multiplier  used to determine the expanded uncertainty based on the standard  uncertainty. The value of <code>k</code> is typically set to reflect the  desired confidence level in the measurement results.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.lcl","title":"<code>lcl</code>  <code>property</code>","text":"<p>Get lower control limit according to given strategy and  agreement (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Get the <code>loc</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.log_likelihood","title":"<code>log_likelihood</code>  <code>property</code>","text":"<p>Get the log-likelihood of the provided or evaluated  distribution (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.max","title":"<code>max</code>  <code>property</code>","text":"<p>Get the maximum value of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.mean","title":"<code>mean</code>  <code>property</code>","text":"<p>Get mean of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.median","title":"<code>median</code>  <code>property</code>","text":"<p>Get median of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.min","title":"<code>min</code>  <code>property</code>","text":"<p>Get the minimum value of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.n_filtered","title":"<code>n_filtered</code>  <code>property</code>","text":"<p>Get sample size of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.n_missing","title":"<code>n_missing</code>  <code>property</code>","text":"<p>Get amount of missing values (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Get sample size of unfiltered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.nan_policy","title":"<code>nan_policy</code>  <code>property</code>","text":"<p>How to handle NaN values in the samples (read-only).  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.p_ad","title":"<code>p_ad</code>  <code>property</code>","text":"<p>Get the probability that the filtered samples are subject of the normal distribution by performing a Anderson-Darling test (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.p_excess","title":"<code>p_excess</code>  <code>property</code>","text":"<p>Get the probability that the excess of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.p_ks","title":"<code>p_ks</code>  <code>property</code>","text":"<p>Get the two-tailed p-value of kolmogorov-smirnof test for  the provided or fitted  distribution. A higher p-value indicates  a better fit to the data (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.p_skew","title":"<code>p_skew</code>  <code>property</code>","text":"<p>Get the probability that the skewness of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.possible_dists","title":"<code>possible_dists = possible_dists</code>  <code>instance-attribute</code>","text":"<p>Distributions given during initialization to which the data may  be subject.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.predicted","title":"<code>predicted</code>  <code>property</code>","text":"<p>Get the predicted values of the provided or evaluated  distribution by using the order statistic medians (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.q_low","title":"<code>q_low</code>  <code>property</code>","text":"<p>Get quantil for lower control limit according to given  agreement. If the samples is subject to normal distribution and  the agreement is given as 6, this value corresponds to the  0.135 % quantile: 6 \u03c3 ~ 99.73 % of the samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.q_upp","title":"<code>q_upp</code>  <code>property</code>","text":"<p>Get quantil for upper control limit according to given  agreement. If the sample data is subject to normal distribution  and the agreement is given as 6, this value corresponds to the  Q_0.99865: 0.99865-quantile or 99.865-percentile (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.sample_percentiles","title":"<code>sample_percentiles</code>  <code>property</code>","text":"<p>Get the empirical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.sample_quantiles","title":"<code>sample_quantiles</code>  <code>property</code>","text":"<p>Get the sample quantiles (sorted filtered samples) (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.samples","title":"<code>samples</code>  <code>property</code>","text":"<p>Get the raw samples as it was given during instantiation as pandas Series (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Get the <code>scale</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.sem","title":"<code>sem</code>  <code>property</code>","text":"<p>Get standard error mean of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.shape_params","title":"<code>shape_params</code>  <code>property</code>","text":"<p>Estimates for any distribution shape parameters (if  applicable), followed by those for location and scale. For most  random variables, shape statistics will be returned, but there  are exceptions (e.g. norm). Can be used to generate values with  the help of the dist attribute (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.skew","title":"<code>skew</code>  <code>property</code>","text":"<p>Get the skewness of the filtered samples (read-only). Calculations are corrected for statistical bias. For normally distributed data, the skewness should be about zero.  For unimodal continuous distributions, a skewness value greater  than zero means that there is more weight in the right tail of  the distribution:     - skew &lt; 0: left-skewed -&gt; long tail left     - skew &gt; 0: right-skewed -&gt; long tail right</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.sorted","title":"<code>sorted</code>  <code>property</code>","text":"<p>Get the filtered samples sorted by value with new index (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.ss","title":"<code>ss</code>  <code>property</code>","text":"<p>Get the sum of squared residuals (SS) using the sorted values and the predicted values (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.std","title":"<code>std</code>  <code>property</code>","text":"<p>Get standard deviation of filtered samples (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.strategy","title":"<code>strategy</code>  <code>property</code> <code>writable</code>","text":"<p>Strategy used to determine the control limits. The control  limits can also be interpreted as the process range.</p> <p>Set strategy as one of {'eval', 'fit', 'norm', 'data'}     - eval: If no evaluate function is given, the strategy is      determined according to the internal evaluate method.      - fit: First, the distribution is searched for that best      represents the process data and then the process variation      tolerance is calculated     - norm: it is assumed that the data is subject to normal      distribution. The variation tolerance is then calculated as      agreement * standard deviation     - data: The quantiles for the process variation tolerance      are read directly from the samples.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.theoretical_percentiles","title":"<code>theoretical_percentiles</code>  <code>property</code>","text":"<p>Get the theoretical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.theoretical_quantiles","title":"<code>theoretical_quantiles</code>  <code>property</code>","text":"<p>Get the theoretical quantiles (osm, or order statistic  medians) of the filtered samples. This quantiles are calculated the same way as in <code>scipy.stats.probplot()</code> function  (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.ucl","title":"<code>ucl</code>  <code>property</code>","text":"<p>Get upper control limit according to given strategy and  agreement (read-only).</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.describe","title":"<code>describe(exclude=(), colname=None)</code>","text":"<p>Generate descriptive statistics.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Attributes to exclude from the summary statistics, by default ()</p> </li> <li> <code>colname</code>               (<code>str | Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Column name for the resulting DataFrame, by default None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stats</code> (              <code>DataFrame</code> )          \u2013            <p>Summary statistics as pandas DataFrame. The indices of the DataFrame are the attributes that have been computed and the column name is the name of the samples.</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.distribution","title":"<code>distribution()</code>","text":"<p>Estimate the distribution by selecting the one from the provided distributions that best reflects the filtered data.</p> <p>Returns:</p> <ul> <li> <code>dist</code> (              <code>scipy.stats rv_continuous</code> )          \u2013            <p>A generic continous distribution class of best fit</p> </li> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The two-tailed p-value for the best fit</p> </li> <li> <code>shape_params</code> (              <code>Tuple[float, ...]</code> )          \u2013            <p>Estimates for any shape parameters (if applicable), followed by those for location and scale. For most random variables, shape statistics will be returned, but there are exceptions (e.g. norm). Can be used to generate values with the help of returned dist</p> </li> </ul> Notes <p>First, the p-score is calculated by performing a  Kolmogorov-Smirnov test to determine how well each distribution  fits the samples. Whatever has the highest P-score is considered the most accurate. This is because a higher p-score means the  hypothesis is closest to reality.</p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate strategy to calculate control limits. If no evaluate function is given the strategy is evaluated as follows:</p> <ol> <li>If variance is not stable within the samples -&gt; strategy = 'data'</li> <li>If variance and mean is stable and samples follow a normal  curve -&gt; strategy = 'norm'</li> <li>If variance and mean is stable but samples don't follow a normal curve -&gt; strategy = 'fit'</li> <li>If variance is stable but mean not and samples follow a  normal curve -&gt; strategy = 'norm'</li> <li>If variance is stable but mean not and samples don't follow a  normal curve -&gt; strategy = 'data'</li> </ol> <p>Returns:</p> <ul> <li> <code>strategy</code> (              <code>{fit, norm, data}</code> )          \u2013            <p>Evaluated strategy to calculate control limits</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.follows_norm_curve","title":"<code>follows_norm_curve(alpha=0.05, excess_test=True, skew_test=True, ad_test=False)</code>","text":"<p>Checks whether the sample data is subject to normal  distribution by performing one or more of the following tests  (depending on the input): - Skewness test - Bulge test - Anderson-Darling test</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>skew_test</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, an skew test will also be carried out, by default  True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an excess test will also be carried out, by default True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an Anderson Darling test will also be carried out, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>remain_h0</code> (              <code>bool</code> )          \u2013            <p>True if all p-values of the tests performed are greater than  alpha, otherwise False</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If all flags are False.</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.mask_missing","title":"<code>mask_missing()</code>","text":"<p>Returns a boolean mask indicating which samples are missing  (NaN).</p> <p>This mask can be used to filter or analyze entries in the  <code>samples</code> attribute that contain missing values.</p> <p>Returns:</p> <ul> <li> <code>Series[bool]:</code>           \u2013            <p>A boolean Series where True indicates a missing sample.</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.mask_ok","title":"<code>mask_ok()</code>","text":"<p>Returns a boolean mask indicating which samples are valid  (OK).</p> <p>A sample is considered OK if it is: - Not missing (i.e., not NaN)</p> <p>Returns:</p> <ul> <li> <code>Series[bool]</code>           \u2013            <p>A boolean Series where True indicates a valid sample.</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.mean_ci","title":"<code>mean_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for mean of filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.median_ci","title":"<code>median_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for median of filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.plotting_positions","title":"<code>plotting_positions(nobs, alpha=0.0, beta=None)</code>  <code>staticmethod</code>","text":"<p>Generates sequence of plotting positions</p> <p>Parameters:</p> <ul> <li> <code>nobs</code>               (<code>int</code>)           \u2013            <p>Number of probability points to plot</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>alpha parameter for the plotting position of an expected order statistic</p> </li> <li> <code>beta</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>beta parameter for the plotting position of an expected order statistic. If None, then beta is set to alpha.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The plotting positions</p> </li> </ul> Notes <p>The plotting positions are given by </p> \\[ i \\in [1, nobs]) \\] \\[ \\frac{(i - \\alpha)}{nobs + 1 - \\alpha - \\beta} \\] <p>Additional information on alpha and beta see: <code>scipy.stats.mstats.plotting_positions</code></p>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.stable_mean","title":"<code>stable_mean(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the mean remains stable across the samples. </p> <p>The sample data is divided into subgroups and the mean of their  sections are checked using the F test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.stable_variance","title":"<code>stable_variance(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the variance remains stable across the samples. </p> <p>The sample data is divided into subgroups and the variances of their sections are checked using the Levene test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.stdev_ci","title":"<code>stdev_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for standard deviation of  filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/location-dispersion-estimator/#daspi.statistics.estimation.LocationDispersionEstimator.z_transform","title":"<code>z_transform(x)</code>","text":"<p>Transform value to z-score.</p> <p>This method produces a value from a distribution with a mean of  0 and a standard deviation of 1. The value indicates how many standard deviations the value is from the mean.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>value to be transformed</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>z</code> (              <code>float</code> )          \u2013            <p>z-score</p> </li> </ul>"},{"location":"statistics/estimation/loess/","title":"Loess","text":""},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess","title":"<code>daspi.statistics.estimation.Loess</code>","text":"<p>Smooth the data using Locally Estimated Scatterplot Smoothing  (LOESS).</p> <p>LOESS is not necessarily suitable for all regression models due to  its non-parametric approach and high computational intensity.  Nonetheless, it serves as an effective method for modeling the  relationship between two variables that do not adhere to a  predefined distribution and exhibit a non-linear relationship.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>pandas DataFrame</code>)           \u2013            <p>Pandas long format DataFrame containing the data source for the plot.</p> </li> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Column name of the target variable for the plot.</p> </li> <li> <code>feature</code>               (<code>str</code>)           \u2013            <p>Column name of the feature variable for the plot, by default ''</p> </li> <li> <code>fit_at_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to fit the model at initialization, by default True</p> </li> <li> <code>**kwds</code>           \u2013            <p>Keyword arguments for the <code>fit</code> method. Is only taken into  account if <code>fit_at_init</code> is True.</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nimport daspi as dsp\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = 5*np.random.random(100)\ndata = pd.DataFrame(dict(\n    x = x,\n    y = np.sin(x) * 3*np.exp(-x) + np.random.normal(0, 0.2, 100)))\nmodel = dsp.Loess(data, 'y', 'x')\nsequence, prediction, lower, upper = model.fitted_line(0.95)\n\nfig, ax = plt.subplots()\nax.scatter(data.x, data.y)\nax.plot(sequence, prediction)\nax.fill_between(sequence, lower, upper, alpha=0.2)\n</code></pre> Sources <p>[1] James Brennan (2020), Confidence intervals for LOWESS models in  python https://james-brennan.github.io</p> <p>[2] Soul Dobilas (2020), LOWESS Regression in Python: How to  Discover Clear Patterns in Your Data?,  Towards Data Science</p> <p>[3] Btyner (2006), Local Regression Wikipedia</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.available_kernels","title":"<code>available_kernels</code>  <code>property</code>","text":"<p>Available kernels for smoothing (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.dof_resid","title":"<code>dof_resid</code>  <code>property</code>","text":"<p>Degree of freedom of residuals (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":"<p>The column name of the feature variable.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.fitted","title":"<code>fitted</code>  <code>property</code>","text":"<p>True if the data has been fitted (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.fraction","title":"<code>fraction</code>  <code>instance-attribute</code>","text":"<p>The fraction of data points used in each local regression.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.kernel","title":"<code>kernel</code>  <code>instance-attribute</code>","text":"<p>The kernel for weights function used in the LOESS smoothing.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Amount of samples in source after removing missing values (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.order","title":"<code>order</code>  <code>instance-attribute</code>","text":"<p>The order of local regression:</p> <ul> <li>0: No smoothing (interpolation)</li> <li>1: Linear regression</li> <li>2: Quadratic regression</li> <li>3: Cubic regression</li> </ul> <p>The order determines the degree of the polynomial used in the local  regression, affecting the flexibility of the fitted curve. High-degree polynomials would tend to overfit the data in each  subset and are numerically unstable, making accurate computations  difficult.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.residuals","title":"<code>residuals</code>  <code>property</code>","text":"<p>Residuals as difference between target and lowess (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.smoothed","title":"<code>smoothed</code>  <code>instance-attribute</code>","text":"<p>Smoothed target data as a pandas Series.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The data source for the plot</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.std_errors","title":"<code>std_errors</code>  <code>instance-attribute</code>","text":"<p>Standard errors of the smoothed target data as a pandas Series.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The column name of the target variable.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.x","title":"<code>x</code>  <code>property</code>","text":"<p>The feature variable as exogenous variable (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.y","title":"<code>y</code>  <code>property</code>","text":"<p>The target variable as endogenous variable (read-only).</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.bandwidth","title":"<code>bandwidth(fraction)</code>","text":"<p>Get the bandwidth parameter that determines the locality of  the smoothing. It controls how far from the target point the  weights will be considered. A larger bandwidth results in  smoother fits, while a smaller bandwidth allows for more local  variation to be captured in the fitted curve.</p>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.fit","title":"<code>fit(fraction=0.6, order=3, kernel='tricube')</code>","text":"<p>Fits the model using the <code>statsmodels.nonparametric.lowess</code>  method.</p> <p>Parameters:</p> <ul> <li> <code>fraction</code>               (<code>float</code>, default:                   <code>0.6</code> )           \u2013            <p>The fraction of the data used for each local regression. A  good value to start with is &gt; 1/2 (default value of  statsmodels is 2/3). Reduce the value to avoid underfitting.  A value below 0.2 usually leads to overfitting exept for  gaussian weights. Default is 0.6</p> </li> <li> <code>order</code>               (<code>Literal[0, 1, 2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The order of the local regression to be fitted.  This determines the degree of the polynomial used in the  local regression: - 0: No smoothing (interpolation) - 1: Linear regression - 2: Quadratic regression - 3: Cubic regression Default is 3.</p> </li> <li> <code>kernel</code>               (<code>Literal['tricube', 'gaussian', 'epanechnikov']</code>, default:                   <code>'tricube'</code> )           \u2013            <p>The kernel function used to calculate the weights.  Available kernels are: - 'tricube': Tricube kernel function - 'gaussian': Gaussian kernel function - 'epanechnikov': Epanechnikov kernel function Default is 'tricube'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lowess</code> (              <code>Self</code> )          \u2013            <p>The instance of the Lowess with the fitted values.</p> </li> </ul> Notes <p>If using this method it's possible to run in a LinAlgError. This error usually happens in two main scenarios:</p> <ol> <li> <p>Singular Matrix:      When the input data creates a singular matrix      (determinant = 0). This often occurs when:</p> <ul> <li>You have perfectly correlated features</li> <li>You have duplicate data points</li> <li>There's not enough variation in your data</li> </ul> </li> <li> <p>Ill-Conditioned Matrix:     When the matrix is nearly singular. Common causes:</p> <ul> <li>Features with very different scales</li> <li>Multicollinearity between features</li> </ul> </li> </ol>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.fitted_line","title":"<code>fitted_line(confidence_level=None, n_points=DEFAULT.LOWESS_SEQUENCE_LEN)</code>","text":"<pre><code>fitted_line() -&gt; Tuple[NDArray, NDArray]\n</code></pre><pre><code>fitted_line(confidence_level: None, n_points: int = ...) -&gt; Tuple[NDArray, NDArray]\n</code></pre><pre><code>fitted_line(confidence_level: float, n_points: int = ...) -&gt; Tuple[NDArray, NDArray, NDArray, NDArray]\n</code></pre> <p>Generate a smooth sequence of predictions from the fitted  LOWESS model.</p> <p>This method creates an evenly spaced sequence of feature values  and predicts their corresponding target values using linear  interpolation. It's particularly useful for: 1. Plotting smooth trend lines 2. Visualizing the LOWESS fit 3. Generating continuous predictions across the feature range</p> <p>Parameters:</p> <ul> <li> <code>confidence_level</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, calculate confidence bands at this level  (0 to 1). Example: 0.95 for 95% confidence bands. If None, no  confidence bands are calculated. Default is None.</p> </li> <li> <code>n_points</code>               (<code>int</code>, default:                   <code>LOWESS_SEQUENCE_LEN</code> )           \u2013            <p>Number of points to generate in the sequence. More points  create a smoother visualization but increase computation  time. Default is defined in DEFAULT.LOWESS_SEQUENCE_LEN.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>sequence</code> (              <code>NDArray</code> )          \u2013            <p>Evenly spaced feature values</p> </li> <li> <code>prediction</code> (              <code>NDArray</code> )          \u2013            <p>Predicted target values</p> </li> <li> <code>lower_band</code> (              <code>(NDArray, optional)</code> )          \u2013            <p>Lower confidence band. Only returned if confidence_level is  provided</p> </li> <li> <code>upper_band</code> (              <code>(NDArray, optional)</code> )          \u2013            <p>Upper confidence band. Only returned if confidence_level is  provided</p> </li> </ul>"},{"location":"statistics/estimation/loess/#daspi.statistics.estimation.Loess.predict","title":"<code>predict(x, kind='linear')</code>","text":"<p>Predict the target value(s) for the given feature value(s).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>int | float | NumericSample1D</code>)           \u2013            <p>The feature value(s) for which to predict the target  value(s).</p> </li> <li> <code>kind</code>               (<code>str or int</code>, default:                   <code>'linear'</code> )           \u2013            <p>Specifies the kind of interpolation as a string or as an  integer specifying the order of the spline interpolator to  use. The string has to be one of 'linear', 'nearest',  'nearest-up', 'zero', 'slinear', 'quadratic', 'cubic',  'previous', or 'next'. - 'zero', 'slinear', 'quadratic' and 'cubic': refer to a    spline interpolation of zeroth, first, second or third    order. - 'previous' and 'next': simply return the previous or    next value of the point - 'nearest-up' and 'nearest': differ when interpolating  half-integers (e.g. 0.5, 1.5) in that 'nearest-up' rounds up  and 'nearest' rounds down. Default is 'linear'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>The predicted target value(s) for the given feature value(s) as one-dimensonal numpy array.</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/","title":"Process estimator","text":""},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator","title":"<code>daspi.statistics.estimation.ProcessEstimator</code>","text":"<p>               Bases: <code>LocationDispersionEstimator</code></p> <p>An object for various statistical estimators. This class extends  the estimator with process-specific statistics such as specification limits, Cp and Cpk values.</p> <p>The attributes are calculated lazily. After the class is instantiated, all attributes are set to None. As soon as an attribute (actually Property) is called, the value is calculated and stored so that the calculation is only performed once.</p> <p>Parameters:</p> <ul> <li> <code>samples</code>               (<code>NumericSample1D</code>)           \u2013            <p>1D array of process data.</p> </li> <li> <code>spec_limits</code>               (<code>SpecLimits</code>)           \u2013            <p>Specification limits for process data.</p> </li> <li> <code>error_values</code>               (<code>tuple of float</code>, default:                   <code>()</code> )           \u2013            <p>If the process data may contain coded values for measurement  errors or similar, they can be specified here,  by default [].</p> </li> <li> <code>strategy</code>               (<code>(eval, fit, norm, data)</code>, default:                   <code>'eval'</code> )           \u2013            <p>Which strategy should be used to determine the control  limits (process spread): - <code>eval</code>: The strategy is determined according to the given  evaluate function. If none is given, the internal <code>evaluate</code> method is used. - <code>fit</code>: First, the distribution that best represents the  process data is searched for and then the agreed process  spread is calculated - norm: it is assumed that the data is subject to normal  distribution. The variation tolerance is then calculated as  agreement * standard deviation - data: The quantiles for the process variation tolerance  are read directly from the data. by default 'norm'</p> </li> <li> <code>agreement</code>               (<code>float or int</code>, default:                   <code>6</code> )           \u2013            <p>Specify the tolerated process variation for which the  control limits are to be calculated.  - If int, the spread is determined using the normal  distribution agreement\u03c3,  e.g. agreement = 6 -&gt; 6\u03c3 ~ covers 99.75 % of the data.  The upper and lower permissible quantiles are then  calculated from this. - If float, the value must be between 0 and 1.This value is then interpreted as the acceptable proportion for the  spread, e.g. 0.9973 (which corresponds to ~ 6 \u03c3) by default 6</p> </li> <li> <code>possible_dists</code>               (<code>tuple of strings or rv_continous</code>, default:                   <code>COMMON</code> )           \u2013            <p>Distributions to which the data may be subject. Only  continuous distributions of scipy.stats are allowed, by default DIST.COMMON</p> </li> <li> <code>evaluate</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Provide a function that evaluates the <code>strategy</code>. If <code>strategy</code> is set to 'eval', this function is used to determine the strategy. The function should take the <code>samples</code> as input and return a string that corresponds to a valid strategy 'fit', 'norm', or 'data'. If not provided, the internal <code>evaluate</code> method is used. For more information on the <code>evaluate</code> method, see the class documentation. Default is None.</p> </li> <li> <code>nan_policy</code>               (<code>(propagate, 'raise', omit)</code>, default:                   <code>'propagate'</code> )           \u2013            <p>How to handle NaN values in the samples.  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis, default is 'omit'.</p> </li> </ul> <p>Examples:</p> <p>You can get a comprehensive analysis of your process using the  <code>describe()</code> method, which returns a <code>pandas.DataFrame</code>. This  contains all important metrics, such as the Cp (if possible) and  Cpk values:</p> <pre><code>import daspi as dsp\n\ndf = dsp.load_dataset('drop_card')\nspec_limits = dsp.SpecLimits(0, float(df.loc[0, 'usl']))\ntarget = 'distance'\n\ndrop_process = dsp.ProcessEstimator(\n    samples=df[target],\n    spec_limits=spec_limits)\nprint(drop_process.describe())\n</code></pre> <p>However, in this dataset, the cards were dropped in two different  ways. To compare both methods, a DataFrame containing both process  analyses can be created as follows:</p> <pre><code>method_mapping = {0: 'parallel', 1: 'perpendicular'}\nsamples_parallel = df[df['method']==method_mapping[0]][target]\nsamples_series = df[df['method']==method_mapping[1]][target]\n\ndrop_analysis = pd.concat([\n    dsp.ProcessEstimator(samples_parallel, spec_limits).describe(),\n    dsp.ProcessEstimator(samples_series, spec_limits).describe()],\n    axis=1,\n    ignore_index=True,\n).rename(\n    columns=method_mapping\n)\nprint(drop_analysis)\n</code></pre> <p>You can get a detailed visual analysis with the precast chart  <code>daspi.plotlib.precast.ProcessCapabilityAnalysisCharts</code></p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set to  'raise'.</p> </li> <li> <code>UserWarning</code>             \u2013            <p>If NaN values are found in the samples and <code>nan_policy</code> is set  to 'omit' or 'propagate'. The warning indicates that NaN values  will be omitted from the analysis or may lead to unexpected  results.</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.D","title":"<code>D</code>  <code>property</code>","text":"<p>Get the Kolmogorov-Smirnov test statistic, either D, D+ or  D-.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.R","title":"<code>R</code>  <code>property</code>","text":"<p>Get range of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.Z","title":"<code>Z</code>  <code>property</code>","text":"<p>The Sigma level Z is another process capability indicator  alongside cp and cpk. It describes how many standard deviations  can be placed between the mean value and the nearest tolerance  limit of a process.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.Z_lt","title":"<code>Z_lt</code>  <code>property</code>","text":"<p>Statements about long-term capabilities can be derived from  short-term capabilities using the \u03c3 level. The empirically  determined value of 1.5 is subtracted from the \u03c3 level.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.agreement","title":"<code>agreement</code>  <code>property</code> <code>writable</code>","text":"<p>Get the agreement multiplier for the \u03c3 (standard deviation)  used in calculating Cp and Cpk values.</p> <p>The agreement is defined as twice the coverage factor <code>k</code>.  Setting this value will reset the Cp and Cpk values to None,  reflecting that the underlying uncertainty parameters have  changed.</p> <p>When setting the agreement using a percentile, provide the  acceptable proportion for the spread, such as 0.9973,  which corresponds to approximately 6\u03c3 (six standard deviations). The agreement value must be specified as either: - A percentage (0.0 &lt; agreement &lt;= 1.0) indicating the   acceptable proportion for the spread. - A multiple of the standard deviation (agreement &gt;= 1).</p> <p>Special Case: - If the agreement is set to 1 (indicating a standard deviation    multiplier), enter it as an integer (1).  - For percentiles or a broader range, use a floating-point    representation (e.g., 1.0) or <code>float('inf')</code> for an infinite   range.</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the provided agreement value is not in the valid range  (0.0 &lt; agreement &lt;= 1.0 for percentiles or agreement &gt;= 1  for standard deviation multipliers).</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.aic","title":"<code>aic</code>  <code>property</code>","text":"<p>Get the Akaike information criterion (AIC) (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.attrs_describe","title":"<code>attrs_describe</code>  <code>property</code>","text":"<p>Get attribute names used for <code>describe</code> method (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.bic","title":"<code>bic</code>  <code>property</code>","text":"<p>Get the Bayesian information criterion (BIC) (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.control_limits","title":"<code>control_limits</code>  <code>property</code>","text":"<p>Get lower and upper control limits (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.control_range","title":"<code>control_range</code>  <code>property</code>","text":"<p>Get the range (span) of the control limits (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.cp","title":"<code>cp</code>  <code>property</code>","text":"<p>Cp is a measure of process capability. Cp is the ratio of the  specification width (usl - lsl) to the process variation  (agreement*\u03c3). The location is not taken into account by the  Cp value. This value therefore only indicates the potential for  the Cpk value. This value cannot be calculated unless an upper and lower  specification limit is given. In this case, None is returned.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.cpk","title":"<code>cpk</code>  <code>property</code>","text":"<p>Estimates what the process is capable of producing,  considering  that the process mean may not be centered between  the specification limits. It's calculated as the minimum of Cpl and Cpu. In general, higher Cpk values indicate a more capable process.  Lower Cpk values indicate that the process may need improvement.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.cpl","title":"<code>cpl</code>  <code>property</code>","text":"<p>Cpl is a measure of process capability. It is the ratio  of the distance between the process mean and the lower  specification limit and the lower spread of the process. Returns inf if no lower specification limit is specified.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.cpu","title":"<code>cpu</code>  <code>property</code>","text":"<p>Cpu is a measure of process capability. It is the ratio  of the distance between the process mean and the upper  specification limit and the upper spread of the process. Returns inf if no upper specification limit is specified.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.dist","title":"<code>dist</code>  <code>property</code> <code>writable</code>","text":"<p>This is the generic continuous distribution class of the  provided or evaluated distribution.</p> <p>Set the distribution to be used for estimation. If a string  is provided, it will be converted to a continuous distribution  class using <code>ensure_generic</code>. If None, the distribution will be  estimated from the samples.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.dist_name","title":"<code>dist_name</code>  <code>property</code>","text":"<p>Get the name of the estimated distribution (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.dof","title":"<code>dof</code>  <code>property</code>","text":"<p>Get degree of freedom for filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.errors","title":"<code>errors</code>  <code>property</code>","text":"<p>Get the amount of error values (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.excess","title":"<code>excess</code>  <code>property</code>","text":"<p>Get the Fisher kurtosis (excess) of filtered samples. Calculations are corrected for statistical bias (read-only). The curvature of the distribution corresponds to the  curvature of a normal distribution when the excess is close to  zero. Distributions with negative excess kurtosis are said to be  platykurtic, this distribution produces fewer and/or less  extreme outliers than the normal distribution (e.g. the uniform  distribution has no outliers). Distributions with a positive  excess kurtosis are said to be leptokurtic (e.g. the Laplace  distribution, which has tails that asymptotically approach zero  more slowly than a Gaussian, and therefore produces more  outliers than the normal distribution):     - excess &lt; 0: less extreme outliers than normal distribution     - excess &gt; 0: more extreme outliers than normal distribution</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.filtered","title":"<code>filtered</code>  <code>property</code>","text":"<p>Get the data without error values and no missing value (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.frozen","title":"<code>frozen</code>  <code>property</code>","text":"<p>This is the frozen continuous RV object of dist property  (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.k","title":"<code>k</code>  <code>property</code>","text":"<p>Get the coverage factor <code>k</code> used in uncertainty  calculations (read-only).</p> <p>This property returns the coverage factor, which is a multiplier  used to determine the expanded uncertainty based on the standard  uncertainty. The value of <code>k</code> is typically set to reflect the  desired confidence level in the measurement results.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.lcl","title":"<code>lcl</code>  <code>property</code>","text":"<p>Get lower control limit according to given strategy and  agreement (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Get the <code>loc</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.log_likelihood","title":"<code>log_likelihood</code>  <code>property</code>","text":"<p>Get the log-likelihood of the provided or evaluated  distribution (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.lsl","title":"<code>lsl</code>  <code>property</code>","text":"<p>Get the lower specification limit (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.max","title":"<code>max</code>  <code>property</code>","text":"<p>Get the maximum value of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.mean","title":"<code>mean</code>  <code>property</code>","text":"<p>Get mean of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.median","title":"<code>median</code>  <code>property</code>","text":"<p>Get median of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.min","title":"<code>min</code>  <code>property</code>","text":"<p>Get the minimum value of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.n_errors","title":"<code>n_errors</code>  <code>property</code>","text":"<p>Get amount of error values (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.n_filtered","title":"<code>n_filtered</code>  <code>property</code>","text":"<p>Get sample size of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.n_missing","title":"<code>n_missing</code>  <code>property</code>","text":"<p>Get amount of missing values (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.n_nok","title":"<code>n_nok</code>  <code>property</code>","text":"<p>Get amount of NOK-values (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.n_ok","title":"<code>n_ok</code>  <code>property</code>","text":"<p>Get amount of OK-values (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Get sample size of unfiltered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.nan_policy","title":"<code>nan_policy</code>  <code>property</code>","text":"<p>How to handle NaN values in the samples (read-only).  - 'propagate': NaN values are preserved in the analysis. - 'raise': Raises an error if NaN values are found. - 'omit': Omits NaN values from the analysis</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.nok","title":"<code>nok</code>  <code>property</code>","text":"<p>Get amount of NOK-values as percent (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.nok_fit","title":"<code>nok_fit</code>  <code>property</code>","text":"<p>Predict the amount NOK-values as percent based on the  fitted distribution (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.nok_norm","title":"<code>nok_norm</code>  <code>property</code>","text":"<p>Predict the amount NOK-values as percent based on the  norm distribution (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.ok","title":"<code>ok</code>  <code>property</code>","text":"<p>Get amount of OK-values as percent (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.p_ad","title":"<code>p_ad</code>  <code>property</code>","text":"<p>Get the probability that the filtered samples are subject of the normal distribution by performing a Anderson-Darling test (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.p_excess","title":"<code>p_excess</code>  <code>property</code>","text":"<p>Get the probability that the excess of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.p_ks","title":"<code>p_ks</code>  <code>property</code>","text":"<p>Get the two-tailed p-value of kolmogorov-smirnof test for  the provided or fitted  distribution. A higher p-value indicates  a better fit to the data (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.p_skew","title":"<code>p_skew</code>  <code>property</code>","text":"<p>Get the probability that the skewness of the population that the sample was drawn from is the same as that of a corresponding normal distribution (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.possible_dists","title":"<code>possible_dists = possible_dists</code>  <code>instance-attribute</code>","text":"<p>Distributions given during initialization to which the data may  be subject.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.predicted","title":"<code>predicted</code>  <code>property</code>","text":"<p>Get the predicted values of the provided or evaluated  distribution by using the order statistic medians (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.q_low","title":"<code>q_low</code>  <code>property</code>","text":"<p>Get quantil for lower control limit according to given  agreement. If the samples is subject to normal distribution and  the agreement is given as 6, this value corresponds to the  0.135 % quantile: 6 \u03c3 ~ 99.73 % of the samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.q_upp","title":"<code>q_upp</code>  <code>property</code>","text":"<p>Get quantil for upper control limit according to given  agreement. If the sample data is subject to normal distribution  and the agreement is given as 6, this value corresponds to the  Q_0.99865: 0.99865-quantile or 99.865-percentile (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.sample_percentiles","title":"<code>sample_percentiles</code>  <code>property</code>","text":"<p>Get the empirical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.sample_quantiles","title":"<code>sample_quantiles</code>  <code>property</code>","text":"<p>Get the sample quantiles (sorted filtered samples) (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.samples","title":"<code>samples</code>  <code>property</code>","text":"<p>Get the raw samples as it was given during instantiation as pandas Series (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Get the <code>scale</code> paramter from <code>shape_params</code> (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.sem","title":"<code>sem</code>  <code>property</code>","text":"<p>Get standard error mean of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.shape_params","title":"<code>shape_params</code>  <code>property</code>","text":"<p>Estimates for any distribution shape parameters (if  applicable), followed by those for location and scale. For most  random variables, shape statistics will be returned, but there  are exceptions (e.g. norm). Can be used to generate values with  the help of the dist attribute (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.skew","title":"<code>skew</code>  <code>property</code>","text":"<p>Get the skewness of the filtered samples (read-only). Calculations are corrected for statistical bias. For normally distributed data, the skewness should be about zero.  For unimodal continuous distributions, a skewness value greater  than zero means that there is more weight in the right tail of  the distribution:     - skew &lt; 0: left-skewed -&gt; long tail left     - skew &gt; 0: right-skewed -&gt; long tail right</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.sorted","title":"<code>sorted</code>  <code>property</code>","text":"<p>Get the filtered samples sorted by value with new index (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.spec_limits","title":"<code>spec_limits</code>  <code>property</code> <code>writable</code>","text":"<p>Get and set the specification limits.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.ss","title":"<code>ss</code>  <code>property</code>","text":"<p>Get the sum of squared residuals (SS) using the sorted values and the predicted values (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.std","title":"<code>std</code>  <code>property</code>","text":"<p>Get standard deviation of filtered samples (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.strategy","title":"<code>strategy</code>  <code>property</code> <code>writable</code>","text":"<p>Strategy used to determine the control limits. The control  limits can also be interpreted as the process range.</p> <p>Set strategy as one of {'eval', 'fit', 'norm', 'data'}     - eval: If no evaluate function is given, the strategy is      determined according to the internal evaluate method.      - fit: First, the distribution is searched for that best      represents the process data and then the process variation      tolerance is calculated     - norm: it is assumed that the data is subject to normal      distribution. The variation tolerance is then calculated as      agreement * standard deviation     - data: The quantiles for the process variation tolerance      are read directly from the samples.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.theoretical_percentiles","title":"<code>theoretical_percentiles</code>  <code>property</code>","text":"<p>Get the theoretical percentiles (CDF values) of the sample data (read-only)</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.theoretical_quantiles","title":"<code>theoretical_quantiles</code>  <code>property</code>","text":"<p>Get the theoretical quantiles (osm, or order statistic  medians) of the filtered samples. This quantiles are calculated the same way as in <code>scipy.stats.probplot()</code> function  (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.tolerance","title":"<code>tolerance</code>  <code>property</code>","text":"<p>Get tolerance range. If one of the specification limits is  not specified, inf is returned (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.ucl","title":"<code>ucl</code>  <code>property</code>","text":"<p>Get upper control limit according to given strategy and  agreement (read-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.usl","title":"<code>usl</code>  <code>property</code>","text":"<p>Get the upper specification limit (rad-only).</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.describe","title":"<code>describe(exclude=(), colname=None)</code>","text":"<p>Generate descriptive statistics.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Attributes to exclude from the summary statistics, by default ()</p> </li> <li> <code>colname</code>               (<code>str | Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Column name for the resulting DataFrame, by default None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stats</code> (              <code>DataFrame</code> )          \u2013            <p>Summary statistics as pandas DataFrame. The indices of the DataFrame are the attributes that have been computed and the column name is the name of the samples.</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.distribution","title":"<code>distribution()</code>","text":"<p>Estimate the distribution by selecting the one from the provided distributions that best reflects the filtered data.</p> <p>Returns:</p> <ul> <li> <code>dist</code> (              <code>scipy.stats rv_continuous</code> )          \u2013            <p>A generic continous distribution class of best fit</p> </li> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The two-tailed p-value for the best fit</p> </li> <li> <code>shape_params</code> (              <code>Tuple[float, ...]</code> )          \u2013            <p>Estimates for any shape parameters (if applicable), followed by those for location and scale. For most random variables, shape statistics will be returned, but there are exceptions (e.g. norm). Can be used to generate values with the help of returned dist</p> </li> </ul> Notes <p>First, the p-score is calculated by performing a  Kolmogorov-Smirnov test to determine how well each distribution  fits the samples. Whatever has the highest P-score is considered the most accurate. This is because a higher p-score means the  hypothesis is closest to reality.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate strategy to calculate control limits. If no evaluate function is given the strategy is evaluated as follows:</p> <ol> <li>If variance is not stable within the samples -&gt; strategy = 'data'</li> <li>If variance and mean is stable and samples follow a normal  curve -&gt; strategy = 'norm'</li> <li>If variance and mean is stable but samples don't follow a normal curve -&gt; strategy = 'fit'</li> <li>If variance is stable but mean not and samples follow a  normal curve -&gt; strategy = 'norm'</li> <li>If variance is stable but mean not and samples don't follow a  normal curve -&gt; strategy = 'data'</li> </ol> <p>Returns:</p> <ul> <li> <code>strategy</code> (              <code>{fit, norm, data}</code> )          \u2013            <p>Evaluated strategy to calculate control limits</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.follows_norm_curve","title":"<code>follows_norm_curve(alpha=0.05, excess_test=True, skew_test=True, ad_test=False)</code>","text":"<p>Checks whether the sample data is subject to normal  distribution by performing one or more of the following tests  (depending on the input): - Skewness test - Bulge test - Anderson-Darling test</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>skew_test</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, an skew test will also be carried out, by default  True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an excess test will also be carried out, by default True</p> </li> <li> <code>ad_test</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, an Anderson Darling test will also be carried out, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>remain_h0</code> (              <code>bool</code> )          \u2013            <p>True if all p-values of the tests performed are greater than  alpha, otherwise False</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If all flags are False.</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.mask_error","title":"<code>mask_error()</code>","text":"<p>Returns a boolean mask indicating which samples are  considered errors.</p> <p>A sample is marked as an error if its value is found in the  predefined set of error values (<code>_error_values</code>).</p> <p>Returns:</p> <ul> <li> <code>Series[bool]</code>           \u2013            <p>A boolean Series where True indicates an erroneous sample.</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.mask_missing","title":"<code>mask_missing()</code>","text":"<p>Returns a boolean mask indicating which samples are missing  (NaN).</p> <p>This mask can be used to filter or analyze entries in the  <code>samples</code> attribute that contain missing values.</p> <p>Returns:</p> <ul> <li> <code>Series[bool]:</code>           \u2013            <p>A boolean Series where True indicates a missing sample.</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.mask_nok","title":"<code>mask_nok()</code>","text":"<p>Returns a boolean mask indicating which filtered samples are  out of specification.</p> <p>A sample is considered not OK (NOK) if it is less than or equal  to the lower specification limit (<code>lsl</code>) or greater than or  equal to the upper specification limit (<code>usl</code>).</p> <p>Returns:</p> <ul> <li> <code>Series[bool]</code>           \u2013            <p>A boolean Series where True indicates a sample that is out  of spec.</p> </li> </ul> Notes <p>This mask only checks for out-of-spec values and does not  consider missing or erroneous samples. Therefore, it is not the  exact inverse of <code>mask_ok()</code>, which also excludes missing and  error values. To get the full set of invalid samples, combine  this mask with <code>mask_missing()</code> and <code>mask_error()</code>.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.mask_ok","title":"<code>mask_ok()</code>","text":"<p>Returns a boolean mask indicating which samples are valid  (OK).</p> <p>A sample is considered OK if it is: - Not missing (i.e., not NaN) - Not an error (i.e., not in <code>_error_values</code>) - Within specification limits (<code>lsl</code> &lt; value &lt; <code>usl</code>)</p> <p>Returns:</p> <ul> <li> <code>Series[bool]</code>           \u2013            <p>A boolean Series where True indicates a valid sample.</p> </li> </ul> Notes <p>This mask is the logical inverse of the union of  <code>mask_missing()</code>, <code>mask_error()</code>, and <code>mask_nok()</code>. It ensures  that only fully valid samples are marked as OK, whereas  <code>mask_nok()</code> alone does not account for missing or erroneous  values.</p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.mean_ci","title":"<code>mean_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for mean of filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.median_ci","title":"<code>median_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for median of filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.plotting_positions","title":"<code>plotting_positions(nobs, alpha=0.0, beta=None)</code>  <code>staticmethod</code>","text":"<p>Generates sequence of plotting positions</p> <p>Parameters:</p> <ul> <li> <code>nobs</code>               (<code>int</code>)           \u2013            <p>Number of probability points to plot</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>alpha parameter for the plotting position of an expected order statistic</p> </li> <li> <code>beta</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>beta parameter for the plotting position of an expected order statistic. If None, then beta is set to alpha.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The plotting positions</p> </li> </ul> Notes <p>The plotting positions are given by </p> \\[ i \\in [1, nobs]) \\] \\[ \\frac{(i - \\alpha)}{nobs + 1 - \\alpha - \\beta} \\] <p>Additional information on alpha and beta see: <code>scipy.stats.mstats.plotting_positions</code></p>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.stable_mean","title":"<code>stable_mean(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the mean remains stable across the samples. </p> <p>The sample data is divided into subgroups and the mean of their  sections are checked using the F test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.stable_variance","title":"<code>stable_variance(alpha=0.05, n_sections=3)</code>","text":"<p>Test whether the variance remains stable across the samples. </p> <p>The sample data is divided into subgroups and the variances of their sections are checked using the Levene test.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>Alpha risk of hypothesis tests. If a p-value is below this  limit, the null hypothesis is rejected</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the filtered samples into,  by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>stable</code> (              <code>bool</code> )          \u2013            <p>True if the p-value &gt; alpha</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.stdev_ci","title":"<code>stdev_ci(level=0.95)</code>","text":"<p>Two sided confidence interval for standard deviation of  filtered data</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>float in (0, 1)</code>, default:                   <code>0.95</code> )           \u2013            <p>confidence level, by default 0.95</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ci_low, ci_upp : float</code>           \u2013            <p>lower and upper confidence level</p> </li> </ul>"},{"location":"statistics/estimation/process-estimator/#daspi.statistics.estimation.ProcessEstimator.z_transform","title":"<code>z_transform(x)</code>","text":"<p>Transform value to z-score.</p> <p>This method produces a value from a distribution with a mean of  0 and a standard deviation of 1. The value indicates how many standard deviations the value is from the mean.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>value to be transformed</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>z</code> (              <code>float</code> )          \u2013            <p>z-score</p> </li> </ul>"},{"location":"statistics/hypothesis/","title":"Index","text":""},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis","title":"<code>daspi.statistics.hypothesis</code>","text":""},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.anderson_darling_test","title":"<code>anderson_darling_test(sample)</code>","text":"<p>The Anderson-Darling test compares the measured values with the  theoretical values of a given distribution (in this case the normal  distribution). This test is considered to be one of the most  powerful tests for normal distribution for both small and large  sample sizes.</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The p-value for the test</p> </li> <li> <code>A_star</code> (              <code>float</code> )          \u2013            <p>The adjusted Anderson Darling test statistic</p> </li> </ul> Notes <p>This test was inspired by the Excel Addin by Charles Zaiontz, see: https://real-statistics.com/non-parametric-tests/goodness-of-fit-tests/anderson-darling-test/</p>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.all_normal","title":"<code>all_normal(*samples, p_threshold=0.05)</code>","text":"<p>Performs the Anderson-Darling test against the normal distribution for each given sample data. Only one-dimensional samples are accepted.</p> <p>Parameters:</p> <ul> <li> <code>*samples</code>               (<code>NumericSample1D</code>, default:                   <code>()</code> )           \u2013            <p>One or more one-dimensional array-like objects containing the samples.</p> </li> <li> <code>p_threshold</code>               (<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The threshold p-value for significance (default is 0.05).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if all p-values are greater than the specified p_threshold, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If p_threshold is not within the range (0, 1).</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.kolmogorov_smirnov_test","title":"<code>kolmogorov_smirnov_test(sample, dist, alternative='two-sided')</code>","text":"<p>Perform a one-sample Kolmogorov-Smirnov-Test. This hypothesis test compares the underlying distribution F(x) of a sample against a  given distribution G(x). This test is valid only for continuous  distributions.</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>dist</code>               (<code>str or scipy.stats rv_continous</code>)           \u2013            <p>If a string, it should be the name of a continous distribution  in scipy.stats, which will be used as the cdf function.</p> </li> <li> <code>alternative</code>               (<code>(two - sided, less, greater)</code>, default:                   <code>'two-sided'</code> )           \u2013            <p>The alternative hypothesis to use for the test. 'two-sided' : the cdf of the distribution is not the same as the      cdf of the sample 'less' : the cdf of the distribution is the same as or less than      the cdf of the sample 'greater' : the cdf of the distribution is the same as or greater      than the cdf of the sample</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The two-tailed p-value for the test</p> </li> <li> <code>D</code> (              <code>float</code> )          \u2013            <p>Kolmogorov-Smirnov test statistic, either D, D+ or D-.</p> </li> <li> <code>params</code> (              <code>Tuple[float, ...]</code> )          \u2013            <p>Estimates for any shape parameters (if applicable), followed by  those for location and scale. For most random variables, shape  statistics will be returned, but there are exceptions  (e.g. <code>norm</code>).</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.f_test","title":"<code>f_test(sample1, sample2)</code>","text":"<p>The F-test is a test for equal variances between two populations.  The probability distribution on which the F-test is based is called  the F-distribution (also Fisher distribution). </p> <p>Parameters:</p> <ul> <li> <code>sample1</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the first sample.</p> </li> <li> <code>sample2</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the second sample.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>The p-value for the test</p> </li> <li> <code>F</code> (              <code>float</code> )          \u2013            <p>The f-test statistic</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.levene_test","title":"<code>levene_test(sample1, sample2, heavy_tailed=False)</code>","text":"<p>Perform Levene test for equal variances. The Levene test tests the null hypothesis that all input samples are  from populations with equal variances.</p> <p>Parameters:</p> <ul> <li> <code>sample1</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the first sample.</p> </li> <li> <code>sample2</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the second sample.</p> </li> <li> <code>heavy_tailed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>set True if data is heavy tailed, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>L</code> (              <code>float</code> )          \u2013            <p>Levene test statistic</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.variance_stability_test","title":"<code>variance_stability_test(sample, n_sections=3)</code>","text":"<p>Perform Levene test for equal variances within one sample.</p> <p>Divides the data into the number of n_sections. A Levene test is  then performed between these intercepts to check whether the  variance remains stable</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the data into, by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>L</code> (              <code>float</code> )          \u2013            <p>Levene test statistic</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.mean_stability_test","title":"<code>mean_stability_test(sample, n_sections=3)</code>","text":"<p>Perform one-way ANOVA for equal means within one sample.</p> <p>Divides the data into the number of n_sections. A f_oneway test is  then performed between these intercepts to check whether the  mean remains stable</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> <li> <code>n_sections</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Amount of sections to divide the data into, by default 3</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>statistic</code> (              <code>float</code> )          \u2013            <p>The computed F statistic of the test.</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.position_test","title":"<code>position_test(sample1, sample2, equal_var=True, normal=None, u_test=True)</code>","text":"<p>calculate the test for the means of two independent samples of  scores. This is a two-sided test for the null hypothesis that 2 independent samples have identical average (expected) values. This test assumes that the populations have identical variances by default. If u_test is true and normal is false perform the Mann-Whitney U  rank test on two independent samples. The Mann-Whitney U test is a nonparametric test of the null  hypothesis that the distribution underlying sample x is the same as  the distribution underlying sample y. It is often used as a test of  difference in location between distributions.</p> <p>Parameters:</p> <ul> <li> <code>sample1</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the first sample.</p> </li> <li> <code>sample2</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the second sample.</p> </li> <li> <code>equal_var</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), perform a standard independent 2 sample test  that assumes equal population variances. If False, perform  Welch's t-test, which does not assume equal population variance</p> </li> <li> <code>normal</code>               (<code>bool or None</code>, default:                   <code>None</code> )           \u2013            <p>Set to True if both sample data are normally distributed. If  True, perform a t-test. If False and u_test is True, perform a  Mann Whitney U test. If None, an Anderson-Darling test for  normal distribution is performed for both sample data. If one of the two data sets is not normally distributed, normal is set to  False, by default None</p> </li> <li> <code>u_test</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True and data are not normally distributed, perform a Mann  Whitney U test, by default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>statistic</code> (              <code>float</code> )          \u2013            <p>f if normal, else Levene test statistic</p> </li> <li> <code>test</code> (              <code>string</code> )          \u2013            <p>name of performed test</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.variance_test","title":"<code>variance_test(sample1, sample2, normal=None, heavy_tailed=False)</code>","text":"<p>Perform test for equal variances of two independent variables. This test tests the null hypothesis that all input samples are  from populations with equal variances.</p> <p>Parameters:</p> <ul> <li> <code>sample1</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the first sample.</p> </li> <li> <code>sample2</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the second sample.</p> </li> <li> <code>normal</code>               (<code>bool or None</code>, default:                   <code>None</code> )           \u2013            <p>Set to True if both sample data are normally distributed. If  true, an F-test is performed, otherwise a Levene test. If None,  an Anderson-Darling test for normal distribution is performed  for both sample data. If one of the two data sets is not  normally distributed, normal is set to False, by default None</p> </li> <li> <code>heavy_tailed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>set True if data is heavy tailed. Is only taken into account if  normal is False , by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>statistic</code> (              <code>float</code> )          \u2013            <p>f if normal, else Levene test statistic</p> </li> <li> <code>test</code> (              <code>string</code> )          \u2013            <p>name of performed test</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.proportions_test","title":"<code>proportions_test(events1, observations1, events2, observations2, decision_threshold=1000)</code>","text":"<p>Hypothesis test for comparing two independent proportions This assumes that we have two independent binomial samples.</p> <p>Fisher's exact test is one of exact tests. Especially when more than  20% of cells have expected frequencies &lt; 5, we need to use Fisher's  exact test because applying approximation method is inadequate.  Fisher's exact test assesses the null hypothesis of independence  applying hypergeometric distribution of the numbers in the cells  of the table. </p> <p>Parameters:</p> <ul> <li> <code>events1</code>               (<code>int</code>)           \u2013            <p>Counted number of events of sample 1.</p> </li> <li> <code>observations1</code>               (<code>int</code>)           \u2013            <p>Total number of observations of sample 1.</p> </li> <li> <code>events2</code>               (<code>int</code>)           \u2013            <p>counted number of events of sample 2.</p> </li> <li> <code>observations2</code>               (<code>int</code>)           \u2013            <p>Total number of observations of sample 2.</p> </li> <li> <code>decision_threshold</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>if the sum of sample size (observations1 + observations2) is greater than decision_threshold, the Fisher exact test is performed,  by default 1000</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>statistic</code> (              <code>float</code> )          \u2013            <p>test statistic</p> </li> <li> <code>test</code> (              <code>string</code> )          \u2013            <p>name of performed test</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.kurtosis_test","title":"<code>kurtosis_test(sample)</code>","text":"<p>Two sided hypothesis test whether a dataset has normal kurtosis.</p> <p>This function tests the null hypothesis that the kurtosis of the  population from which the sample was drawn is that of the normal  distribution. Performs the calculations ignoring nan values</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>statistic</code> (              <code>float</code> )          \u2013            <p>The computed z-score for this test</p> </li> </ul>"},{"location":"statistics/hypothesis/#daspi.statistics.hypothesis.skew_test","title":"<code>skew_test(sample)</code>","text":"<p>Two sided hypothesis whether the skew is different from the  normal distribution.</p> <p>This function tests the null hypothesis that the skewness of the  population that the sample was drawn from is the same as that of a  corresponding normal distribution. Performs the calculations  ignoring nan values.</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>NumericSample1D</code>)           \u2013            <p>A one-dimensional array-like object containing the samples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>float</code> )          \u2013            <p>p-value for the test</p> </li> <li> <code>statistic</code> (              <code>float</code> )          \u2013            <p>The computed z-score for this test</p> </li> </ul>"},{"location":"statistics/montecarlo/","title":"Index","text":""},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo","title":"<code>daspi.statistics.montecarlo</code>","text":""},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits","title":"<code>SpecLimits</code>  <code>dataclass</code>","text":"<p>Class to hold the limits of a parameter specification.</p> <p>Parameters:</p> <ul> <li> <code>lower</code>               (<code>float</code>, default:                   <code>float('-inf')</code> )           \u2013            <p>The lower limit of the specification. Default is -inf.</p> </li> <li> <code>upper</code>               (<code>float</code>, default:                   <code>float('inf')</code> )           \u2013            <p>The upper limit of the specification. Default is inf.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.are_both_finite","title":"<code>are_both_finite</code>  <code>property</code>","text":"<p>Check if both lower and upper are finite values.</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.both_unbounded","title":"<code>both_unbounded</code>  <code>property</code>","text":"<p>Check if both lower and upper are -inf and inf, respectively.</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.is_unbounded","title":"<code>is_unbounded</code>  <code>property</code>","text":"<p>Check if any of lower or upper is -inf or inf.</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.nominal","title":"<code>nominal</code>  <code>property</code>","text":"<p>Nominal value, returns the average of upper and lower limits (read-only).</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.tolerance","title":"<code>tolerance</code>  <code>property</code>","text":"<p>Tolerance range, returns the difference between upper and  lower limits. (read-only)</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.__contains__","title":"<code>__contains__(value)</code>","text":"<p>Check if a given value is within the specified limits.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>The value to check against the limits.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is within the limits, False otherwise.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Checks if this SpecLimits instance is equal to another  SpecLimits instance or a tuple.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>(SpecLimits, list or tuple)</code>)           \u2013            <p>The object to compare with this instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if equal, False otherwise.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.SpecLimits.to_tuple","title":"<code>to_tuple()</code>","text":"<p>Returns the lower and upper limits as a tuple.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float]</code>           \u2013            <p>A tuple containing the lower and upper limits in order.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue","title":"<code>RandomProcessValue</code>","text":"<p>Class to generate a random process value.</p> <p>This class generates random values based on the specified distribution and parameters. The generated values are within the  specified limits and tolerance comi. The class supports three types  of distributions: normal, uniform, and circular. The generated values can be clipped to the range defined by the tolerance. The  class also provides a method to generate an array of random values.</p> <p>Parameters:</p> <ul> <li> <code>specification</code>               (<code>Specification</code>)           \u2013            <p>The specification for which the random value will be generated.</p> </li> <li> <code>dist</code>               (<code>(normal, uniform, circular)</code>, default:                   <code>'normal'</code> )           \u2013            <p>The distribution from which the random value will be generated.</p> </li> <li> <code>clip</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clip the generated value to the range defined by the tolerance. Default is False.</p> </li> </ul> <p>Examples:</p> <p>Generate a random value from a uniform distribution:</p> <pre><code>import daspi as dsp\n\nPARAM_I = dsp.Specification(limits=(5, 10))\nPARAM_II = dsp.Specification(tolerance=0.1, nominal=3)\n\nrpv = RandomProcessValue(PARAM_I, 'uniform')\nvalue = rpv()\n</code></pre> <p>Generate a array from a normal distribution with clipping:</p> <pre><code>rpv = RandomProcessValue(PARAM_II, 'normal', clip=True)\narray = rpv.generate(100_000)\n</code></pre>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Location parameter of the distribution.</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>Lower bound of the distribution.</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale factor for the distribution (6 sigma rule).</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>Upper bound of the distribution.</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.__call__","title":"<code>__call__()</code>","text":"<p>Generate a random value within the specified tolerance range.</p> <p>This method generates a random value within the specified  tolerance range, clipping the value if the clip parameter is  set to True.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generated random value.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.circular","title":"<code>circular()</code>","text":"<p>Generate a randomized offset based on a circular distribution.</p> <p>This function computes a randomized value by applying a circular  offset to the provided tolerance. The offset is determined by  multiplying the tolerance by the sine of a random angle uniformly  distributed between 0 and 2\u03c0 radians, simulating the effects of  coaxiality in all possible directions.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The modified value after applying the random circular offset.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.clip","title":"<code>clip(value, min_value, max_value)</code>  <code>staticmethod</code>","text":"<p>Clip a value between a minimum and maximum value.</p> <p>This function ensures that the provided value is within the  specified range, clipping it if it falls outside the range.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>The value to be clipped.</p> </li> <li> <code>min_value</code>               (<code>float</code>)           \u2013            <p>The minimum value of the range.</p> </li> <li> <code>max_value</code>               (<code>float</code>)           \u2013            <p>The maximum value of the range.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The clipped value.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.coaxial","title":"<code>coaxial()</code>","text":"<p>Generate a random coaxiality value.</p> <p>This method generates a random coaxiality value by applying a  circular distribution to the tolerance range. The amplitude of  the coaxiality is determined by a normal distribution within  the tolerance range, and the direction is randomized using a  uniform distribution between 0 and 2\u03c0 radians.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generated random coaxiality value.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.generate","title":"<code>generate(n)</code>","text":"<p>Generate an array of random values.</p> <p>This method generates an array of random values by calling the  appropriate distribution method (normal or uniform) for the  specified number of times.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of random values to generate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[float64]</code>           \u2013            <p>An array of random values.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.normal","title":"<code>normal()</code>","text":"<p>Generate a random value within the specified tolerance range.</p> <p>This function generates a random value within a range defined by the provided nominal and tolerance. The generated value is calculated by a normal distribution with a mean of the nominal and a standard deviation equal to the tolerance divided by 6.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generated random value within the specified tolerance  range.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.perpendicular","title":"<code>perpendicular()</code>","text":"<p>Generate a random perpendicularity value.</p> <p>This method generates a random perpendicularity value by applying  a circular distribution to the tolerance range. The amplitude of  the perpendicularity is determined by a normal distribution  within the tolerance range, and the direction is randomized  using a uniform distribution between 0 and 2\u03c0 radians. In  principle, this is exactly the same as coaxiality.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generated random perpendicularity value.</p> </li> </ul> Notes <p>The returned value is in the same unit as the specified  tolerance (usually mm). When specifying tolerances according to  GPS, a protractor is held against the measuring object, and the  maximum gap must not be larger than the specified tolerance. For further information, see: https://www.keyence.de/ss/products/measure-sys/gd-and-t/orientation-tolerance/perpendicularity.jsp</p>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.RandomProcessValue.uniform","title":"<code>uniform()</code>","text":"<p>Generate a random value within the specified tolerance range.</p> <p>This method generates a random value within the specified  tolerance range using a uniform distribution.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generated random value within the specified tolerance  range.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.Binning","title":"<code>Binning</code>","text":"<p>A class for binning precise values into a specified number of  bins.</p> <p>This class is designed to handle scenarios where precise values are  available only at certain intervals with a defined tolerance. It  provides methods to bin these values using either a linear or  quantile approach.</p> <p>The binning method is determined by the <code>kind</code> parameter: - If <code>kind</code> is set to 'linear', bin edges are calculated based on    the minimum and maximum values of the provided data. - If <code>kind</code> is set to 'quantile', bin edges are determined by the    quantiles of the input data.</p> <p>The <code>values</code> method assigns each data point to the nearest bin using  a digitizing function. For more accurate results, the  <code>round_to_nearest</code> method can be used to round the bin nominal  values.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>NDArray[float64] | Series</code>)           \u2013            <p>The precise values to be binned and used for calculations.</p> </li> <li> <code>num_bins</code>               (<code>int</code>)           \u2013            <p>The total number of bins to create.</p> </li> <li> <code>kind</code>               (<code>Literal['linear', 'quantile']</code>, default:                   <code>'quantile'</code> )           \u2013            <p>The method to calculate the bin edges, default is 'quantile'.</p> </li> <li> <code>distance</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The distance between the bins, representing the process tolerance. This parameter is only relevant when <code>kind</code> is 'linear' and must  be specified in that case. Default is None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the <code>distance</code> is not specified when <code>kind</code> is 'linear'.</p> </li> </ul> <p>Examples:</p> <p>Example 1: Binning with linear approach <pre><code>import numpy as np\nimport daspi as dsp\ndata = np.array([1.5, 2.3, 3.7, 4.1, 5.0])\nbinning = dsp.Binning(data, num_bins=3, distance=1.0, kind='linear')\nbinned_values = binning.values()\nprint(f'{binning.nominals=}')\nprint(f'{binning.indices=}')\nprint(binned_values)\n</code></pre></p> <pre><code>binning.nominals=array([2.32, 3.32, 4.32])\nbinning.indices=array([0, 0, 1, 2, 2])\n[2.32, 2.32, 3.32, 4.32, 4.32]\n</code></pre> <p>Example 2: Binning with quantile approach <pre><code>data = np.array([1.5, 2.3, 3.7, 4.1, 5.0])\nbinning = dsp.Binning(data, num_bins=3, kind='quantile')\nbinned_values = binning.values()\nprint(f'{binning.nominals=}')\nprint(f'{binning.indices=}')\nprint(binned_values)\n</code></pre></p> <pre><code>binning.nominals=array([2.3, 3.7, 4.1])\nbinning.indices=array([0, 0, 1, 2, 2])\n[2.3, 2.3, 3.7, 4.1, 4.1]\n</code></pre> <p>Example 3: Rounding nominals <pre><code>data = np.array([1.5, 2.3, 3.7, 4.1, 5.0])\nbinning = dsp.Binning(data, num_bins=3, kind='quantile')\nbinning.round_to_nearest(nearest=5, digit=1)\nbinned_values = binning.values()\nprint(f'{binning.nominals=}')\nprint(binned_values)\n</code></pre></p> <pre><code>binning.nominals=array([2.5, 3.5, 4.0])\n[2.5, 2.5, 3.5, 4.0, 4.0]\n</code></pre>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.Binning.round_to_nearest","title":"<code>round_to_nearest(nearest=5, digit=3)</code>","text":"<p>Round to the nearest multiple of <code>nearest</code>.</p> <p>This function rounds the input data to the nearest multiple of  the specified <code>nearest</code> value at the specified <code>digit</code>.</p> <p>Parameters:</p> <ul> <li> <code>nearest</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The multiple to round to, by default 5.</p> </li> <li> <code>digit</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The number of decimal places to round to, by default 3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The instance with the rounded nominals.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.Binning.values","title":"<code>values()</code>","text":"<p>Get the binned values based on the calculated indices and  nominals.</p> <p>Returns:</p> <ul> <li> <code>NDArray[float64]</code>           \u2013            <p>The binned values.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.round_to_nearest","title":"<code>round_to_nearest(x, nearest=5, digit=3)</code>","text":"<p>Round to the nearest multiple of <code>nearest</code>.</p> <p>This function rounds the input data to the nearest multiple of the  specified <code>nearest</code> value at the specified <code>digit</code>.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float | NDArray[float64] | Series</code>)           \u2013            <p>The input data to be rounded.</p> </li> <li> <code>nearest</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The multiple to round to, by default 5.</p> </li> <li> <code>digit</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The number of decimal places to round to, by default 3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | NDArray[float64] | Series</code>           \u2013            <p>The rounded data as the same type as the input.</p> </li> </ul>"},{"location":"statistics/montecarlo/#daspi.statistics.montecarlo.inclination_displacement","title":"<code>inclination_displacement(perpendicularity, height, distance)</code>","text":"<p>Calculate the displacement from a distant point due to  perpendicularity deviation. Perpendicularity is measured in mm. To  calculate the angle, the height at which perpendicularity is  measured is required as the maximum distance in the drawing.</p> \\[ displacement = distance * sin(arctan(perpendicularity/height)) \\] <p>Parameters:</p> <ul> <li> <code>perpendicularity</code>               (<code>float | NDArray[float64] | Series</code>)           \u2013            <p>The perpendicularity of the surface.</p> </li> <li> <code>distance</code>               (<code>float</code>)           \u2013            <p>The distance from the point to the surface.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | NDArray[float64] | Series</code>           \u2013            <p>The displacement of the point.</p> </li> </ul>"}]}